<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigiKipp â€“ KIPP COLOR 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
    }

    #container { 
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 720px;
      overflow: hidden;
      touch-action: none;
    }

    #container canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none;
      user-select: none;
    }

    /* UI OVERLAY */
    #uiOverlay {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 100vh;
      pointer-events: none;
      z-index: 10;
      overflow: hidden;
    }

    #hintText {
      position: absolute;
      top: 460px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 36px;
      font-weight: bold;
      color: #d4b48c;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(212,180,140,0.5);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.6));
      pointer-events: none;
      width: 360px;
      overflow: visible;
      line-height: 1.2;
      opacity: 0;
      will-change: transform, opacity, text-shadow;
      backface-visibility: hidden;
      -webkit-font-smoothing: antialiased;
    }
    

    #countdown {
      position: absolute;
      top: 475px;
      left: 180px;
      transform: translateX(-50%);
      font-size: 50px;
      font-weight: bold;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(255,255,255,0.5);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
      pointer-events: none;
      display: none;
    }
    #demoSubtitle {
      position: absolute;
      top: 413px;
      left: 50%;
      right: 5px;
      transform: none;
      text-align: left;
      font-size: 16pt;
      font-weight: bold;
      color: #f0f0f0;
      text-shadow: 0 1px 3px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
      pointer-events: none;
      display: none;
      z-index: 13;
      opacity: 0;
      transition: opacity 0.35s ease;
    }
    #jokerIconsRow {
      position: absolute;
      top: 470px;
      left: 0;
      width: 360px;
      height: 58px;
      display: none;
      z-index: 13;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.35s ease;
    }


    #jokerIconsRow img {
      position: absolute;
      width: 58px;
      height: 58px;
      object-fit: fill;
      pointer-events: auto;
      cursor: pointer;
      transform: translateX(-50%);
    }
    #zumSpielBtn {
      position: absolute;
      top: 611px;
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      height: 42px;
      background: url(button_kurz.webp) center/contain no-repeat;
      border: none;
      cursor: pointer;
      pointer-events: auto;
      z-index: 14;
      font-family: Arial, sans-serif;
      font-size: 14px;
      font-weight: bold;
      color: #d0d0d0;
      text-shadow: 0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);
      padding-top: 2px;
      opacity: 0;
      transition: opacity 0.35s ease;
    }
    #perfektGameText {
      position: absolute;
      top: 465px;
      left: 0;
      width: 360px;
      text-align: center;
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      line-height: 1.4;
      color: #e0d0b8;
      text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(200,180,140,0.3);
      white-space: nowrap;
      pointer-events: none;
      display: none;
      z-index: 13;
      transition: opacity 1.2s ease-in-out;
    }
    #perfektGameText .pgtLine {
      position: absolute;
      top: 0; left: 0; width: 100%;
      text-align: center;
      opacity: 0;
      transform: scale(0.6);
    }
    #perfektGameText .pgtHead {
      font-size: 26px;
      letter-spacing: 3px;
      color: #ffffff;
      text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 12px rgba(255,255,255,0.4);
    }
    #perfektGameText .pgtSub {
      font-size: 21px;
    }
    #startChallengeText {
      position: absolute;
      top: 451px;
      left: 0;
      width: 360px;
      text-align: center;
      font-family: Arial, sans-serif;
      font-weight: bold;
      color: #e0d0b8;
      text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(200,180,140,0.3);
      white-space: nowrap;
      pointer-events: none;
      z-index: 1;
      transition: opacity 1.2s ease-in-out;
    }
    #startChallengeText .sctLine {
      position: absolute;
      top: 0; left: 0; width: 100%;
      text-align: center;
      opacity: 0;
      transform: scale(0.6);
    }
    #startChallengeText .sctLine.sctHead {
      font-size: 26px;
      letter-spacing: 3px;
      color: #ffffff;
      text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 12px rgba(255,255,255,0.4);
    }
    #startChallengeText .sctLine.sctSub {
      font-size: 21px;
    }
    #startChallengeText .sctLine.inflating {
      animation: sctInflate 1.2s ease-out forwards;
    }
    #startChallengeText .sctLine.deflating {
      animation: sctDeflate 0.4s ease-in forwards;
    }
    @keyframes sctInflate {
      0% { transform: scale(0.6); opacity: 0; }
      20% { opacity: 1; }
      55% { transform: scale(1.08); }
      75% { transform: scale(0.98); }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes sctDeflate {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.6); opacity: 0; }
    }
    @keyframes sctBreathe {
      0% { transform: scale(1); opacity: 1; }
      40% { transform: scale(1.06); opacity: 1; }
      70% { transform: scale(0.97); opacity: 0.85; }
      100% { transform: scale(1); opacity: 0.7; }
    }
    @keyframes challengePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.55; }
    }
    @keyframes kippenPulse {
      0%, 100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
      50% { transform: translate(-50%,-50%) scale(1.15); opacity: 0.5; }
    }
    #eyeIcon {
      position: absolute;
      top: 475px;
      left: 50%;
      transform: translateX(-50%);
      width: 156px;
      height: auto;
      cursor: pointer;
      pointer-events: auto;
      filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4));
      display: none;
      z-index: 15;
      animation: eyePulse 1.5s ease-in-out infinite;
    }
    @keyframes eyePulse {
      0%, 100% { transform: translateX(-50%) scale(1); filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4)); }
      50% { transform: translateX(-50%) scale(1.12); filter: drop-shadow(0 2px 12px rgba(255,255,255,0.7)); }
    }
    .eckeHaken {
      position: absolute;
      width: 40px; height: 40px;
      display: none;
      pointer-events: auto;
      cursor: pointer;
      z-index: 5;
      border-radius: 6px;
      background: rgba(20,14,8,0.6);
      border: 2px solid rgba(212,180,140,0.5);
      color: #cedb25;
      font-size: 24px;
      font-weight: bold;
      line-height: 36px;
      text-align: center;
      text-shadow: 0 0 8px rgba(206,219,37,0.6);
      animation: hakenPulse 2s ease-in-out infinite;
    }
    @keyframes hakenPulse {
      0%, 100% { border-color: rgba(212,180,140,0.5); transform: scale(1); }
      50% { border-color: rgba(206,219,37,0.7); transform: scale(1.08); }
    }
    #kippTarget {
      position: absolute;
      width: 21px;
      height: 21px;
      border: 3px solid #4a2a10;
      border-radius: 50%;
      pointer-events: none;
      display: none;
      z-index: 12;
      transform: translate(-50%, -50%);
      animation: targetPulse 1.5s ease-in-out infinite;
    }
    #kippTarget::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 6px;
      background: #4a2a10;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    @keyframes targetPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
      50% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.5; }
    }
    #skipEndBtn {
      position: absolute;
      top: 499px;
      left: 12px;
      width: 45px;
      height: 45px;
      cursor: pointer;
      pointer-events: auto;
      display: none;
      z-index: 15;
      object-fit: contain;
    }
    #entscheidungText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      color: #d4b48c;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      line-height: 1.4;
      text-align: left;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      display: none;
      z-index: 10;
    }
    
    #instructionText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    
    #tutorialText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #spielZielText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #verdecktesKippziel {
      position: absolute;
      width: 45px;
      height: 90px;
      left: 10px;
      top: 481px;
      cursor: pointer;
      z-index: 25;
      animation: pulsate 1.5s ease-in-out infinite;
      transform-origin: center center;
    }
    
    @keyframes pulsate {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.08); }
    }

    #actionButton {
      position: absolute;
      top: 540px;
      left: 180px;
      transform: translateX(-50%);
      padding: 8px 28px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 22px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      pointer-events: auto;
      display: none;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    #actionButton:hover {
      background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%);
      transform: translateX(-50%) translateY(-2px);
    }

    #actionButton:active {
      transform: translateX(-50%) translateY(0);
      background: linear-gradient(180deg, #505050 0%, #303030 100%);
    }

    #actionButton.pulse {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    @keyframes kippPulse {
      0%, 100% { box-shadow: 0 0 4px rgba(212,180,140,0.2); }
      50% { box-shadow: 0 0 10px rgba(212,180,140,0.7), 0 0 22px rgba(212,180,140,0.4); }
    }
    .kippBtn.pulsing {
      animation: kippPulse 1.2s ease-in-out infinite;
    }

    @keyframes textGoldenPulse {
      0%, 100% { 
        transform: translateX(-50%) scale(1);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 10px rgba(212,180,140,0.3);
      }
      50% { 
        transform: translateX(-50%) scale(1.25);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
    }

    @keyframes textSinglePulse {
      0% { 
        opacity: 0;
        transform: translateX(-50%) scale(0.95) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 5px rgba(212,180,140,0.2);
      }
      65% { 
        opacity: 1;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 12px rgba(212,180,140,0.3);
      }
    }


    /* BUTTONS 1-6 */
    #kippButtons {
      position: absolute;
      top: 605px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      pointer-events: auto;
      z-index: 20;
    }

    .kippBtn {
      width: 52px;
      height: 52px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    #cwBtn, #ccwBtn {
      background: linear-gradient(180deg, #404040 0%, #303030 100%);
    }
      background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 50%, #f0f0f0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5),
                  inset 0 1px 0 rgba(255,255,255,0.9);
    }

    .kippBtn:active:not(:disabled) {
      transform: translateY(0);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    .kippBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .kippBtn.running {
      background: linear-gradient(180deg, #ffdd00 0%, #ffcc00 50%, #ffbb00 100%);
      border-color: #cc9900;
    }

    .kippBtn.clicked {
      background: linear-gradient(180deg, #4a3e28 0%, #3a2e1c 100%) !important;
      border-color: #d4b48c !important;
      color: #f0e0c0 !important;
      box-shadow: 0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35), inset 0 0 6px rgba(212,180,140,0.15);
    }

    #resetButtonWrap {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 720px;
      pointer-events: none;
      z-index: 50;
    }
    #resetButton {
      display: none;
      position: absolute;
      left: 10px;
      top: 10px;
      width: 45px;
      height: 45px;
      background: transparent;
      border: none;
      cursor: pointer;
      pointer-events: auto;
      padding: 0;
    }

    #resetButton img {
      display: block;
      width: 45px;
      height: 45px;
      object-fit: contain;
      pointer-events: none;
    }

    #soundToggle {
      display: none;
      position: absolute;
      left: 60px;
      top: 10px;
      width: 45px;
      height: 45px;
      background: transparent;
      border: none;
      cursor: pointer;
      pointer-events: auto;
      padding: 0;
    }
    #soundToggle img {
      display: block;
      width: 45px;
      height: 45px;
      object-fit: contain;
      pointer-events: none;
    }

    #backButton {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      border: 1px solid #c0c0c0;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #backButton:active {
      transform: scale(0.95);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 1px 2px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    #handIcon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      font-size: 50px;
      pointer-events: none;
      top: 270px;
      display: none;
    }

    .hidden {
      display: none !important;
    }

    /* === START-OVERLAY (transparent, Buttons Ã¼ber 3D-Szene) === */
    #startOverlay {
      position: absolute;
      top: 0;
      width: 360px; height: 720px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      pointer-events: none;
    }
    .startClickZone {
      position: absolute;
      left: 67px;
      width: 226px;
      height: 42px;
      cursor: pointer;
      pointer-events: auto;
      transition: opacity 1.2s ease-in-out;
      border: none;
      border-radius: 6px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Arial, sans-serif;
      font-weight: bold;
      font-size: 15px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: #d0d0d0;
      text-shadow: 0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);
      overflow: hidden;
      isolation: isolate;
    }
    .startClickZone::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: url('button_lang.webp') center/cover no-repeat;
      opacity: 0.87;
      border-radius: 6px;
      z-index: -1;
    }
    .startClickZone:active {
      filter: brightness(0.85);
    }
    #btnSpielen  { top: 421px; padding-top: 4px; font-size: 18px; letter-spacing: 2.5px; }
    #btnDemo     { top: 480px; padding-top: 4px; font-size: 16px; letter-spacing: 2px; }
    #btnKippPrinzip { top: 539px; padding-top: 4px; font-size: 16px; letter-spacing: 2px; }
    #btnBestScores { /* trophy icon â€” styled inline */ }
    
    /* Best Scores Overlay */
    #bestScoresOverlay {
      position: fixed; top: 0; left: 50%; transform: translateX(-50%); width: 360px; height: 720px;
      background: rgba(0,0,0,0.85);
      display: none; z-index: 20;
    }
    #bestScoresBoard {
      position: absolute;
      left: 50%; top: 46%; transform: translate(-50%,-50%);
      width: 360px; height: 565px;
    }
    #bestScoresBoard img {
      width: 100%; height: 100%;
    }
    .bsRow {
      position: absolute;
      left: 90px; right: 6%;
      text-align: left;
      font: bold 15px Arial, sans-serif;
      color: #c8c0b0;
      text-shadow: 0 1px 1px rgba(0,0,0,0.8), 0 0 4px rgba(255,255,255,0.15);
      letter-spacing: 1px;
      pointer-events: none;
      transform: translateY(-50%);
    }
    .bsNum {
      position: absolute;
      left: 13.8%;
      font: bold 17px Arial, sans-serif;
      color: #c8c0b0;
      text-shadow: 0 1px 1px rgba(0,0,0,0.8), 0 0 4px rgba(255,255,255,0.15);
      pointer-events: none;
      transform: translate(-50%,-50%);
    }
    .bsTitle {
      position: absolute;
      left: 0; right: 0; top: 15.28%;
      text-align: center;
      font: bold 13px Arial, sans-serif;
      color: #c8c0b0;
      text-shadow: 0 1px 1px rgba(0,0,0,0.8), 0 0 4px rgba(255,255,255,0.15);
      letter-spacing: 2px;
      pointer-events: none;
      transform: translateY(-50%);
    }
    #bestScoresClose {
      position: absolute;
      bottom: 63px; left: 50%; transform: translateX(-50%);
      background: url(button_lang.webp) center/contain no-repeat;
      width: 280px; height: 49px; border: none; cursor: pointer;
      font: bold 16px Arial; color: #d0d0d0; letter-spacing: 2px;
      text-shadow: 0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);
      pointer-events: auto;
    }

    /* === KIPP-PRINZIP Overlay (scrollbar, Kipp-Tipp Stil) === */
    #kippPrinzipOverlay {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      width: 360px; height: 720px;
      z-index: 25;
      display: none;
      pointer-events: auto;
    }
    #kippPrinzipOverlay .kpBg {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(30, 15, 5, 0.92);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    #kippPrinzipOverlay .kpScroll {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 40px 30px 80px;
      box-sizing: border-box;
    }
    #kippPrinzipOverlay .kpTitle {
      font-family: Arial, sans-serif;
      font-size: 22px;
      font-weight: bold;
      color: #d4a843;
      text-shadow: 0 2px 6px rgba(0,0,0,0.7);
      margin-bottom: 6px;
      letter-spacing: 2px;
      text-align: center;
    }
    #kippPrinzipOverlay .kpSubtitle {
      font-family: Arial, sans-serif;
      font-size: 14px;
      font-style: italic;
      color: #c0a888;
      text-align: center;
      margin-bottom: 28px;
    }
    #kippPrinzipOverlay .kpSection {
      margin-bottom: 22px;
    }
    #kippPrinzipOverlay .kpSectionTitle {
      font-family: Arial, sans-serif;
      font-size: 17px;
      font-weight: bold;
      color: #e8c870;
      text-shadow: 0 1px 3px rgba(0,0,0,0.6);
      margin-bottom: 8px;
      line-height: 1.3;
      text-align: center;
    }
    #kippPrinzipOverlay .kpSectionText {
      font-family: Arial, sans-serif;
      font-size: 15px;
      color: #ead7be;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      line-height: 1.65;
      text-align: center;
    }
    #kippPrinzipOverlay .kpSectionText b {
      color: #f0d898;
    }
    #kippPrinzipOverlay .kpDivider {
      width: 60%;
      height: 1px;
      background: rgba(212,168,67,0.3);
      margin: 18px auto;
    }
    #kippPrinzipOverlay .kpFooter {
      font-family: Arial, sans-serif;
      font-size: 14px;
      font-style: italic;
      color: #c0a888;
      text-align: center;
      margin-top: 24px;
      line-height: 1.5;
    }
    #kippPrinzipOverlay .kpCloseBtn {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px; height: 44px;
      background: url(button_kurz.webp) center/contain no-repeat;
      border: none; cursor: pointer;
      font-family: Arial, sans-serif;
      font-size: 16px; font-weight: bold;
      color: #d0d0d0;
      text-shadow: 0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);
      letter-spacing: 1px;
      z-index: 26;
      pointer-events: auto;
    }

    /* === ZURUECK-BUTTON (zur Startseite) === */
    /* Progress Dots - 6 Kreise fÃ¼r Fortschritt */
    #gameEndText {
      position: absolute;
      left: 0;
      top: 450px;
      width: 360px;
      text-align: center;
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      color: #d4a843;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      pointer-events: none;
      display: none;
      z-index: 14;
      letter-spacing: 0.5px;
    }
    #progressDots {
      display: none !important;
    }
    .pdot {
      width: 12px; height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(212,168,67,0.6);
      background: transparent;
      transition: all 0.4s ease;
    }
    .pdot.hit {
      background: #d4a843;
      border-color: #d4a843;
      box-shadow: 0 0 8px rgba(212,168,67,0.7);
    }
    .pdot.active {
      border-color: #ffffff;
      animation: dotPulse 1.5s ease-in-out infinite;
    }
    @keyframes dotPulse {
      0%, 100% { box-shadow: 0 0 4px rgba(255,255,255,0.3); }
      50% { box-shadow: 0 0 12px rgba(255,255,255,0.7); }
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <!-- START-OVERLAY -->
  <div id="startOverlay">
    <div id="startChallengeText">
      <div class="sctLine sctHead" id="sctHead">SPIEL ZIEL</div>
      <div class="sctLine sctSub" id="sctSub">21 SEKUNDEN</div>
      <div class="sctLine sctSub" id="sctBest" style="font-size:18px;color:#d4a843;"></div>
    </div>
    <button class="startClickZone" id="btnSpielen" disabled style="opacity:0">SPIELEN</button>
    <button class="startClickZone" id="btnDemo" disabled style="opacity:0">TUTORIAL</button>
    <button class="startClickZone" id="btnKippPrinzip" disabled style="opacity:0">KIPP Prinzip</button>
  </div>
  
  <!-- BEST SCORES Overlay -->
  <div id="bestScoresOverlay">
    <div id="bestScoresBoard">
      <img src="scoretafel.png" alt="Best Scores">
      <div class="bsTitle" id="bsTitleText">HIGHSCORES</div>
      <span class="bsNum" style="top:23.69%">1.</span>
      <span class="bsNum" style="top:30.69%">2.</span>
      <span class="bsNum" style="top:37.69%">3.</span>
      <span class="bsNum" style="top:44.64%">4.</span>
      <span class="bsNum" style="top:51.77%">5.</span>
      <span class="bsNum" style="top:58.94%">6.</span>
      <span class="bsNum" style="top:66.12%">7.</span>
      <span class="bsNum" style="top:73.25%">8.</span>
      <span class="bsNum" style="top:80.16%">9.</span>
      <span class="bsNum" style="top:87.07%">10.</span>
      <span class="bsNum" style="top:93.85%">11.</span>
      <div class="bsRow" style="top:23.69%" id="bsRow1"></div>
      <div class="bsRow" style="top:30.69%" id="bsRow2"></div>
      <div class="bsRow" style="top:37.69%" id="bsRow3"></div>
      <div class="bsRow" style="top:44.64%" id="bsRow4"></div>
      <div class="bsRow" style="top:51.77%" id="bsRow5"></div>
      <div class="bsRow" style="top:58.94%" id="bsRow6"></div>
      <div class="bsRow" style="top:66.12%" id="bsRow7"></div>
      <div class="bsRow" style="top:73.25%" id="bsRow8"></div>
      <div class="bsRow" style="top:80.16%" id="bsRow9"></div>
      <div class="bsRow" style="top:87.07%" id="bsRow10"></div>
      <div class="bsRow" style="top:93.85%" id="bsRow11"></div>
    </div>
    <button id="bestScoresClose">OK</button>
  </div>
  
  <!-- KIPP-PRINZIP Overlay -->
  <div id="kippPrinzipOverlay">
    <div class="kpBg"></div>
    <div class="kpScroll">
      <div class="kpTitle" id="kpTitle">DAS KIPP-PRINZIP</div>
      <div class="kpSubtitle" id="kpSubtitle"></div>
      <div id="kpBody"></div>
      <button class="kpCloseBtn" id="kpCloseBtn">OK</button>
    </div>
  </div>
  
  <!-- RESET-BUTTON (Body-Ebene, z-index 50 â€” Ã¼ber allen Overlays, immer klickbar) -->
  <div id="resetButtonWrap">
    <button id="resetButton"><img src="rw.webp" alt="ZurÃ¼ck"></button>
    <button id="soundToggle"><img id="soundImg" src="tonein.webp" alt="Sound"></button>
    <div id="btnBestScores" style="position:absolute; right:9px; top:11px; width:57px; height:57px; cursor:pointer; pointer-events:auto; display:block;"><img src="pokal.png" style="width:57px;height:57px;object-fit:contain;pointer-events:none;"></div>
  </div>
  
  <div id="uiOverlay">
    <div id="progressDots"><div class="pdot"></div><div class="pdot"></div><div class="pdot"></div><div class="pdot"></div><div class="pdot"></div><div class="pdot"></div></div>
    <div id="handIcon">ðŸ‘†</div>
    <div id="hintText"></div>
    <div id="instructionText"></div>
    <img id="verdecktesKippziel" src="leernohit.webp" style="display:none;">
    <div id="tutorialText"></div>
    <div id="spielZielText"></div>
    <div id="entscheidungText"></div>
    <div id="kippTarget"></div>
    <div class="eckeHaken" id="hakenQ0">âœ“</div>
    <div class="eckeHaken" id="hakenQ1">âœ“</div>
    <div class="eckeHaken" id="hakenQ2">âœ“</div>
    <div class="eckeHaken" id="hakenQ3">âœ“</div>
    <div id="countdown">30</div>
    <div id="demoSubtitle"></div>
    <div id="jokerIconsRow"></div>
    <button id="zumSpielBtn" style="display:none;">zum SPIEL</button>
    
    <!-- KIPP-TIPP Overlay -->
    <div id="perfektGameText">
      <div class="pgtLine pgtHead" id="pgtHead">SPIEL ZIEL</div>
      <div class="pgtLine pgtSub" id="pgtSub">21 SEKUNDEN</div>
    </div>
    <div id="gameEndText"></div>
    <!-- End-Buttons werden dynamisch erzeugt (button_lang.webp) -->
    <img id="eyeIcon" src="data:image/png;base64,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" />
    <img id="skipEndBtn" src="data:image/webp;base64,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" />
    <button id="actionButton"></button>
    <button id="backButton">â†»</button>
    
    <div id="richtungButtons" class="hidden" style="position:absolute;top:540px;left:50%;transform:translateX(-50%);display:flex;gap:21px;width:180px;z-index:20;">
      <button id="cwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†»</span></button>
      <button id="ccwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†º</span></button>
    </div>

    <!-- Buttons 1-6 - VernÃ¼nftig positioniert -->
    <div id="kippButtons" class="hidden">
      <button class="kippBtn" data-anzahl="1">1</button>
      <button class="kippBtn" data-anzahl="2">2</button>
      <button class="kippBtn" data-anzahl="3">3</button>
      <button class="kippBtn" data-anzahl="4">4</button>
      <button class="kippBtn" data-anzahl="5">5</button>
      <button class="kippBtn" data-anzahl="6">6</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // === GLOBAL ERROR HANDLER (console only) ===
    window.onerror = function(msg, url, line, col, error) {
      console.error('ERROR L' + line + ': ' + msg);
      return false;
    };
    window.addEventListener('unhandledrejection', function(e) {
      console.error('PROMISE: ' + (e.reason && e.reason.message || e.reason));
    });

    // === SPRACH-SYSTEM ===
    var _digikippLang = "de";
    try { _digikippLang = localStorage.getItem("digikipp_lang") || "de"; } catch(e) {}
    var T = {
      "de": {
        s1:"SPIEL ZIEL", s2:"\u2022 Finde m\u00f6glichst oft die richtige Kipp-Anzahl und -Richtung heraus, damit der W\u00fcrfel das Kippziel trifft. Hier z.B. <b>{zahl}</b> an <b>{farbe}</b>.<br>Es sind nie mehr als <b>6</b> Kipps, wenn die Richtung stimmt.<br>",
        w:"weiter", n:"Neues Spiel",
        e1:"IMMER 2 OPTIONEN", e2:"Zuerst auf Augen-Icon \u2013 W\u00fcrfelschauen (empfohlen)", e3:"Gleich auf Kippziel \u2013 Kippzug machen",
        k1:"SCHAUEN & MERKEN", k2:"Kippe den W\u00fcrfel in der Box in beliebige Richtung von Ecke zu Ecke. Merke dir m\u00f6glichst viele Zahlenpositionen in m\u00f6glichst kurzer Zeit.<br>Nach dem SCHAUEN deckst du hier links dein erstes von sechs Kippzielen auf.",
        p1:"TIPPEN & SCHUBSEN", p2:"Das Kippziel links zeigt: <b>{zahl}</b> muss zu <b>{farbe}</b> gekippt werden.<br><b>TIPPE</b> ein- bis sechsmal auf den W\u00fcrfel.<br><b>SCHUBSE</b> ihn anschlie\u00dfend in die gew\u00fcnschte Richtung, um den Kippzug auszul\u00f6sen.",
        ma:"SPIEL MIT ANLEITUNG", sp:"SPIELEN", dm:"TUTORIAL",
        wh:"WIEDERHOLEN", nm:"NEUES SPIEL", bs:"HIGHSCORES",
        ch1:"21 SEKUNDEN", ch2:"21 SEKUNDEN",
        jw:"W\u00fcrfel-Einblick<br>w\u00e4hlen",kp:"Kippen!",kb:"KIPPBLICK",eb:"ECKBLICK",
        erg:"Ergebnis: {k} KIPPS | {z}", best21:"BEST: 21 KIPPS unter 21 Sek.",
        d1:["Nach Klick aufs Auge<br>l\u00e4sst sich der W\u00fcrfel","mit dem Finger<br>durch die Box kippen."],
        d1b:["Auf Kante wippen,<br>Zahlenpositionen merken.","Auf Kante wippen,<br>Zahlenpositionen merken.","Du hast 30 Sekunden.<br>(Siehe Counter, unten)","Fr\u00fcher abbrechen?<br>Auf W\u00fcrfel tippen."],
        d2:"Klick dir dein KIPP ZIEL.",
        d3:["Das Kippziel zeigt:<br>{z} muss zu {f}.","TIPPE 1 bis 6 mal<br>auf den W\u00fcrfel.","SCHUBSE ihn anschlie\u00dfend<br>in eine beliebige Richtung."],
        d4h:"GETROFFEN!", d4m:"KNAPP DANEBEN!",
        d5a:"Tutorial wiederholen?<br>Oder die sechs", d5b:"KIPP-KNIFF-JOKER<br>kennenlernen?", d5c:"Klick auf Beginn-Button,<br>unten links.",
        fV:"Violett", fB:"Blau", fG:"Gr\u00fcn", fO:"Orange"
      },
      "en": {
        s1:"OBJECTIVE", s2:"\u2022 Find the right number of tips and the correct direction so the cube hits the target. E.g. <b>{zahl}</b> to <b>{farbe}</b>.<br>It\u2019s never more than <b>6</b> tips if the direction is right.<br>\u2022 Use <b>LOOK</b> seconds efficiently.",
        w:"next", n:"New Game",
        e1:"ALWAYS 2 OPTIONS", e2:"First tap eye icon \u2013 look at the cube (recommended)", e3:"Go straight to target \u2013 make your tipping move",
        k1:"LOOK & REMEMBER", k2:"Tip the cube inside the box in any direction from corner to corner. Memorize as many number positions as possible in the shortest time (Use LOOK seconds efficiently).<br>After LOOKING, uncover your first of six targets here on the left.",
        p1:"TAP & PUSH", p2:"The target on the left shows: <b>{zahl}</b> must reach <b>{farbe}</b>.<br><b>TAP</b> the cube one to six times.<br><b>PUSH</b> it in the desired direction to trigger the tipping move.",
        ma:"PLAY WITH TUTORIAL", sp:"PLAY", dm:"TUTORIAL",
        wh:"REPEAT", nm:"NEW GAME", bs:"HIGHSCORES",
        ch1:"21 SECONDS", ch2:"21 SECONDS",
        jw:"Cube Insight<br>choose",kp:"Tip first!",kb:"TILT VIEW",eb:"CORNER VIEW",
        erg:"Result: {k} TIPS | {z}", best21:"BEST: 21 TIPS under 21 sec.",
        d1:["After clicking the eye<br>you can tip the cube","with your finger<br>through the box."],
        d1b:["Tilt to the edge,<br>memorize number positions.","Tilt to the edge,<br>memorize number positions.","You have 30 seconds.<br>(See counter below)","Stop early?<br>Tap the cube."],
        d2:"Click to reveal your TARGET.",
        d3:["The target shows:<br>{z} must reach {f}.","TAP the cube<br>1 to 6 times.","Then PUSH it<br>in any direction."],
        d4h:"HIT!", d4m:"JUST MISSED!",
        d5a:"Repeat tutorial?<br>Or discover the six", d5b:"TILT-TRICK JOKERS?", d5c:"Click the Start button,<br>bottom left.",
        fV:"Violet", fB:"Blue", fG:"Green", fO:"Orange"
      },
      "es": {
        s1:"OBJETIVO", s2:"\u2022 Encuentra el n\u00famero correcto de volcados y la direcci\u00f3n adecuada para que el cubo alcance el objetivo. P.ej. <b>{zahl}</b> a <b>{farbe}</b>.<br>Nunca son m\u00e1s de <b>6</b> volcados si la direcci\u00f3n es correcta.<br>\u2022 Usa los segundos de <b>MIRAR</b> eficientemente.",
        w:"siguiente", n:"Nuevo Juego",
        e1:"SIEMPRE 2 OPCIONES", e2:"Primero pulsa el icono del ojo \u2013 mirar el cubo (recomendado)", e3:"Directo al objetivo \u2013 hacer tu jugada",
        k1:"MIRAR & RECORDAR", k2:"Volca el cubo dentro de la caja en cualquier direcci\u00f3n de esquina a esquina. Memoriza tantas posiciones de n\u00fameros como sea posible en el menor tiempo (Usa los segundos de MIRAR eficientemente).<br>Despu\u00e9s de MIRAR, descubre aqu\u00ed a la izquierda tu primer objetivo de seis.",
        p1:"TOCAR & EMPUJAR", p2:"El objetivo a la izquierda muestra: <b>{zahl}</b> debe llegar a <b>{farbe}</b>.<br><b>TOCA</b> el cubo de una a seis veces.<br><b>EMPUJA</b> en la direcci\u00f3n deseada para activar el volcado.",
        ma:"JUGAR CON GU\u00cdA", sp:"JUGAR", dm:"TUTORIAL",
        wh:"REPETIR", nm:"NUEVO JUEGO", bs:"HIGHSCORES",
        ch1:"21 SEGUNDOS", ch2:"21 SEGUNDOS",
        jw:"Vista del cubo<br>elegir",kp:"\u00a1Vuelca!",kb:"VISTA GIRO",eb:"VISTA ESQUINA",
        erg:"Resultado: {k} VOLCADOS | {z}", best21:"MEJOR: 21 VOLCADOS en menos de 21 seg.",
        d1:["Tras pulsar el ojo<br>puedes volcar el cubo","con el dedo<br>por la caja."],
        d1b:["Inclinar al borde,<br>memoriza las posiciones.","Inclinar al borde,<br>memoriza las posiciones.","Tienes 30 segundos.<br>(Ver contador abajo)","\u00bfTerminar antes?<br>Toca el cubo."],
        d2:"Pulsa para ver tu OBJETIVO.",
        d3:["El objetivo muestra:<br>{z} debe llegar a {f}.","TOCA el cubo<br>de 1 a 6 veces.","Luego EMP\u00daJALO<br>en cualquier direcci\u00f3n."],
        d4h:"\u00a1ACERTADO!", d4m:"\u00a1POR POCO!",
        d5a:"\u00bfRepetir tutorial?<br>O conocer los seis", d5b:"JOKERS DE<br>TRUCO DE VUELCO?", d5c:"Pulsa el botÃ³n Inicio,<br>abajo a la izquierda.",
        fV:"Violeta", fB:"Azul", fG:"Verde", fO:"Naranja"
      },
      "fr": {
        s1:"OBJECTIF", s2:"\u2022 Trouve le bon nombre de basculements et la bonne direction pour que le cube atteigne la cible. Par ex. <b>{zahl}</b> \u00e0 <b>{farbe}</b>.<br>Jamais plus de <b>6</b> basculements si la direction est bonne.<br>\u2022 Utilise les secondes de <b>REGARD</b> efficacement.",
        w:"suivant", n:"Nouvelle Partie",
        e1:"TOUJOURS 2 OPTIONS", e2:"D\u2019abord l\u2019ic\u00f4ne \u0153il \u2013 regarder le cube (recommand\u00e9)", e3:"Directement \u00e0 la cible \u2013 faire ton coup",
        k1:"REGARDER & RETENIR", k2:"Bascule le cube dans la bo\u00eete dans n\u2019importe quelle direction de coin en coin. M\u00e9morise autant de positions de chiffres que possible en un minimum de temps (Utilise les secondes de REGARD efficacement).<br>Apr\u00e8s avoir REGARD\u00c9, d\u00e9couvre ici \u00e0 gauche ta premi\u00e8re cible sur six.",
        p1:"TAPER & POUSSER", p2:"La cible \u00e0 gauche indique : <b>{zahl}</b> doit atteindre <b>{farbe}</b>.<br><b>TAPE</b> une \u00e0 six fois sur le cube.<br><b>POUSSE</b>-le dans la direction souhait\u00e9e pour d\u00e9clencher le basculement.",
        ma:"JOUER AVEC GUIDE", sp:"JOUER", dm:"TUTORIAL",
        wh:"R\u00c9P\u00c9TER", nm:"NOUVEAU JEU", bs:"HIGHSCORES",
        ch1:"21 SECONDES", ch2:"21 SECONDES",
        jw:"Aper\u00e7u du cube<br>choisir",kp:"Bascule !",kb:"VUE BASCULE",eb:"VUE COIN",
        erg:"R\u00e9sultat : {k} BASCULES | {z}", best21:"MEILLEUR : 21 BASCULES en moins de 21 sec.",
        d1:["Apr\u00e8s clic sur l\u2019\u0153il<br>tu peux basculer le cube","avec le doigt<br>dans la bo\u00eete."],
        d1b:["Basculer sur l\u2019ar\u00eate,<br>m\u00e9morise les positions.","Basculer sur l\u2019ar\u00eate,<br>m\u00e9morise les positions.","Tu as 30 secondes.<br>(Voir compteur ci-dessous)","Arr\u00eater plus t\u00f4t ?<br>Touche le cube."],
        d2:"Clique pour r\u00e9v\u00e9ler ta CIBLE.",
        d3:["La cible indique :<br>{z} doit atteindre {f}.","TAPE 1 \u00e0 6 fois<br>sur le cube.","Puis POUSSE-le<br>dans n\u2019importe quelle direction."],
        d4h:"TOUCH\u00c9 !", d4m:"TOUT PR\u00c8S !",
        d5a:"R\u00e9p\u00e9ter le tutorial ?<br>Ou d\u00e9couvrir les six", d5b:"JOKERS DE<br>TRUC DE BASCULE ?", d5c:"Clique sur le bouton DÃ©but,<br>en bas Ã  gauche.",
        fV:"Violet", fB:"Bleu", fG:"Vert", fO:"Orange"
      },
      "it": {
        s1:"OBIETTIVO", s2:"\u2022 Trova il numero giusto di ribaltamenti e la direzione corretta affinch\u00e9 il cubo raggiunga il bersaglio. Es. <b>{zahl}</b> a <b>{farbe}</b>.<br>Non sono mai pi\u00f9 di <b>6</b> ribaltamenti se la direzione \u00e8 giusta.<br>\u2022 Usa i secondi di <b>GUARDA</b> in modo efficiente.",
        w:"avanti", n:"Nuova Partita",
        e1:"SEMPRE 2 OPZIONI", e2:"Prima tocca l\u2019icona occhio \u2013 guardare il cubo (consigliato)", e3:"Diretto al bersaglio \u2013 fare la tua mossa",
        k1:"GUARDA & RICORDA", k2:"Ribalta il cubo nella scatola in qualsiasi direzione da angolo ad angolo. Memorizza quante pi\u00f9 posizioni di numeri possibile nel minor tempo (Usa i secondi di GUARDA in modo efficiente).<br>Dopo aver GUARDATO, scopri qui a sinistra il tuo primo bersaglio su sei.",
        p1:"TOCCA & SPINGI", p2:"Il bersaglio a sinistra mostra: <b>{zahl}</b> deve raggiungere <b>{farbe}</b>.<br><b>TOCCA</b> il cubo da una a sei volte.<br><b>SPINGI</b> nella direzione desiderata per attivare il ribaltamento.",
        ma:"GIOCA CON GUIDA", sp:"GIOCARE", dm:"TUTORIAL",
        wh:"RIPETERE", nm:"NUOVO GIOCO", bs:"HIGHSCORES",
        ch1:"21 SECONDI", ch2:"21 SECONDI",
        jw:"Vista del cubo<br>scegli",kp:"Ribalta!",kb:"VISTA KIPP",eb:"VISTA ANGOLO",
        erg:"Risultato: {k} RIBALTAMENTI | {z}", best21:"MIGLIORE: 21 RIBALTAMENTI sotto 21 sec.",
        d1:["Dopo il clic sull\u2019occhio<br>puoi ribaltare il cubo","con il dito<br>nella scatola."],
        d1b:["Inclinare sul bordo,<br>memorizza le posizioni.","Inclinare sul bordo,<br>memorizza le posizioni.","Hai 30 secondi.<br>(Vedi contatore sotto)","Terminare prima?<br>Tocca il cubo."],
        d2:"Clicca per rivelare il BERSAGLIO.",
        d3:["Il bersaglio mostra:<br>{z} deve raggiungere {f}.","TOCCA il cubo<br>da 1 a 6 volte.","Poi SPINGI<br>in qualsiasi direzione."],
        d4h:"COLPITO!", d4m:"QUASI PRESO!",
        d5a:"Ripetere il tutorial?<br>O scoprire i sei", d5b:"JOKER DI<br>TRUCCO DI RIBALTAMENTO?", d5c:"Clicca sul pulsante Inizio,<br>in basso a sinistra.",
        fV:"Viola", fB:"Blu", fG:"Verde", fO:"Arancione"
      },
      "tr": {
        s1:"HEDEF", s2:"\u2022 K\u00fcp\u00fcn hedefe ula\u015fmas\u0131 i\u00e7in do\u011fru devrilme say\u0131s\u0131n\u0131 ve y\u00f6n\u00fcn\u00fc bul. \u00d6rn. <b>{zahl}</b> \u2192 <b>{farbe}</b>.<br>Y\u00f6n do\u011fruysa asla <b>6</b>\u2019dan fazla devrilme olmaz.<br>\u2022 <b>BAKMA</b> saniyelerini verimli kullan.",
        w:"devam", n:"Yeni Oyun",
        e1:"HER ZAMAN 2 SE\u00c7ENEK", e2:"\u00d6nce g\u00f6z ikonuna dokun \u2013 k\u00fcpe bak (\u00f6nerilen)", e3:"Do\u011frudan hedefe \u2013 hamle yap",
        k1:"BAK & HATIRLA", k2:"K\u00fcp\u00fc kutunun i\u00e7inde herhangi bir y\u00f6ne k\u00f6\u015feden k\u00f6\u015feye devir. M\u00fcmk\u00fcn oldu\u011funca \u00e7ok say\u0131 pozisyonunu en k\u0131sa s\u00fcrede ezberle (BAKMA saniyelerini verimli kullan).<br>BAKTIKTAN sonra burada solda alt\u0131 hedefinden ilkini a\u00e7.",
        p1:"DOKUN & \u0130T", p2:"Soldaki hedef g\u00f6steriyor: <b>{zahl}</b> \u2192 <b>{farbe}</b> olmal\u0131.<br>K\u00fcpe <b>bir ile alt\u0131</b> kez <b>DOKUN</b>.<br>Sonra istedi\u011fin y\u00f6ne <b>\u0130T</b> ve devrilmeyi ba\u015flat.",
        ma:"REHBERL\u0130 OYNA", sp:"OYNA", dm:"TUTORIAL",
        wh:"TEKRAR", nm:"YEN\u0130 OYUN", bs:"HIGHSCORES",
        ch1:"21 SANÄ°YE", ch2:"21 SANÄ°YE",
        jw:"K\u00fcp g\u00f6r\u00fcn\u00fcm\u00fc<br>se\u00e7",kp:"Devir!",kb:"DEV\u0130R G\u00d6R\u00dc\u015e",eb:"K\u00d6\u015eE G\u00d6R\u00dc\u015e",
        erg:"Sonu\u00e7: {k} DEVIRME | {z}", best21:"EN \u0130Y\u0130: 21 DEVIRME, 21 sn. alt\u0131nda",
        d1:["G\u00f6ze t\u0131klad\u0131ktan sonra<br>k\u00fcp\u00fc parma\u011f\u0131nla","kutuda<br>devrilebilirsin."],
        d1b:["Kenara yat\u0131r,<br>pozisyonlar\u0131 ezberle.","Kenara yat\u0131r,<br>pozisyonlar\u0131 ezberle.","30 saniyen var.<br>(A\u015fa\u011f\u0131daki saya\u00e7a bak)","Erken bitirmek mi?<br>K\u00fcpe dokun."],
        d2:"HEDEF\u0130NI a\u00e7mak i\u00e7in t\u0131kla.",
        d3:["Hedef g\u00f6steriyor:<br>{z}, {f} olmal\u0131.","K\u00fcpe 1\u20136 kez<br>DOKUN.","Sonra \u0130T<br>herhangi bir y\u00f6ne."],
        d4h:"\u0130SABET!", d4m:"AZ KALDI!",
        d5a:"Tutorial\u0131 tekrarla?<br>Veya alt\u0131", d5b:"DEVIRME-TRICK<br>JOKER\u0130 ke\u015ffet?", d5c:"Sol alttaki BaÅŸla butonuna<br>tÄ±kla.",
        fV:"Mor", fB:"Mavi", fG:"Ye\u015fil", fO:"Turuncu"
      }
    }[_digikippLang];
    if(!T) T = {s1:"SPIEL ZIEL",s2:"",w:"weiter",n:"Neues Spiel",e1:"IMMER 2 OPTIONEN",e2:"",e3:"",k1:"SCHAUEN & MERKEN",k2:"",p1:"TIPPEN & SCHUBSEN",p2:"",
        ma:"SPIEL MIT ANLEITUNG",sp:"SPIELEN",dm:"TUTORIAL",wh:"WIEDERHOLEN",nm:"NEUES SPIEL",bs:"HIGHSCORES",ch1:"21 SEKUNDEN",ch2:"21 SEKUNDEN",jw:"W\u00fcrfel-Einblick<br>w\u00e4hlen",kp:"Kippen!",kb:"KIPPBLICK",eb:"ECKBLICK",erg:"Ergebnis: {k} KIPPS | {z}",best21:"BEST: 21 KIPPS unter 21 Sek.",
        d5a:"Tutorial wiederholen?<br>Oder die sechs",d5b:"KIPP-KNIFF-JOKER<br>kennenlernen?",d5c:"Klick auf Beginn-Button,<br>unten links.",fV:"Violett",fB:"Blau",fG:"Gr\u00fcn",fO:"Orange"};
    document.getElementById("btnSpielen").textContent = T.sp;
    document.getElementById("btnDemo").textContent = T.dm;
    
    // Kipp-Prinzip Button Text & Overlay Content
    const KIPP_PRINZIP = {
      de: {
        btn: "KIPP Prinzip",
        title: "DAS KIPP-PRINZIP",
        subtitle: "F\u00fcr Supert\u00fcftler",
        sections: [
          { t: "Der W\u00fcrfel in der Box", p: "Ein W\u00fcrfel mit drei sichtbaren Seiten, best\u00fcckt mit je vier Zahlen. Er kippt im Kreis \u2013 im oder gegen den Uhrzeigersinn. Das klingt simpel. Ist es aber nicht." },
          { t: "Warum 21 Sekunden?", p: "Der Algorithmus erzeugt sechs Kippziele: eines erreichbar mit 1 Kipp, eines mit 2, eines mit 3, eines mit 4, eines mit 5, eines mit 6.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Jeder Kipp ist locker in einer Sekunde zu schaffen. Wer jede Kippzahl und Richtung vorausplanen kann, kippt <b>entschlossen, zÃ¼gig und gezielt</b>. Und so kippt man alle 6 Kippziele locker unter 21 Sekunden ab." },
          { t: "48 Kombinationen. Maximal 6 Kipps.", p: "Es gibt genau <b>48 verschiedene Kombinationen</b> aus W\u00fcrfelfeld und Randfeld. Jede einzelne davon l\u00e4sst sich mit <b>h\u00f6chstens 6 Kipps</b> erreichen. Immer. Die entscheidende Frage ist nur: <b>Im oder gegen den Uhrzeigersinn?</b><br><br>Wer die richtige Richtung w\u00e4hlt, braucht nie mehr als 6 Kipps. 50:50 Chance \u2013 oder pures Wissen." },
          { t: "Der Logikkipp", p: "Dein Kippziel ist <b>5 an Blau</b> \u2013 und die 5 ist bereits sichtbar auf dem W\u00fcrfel? Dann brauchst du exakt <b>3 oder 6 Kipps</b>. Wer versteht warum, hat einen entscheidenden Vorteil. Mehr wird nicht verraten." },
          { t: "Der Uhrenvergleich", p: "Stell dir eine Uhr vor. Du kannst den Stundenzeiger <b>11 Stunden vorstellen</b> \u2013 oder <b>1 Stunde zur\u00fcck</b>. Du landest auf derselben Stunde.<br><br>Genau so funktioniert der W\u00fcrfel:<br>\u2022 <b>11 Kipps</b> im Uhrzeigersinn = <b>1 Kipp</b> gegen den Uhrzeigersinn<br>\u2022 <b>8 Kipps</b> in eine Richtung = <b>4 Kipps</b> in die Gegenrichtung<br>\u2022 <b>6 Kipps</b> im UZS = <b>6 Kipps</b> gegen UZS \u2013 Richtung egal<br>\u2022 <b>12 Kipps</b> in beliebige Richtung: Wieder wie am Anfang" },
          { t: "W\u00fcrfel Einblick nutzen \u2013 Zahlenpaare merken", p: "Mit dem W\u00fcrfel Einblick erh\u00e4ltst du Einblick in die verdeckten W\u00fcrfelfl\u00e4chen. Nutze sie klug. Merke dir besonders die <b>Zahlenpaare, die sich an den Kanten gegen\u00fcberliegen</b>. Dieses Wissen verk\u00fcrzt deine Kippwege drastisch." }
        ],
        footer: "Viel Spannung, Spa\u00df und Kopfzerbrechen\nmit dem W\u00fcrfel in der Box."
      },
      en: {
        btn: "TILT Principle",
        title: "THE TILT PRINCIPLE",
        subtitle: "For Super Puzzlers",
        sections: [
          { t: "The Cube in the Box", p: "A cube with three visible faces, each bearing four numbers. It tilts in a circle \u2013 clockwise or counter-clockwise. Sounds simple. But it isn\u2019t." },
          { t: "Why 21 Seconds?", p: "The algorithm generates six targets: one reachable in 1 tilt, one in 2, one in 3, one in 4, one in 5, one in 6.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Each tilt takes about one second. If you can plan every tilt count and direction in advance, you tilt <b>decisively, swiftly and precisely</b>. That\u2019s how you nail all 6 targets well under 21 seconds." },
          { t: "48 Combinations. Maximum 6 Tilts.", p: "There are exactly <b>48 different combinations</b> of cube field and border field. Every single one can be reached in <b>at most 6 tilts</b>. Always. The only question is: <b>Clockwise or counter-clockwise?</b><br><br>Choose the right direction and you\u2019ll never need more than 6 tilts. 50:50 chance \u2013 or pure knowledge." },
          { t: "The Logic Tilt", p: "Your target is <b>5 at Blue</b> \u2013 and the 5 is already visible on the cube? Then you need exactly <b>3 or 6 tilts</b>. Understand why and you gain a crucial advantage. No more clues." },
          { t: "The Clock Comparison", p: "Imagine a clock. You can move the hour hand <b>11 hours forward</b> \u2013 or <b>1 hour back</b>. Same position.<br><br>The cube works exactly the same way:<br>\u2022 <b>11 tilts</b> clockwise = <b>1 tilt</b> counter-clockwise<br>\u2022 <b>8 tilts</b> one way = <b>4 tilts</b> the other<br>\u2022 <b>6 tilts</b> CW = <b>6 tilts</b> CCW \u2013 direction doesn\u2019t matter<br>\u2022 <b>12 tilts</b> in any direction: Back to start" },
          { t: "Use Cube Insight \u2013 Remember Number Pairs", p: "The cube insight gives you a peek at the hidden cube faces. Use them wisely. Pay special attention to the <b>number pairs that sit opposite each other at the edges</b>. This knowledge drastically shortens your tilting paths." }
        ],
        footer: "Lots of suspense, fun and brainwork\nwith the cube in the box."
      },
      es: {
        btn: "Principio VOLCADO",
        title: "EL PRINCIPIO VOLCADO",
        subtitle: "Para Superingeniosos",
        sections: [
          { t: "El Cubo en la Caja", p: "Un cubo con tres caras visibles, cada una con cuatro n\u00fameros. Se vuelca en c\u00edrculo \u2013 en sentido horario o antihorario. Suena simple. Pero no lo es." },
          { t: "\u00bfPor qu\u00e9 21 Segundos?", p: "El algoritmo genera seis objetivos: uno alcanzable con 1 volcado, uno con 2, uno con 3, uno con 4, uno con 5, uno con 6.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Cada volcado se logra f\u00e1cilmente en un segundo. Quien puede planificar cada cantidad y direcci\u00f3n, vuelca <b>con conocimiento, decisi\u00f3n y precisi\u00f3n</b>. As\u00ed se alcanzan los 6 objetivos c\u00f3modamente en menos de 21 segundos." },
          { t: "48 Combinaciones. M\u00e1ximo 6 Volcados.", p: "Hay exactamente <b>48 combinaciones diferentes</b> de campo del cubo y campo del borde. Cada una se puede alcanzar con <b>m\u00e1ximo 6 volcados</b>. Siempre. La \u00fanica pregunta es: <b>\u00bfHorario o antihorario?</b><br><br>Quien elige la direcci\u00f3n correcta nunca necesita m\u00e1s de 6 volcados. 50:50 \u2013 o puro conocimiento." },
          { t: "El Volcado L\u00f3gico", p: "Tu objetivo es <b>5 en Azul</b> \u2013 \u00bfy el 5 ya es visible en el cubo? Entonces necesitas exactamente <b>3 o 6 volcados</b>. Quien entiende por qu\u00e9, tiene una ventaja decisiva. No se dice m\u00e1s." },
          { t: "La Comparaci\u00f3n del Reloj", p: "Imagina un reloj. Puedes adelantar la manecilla <b>11 horas</b> \u2013 o retroceder <b>1 hora</b>. Misma posici\u00f3n.<br><br>El cubo funciona exactamente igual:<br>\u2022 <b>11 volcados</b> horario = <b>1 volcado</b> antihorario<br>\u2022 <b>8 volcados</b> en una direcci\u00f3n = <b>4</b> en la contraria<br>\u2022 <b>6 volcados</b> horario = <b>6</b> antihorario \u2013 da igual<br>\u2022 <b>12 volcados</b>: De vuelta al inicio" },
          { t: "Usa Vista del Cubo \u2013 Recuerda los Pares", p: "La vista del cubo te da un vistazo a las caras ocultas del cubo. \u00dasalos con inteligencia. Recuerda especialmente los <b>pares de n\u00fameros opuestos en las aristas</b>. Este conocimiento acorta dr\u00e1sticamente tus caminos." }
        ],
        footer: "Mucha tensi\u00f3n, diversi\u00f3n y rompecabezas\ncon el cubo en la caja."
      },
      fr: {
        btn: "Principe BASCULE",
        title: "LE PRINCIPE BASCULE",
        subtitle: "Pour Super Casse-t\u00eates",
        sections: [
          { t: "Le Cube dans la Bo\u00eete", p: "Un cube avec trois faces visibles, chacune portant quatre chiffres. Il bascule en cercle \u2013 dans le sens horaire ou antihoraire. \u00c7a semble simple. Mais \u00e7a ne l\u2019est pas." },
          { t: "Pourquoi 21 Secondes ?", p: "L\u2019algorithme g\u00e9n\u00e8re six cibles : une atteignable en 1 bascule, une en 2, une en 3, une en 4, une en 5, une en 6.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Chaque bascule se r\u00e9alise facilement en une seconde. Celui qui peut planifier chaque nombre et direction bascule <b>en connaissance de cause, avec d\u00e9cision et pr\u00e9cision</b>. C\u2019est ainsi qu\u2019on atteint les 6 cibles confortablement en moins de 21 secondes." },
          { t: "48 Combinaisons. Maximum 6 Bascules.", p: "Il existe exactement <b>48 combinaisons diff\u00e9rentes</b> de case du cube et case du cadre. Chacune est atteignable en <b>6 bascules maximum</b>. Toujours. La seule question : <b>Sens horaire ou antihoraire ?</b><br><br>Qui choisit la bonne direction n\u2019a jamais besoin de plus de 6 bascules. 50:50 \u2013 ou pur savoir." },
          { t: "La Bascule Logique", p: "Ta cible est <b>5 au Bleu</b> \u2013 et le 5 est d\u00e9j\u00e0 visible sur le cube ? Alors il te faut exactement <b>3 ou 6 bascules</b>. Qui comprend pourquoi a un avantage d\u00e9cisif. Pas d\u2019autre indice." },
          { t: "La Comparaison de l\u2019Horloge", p: "Imagine une horloge. Tu peux avancer l\u2019aiguille de <b>11 heures</b> \u2013 ou reculer d\u2019<b>1 heure</b>. M\u00eame position.<br><br>Le cube fonctionne exactement pareil :<br>\u2022 <b>11 bascules</b> horaire = <b>1 bascule</b> antihoraire<br>\u2022 <b>8 bascules</b> dans un sens = <b>4</b> dans l\u2019autre<br>\u2022 <b>6 bascules</b> horaire = <b>6</b> antihoraire \u2013 peu importe<br>\u2022 <b>12 bascules</b> : Retour au d\u00e9part" },
          { t: "Utilise l\u2019Aper\u00e7u du Cube \u2013 Retiens les Paires", p: "L\u2019aper\u00e7u du cube te r\u00e9v\u00e8lent les faces cach\u00e9es du cube. Utilise-les avec intelligence. Retiens surtout les <b>paires de chiffres oppos\u00e9es aux ar\u00eates</b>. Ce savoir raccourcit drastiquement tes chemins." }
        ],
        footer: "Beaucoup de suspense, de plaisir\net de casse-t\u00eate avec le cube dans la bo\u00eete."
      },
      it: {
        btn: "Principio RIBALTAMENTO",
        title: "IL PRINCIPIO RIBALTAMENTO",
        subtitle: "Per Super Rompicapi",
        sections: [
          { t: "Il Cubo nella Scatola", p: "Un cubo con tre facce visibili, ciascuna con quattro numeri. Si ribalta in cerchio \u2013 in senso orario o antiorario. Sembra semplice. Ma non lo \u00e8." },
          { t: "Perch\u00e9 21 Secondi?", p: "L\u2019algoritmo genera sei bersagli: uno raggiungibile con 1 ribaltamento, uno con 2, uno con 3, uno con 4, uno con 5, uno con 6.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Ogni ribaltamento si compie facilmente in un secondo. Chi sa pianificare ogni numero e direzione ribalta <b>con decisione, rapiditÃ  e precisione</b>. Cos\u00ec si raggiungono tutti i 6 bersagli comodamente sotto i 21 secondi." },
          { t: "48 Combinazioni. Massimo 6 Ribaltamenti.", p: "Esistono esattamente <b>48 combinazioni diverse</b> di campo del cubo e campo del bordo. Ognuna \u00e8 raggiungibile con <b>massimo 6 ribaltamenti</b>. Sempre. L\u2019unica domanda: <b>Orario o antiorario?</b><br><br>Chi sceglie la direzione giusta non ha mai bisogno di pi\u00f9 di 6 ribaltamenti. 50:50 \u2013 o pura conoscenza." },
          { t: "Il Ribaltamento Logico", p: "Il tuo obiettivo \u00e8 <b>5 al Blu</b> \u2013 e il 5 \u00e8 gi\u00e0 visibile sul cubo? Allora ti servono esattamente <b>3 o 6 ribaltamenti</b>. Chi capisce perch\u00e9 ha un vantaggio decisivo. Nessun altro indizio." },
          { t: "Il Confronto con l\u2019Orologio", p: "Immagina un orologio. Puoi spostare la lancetta avanti di <b>11 ore</b> \u2013 o indietro di <b>1 ora</b>. Stessa posizione.<br><br>Il cubo funziona esattamente cos\u00ec:<br>\u2022 <b>11 ribaltamenti</b> orario = <b>1</b> antiorario<br>\u2022 <b>8 ribaltamenti</b> in una direzione = <b>4</b> nell\u2019altra<br>\u2022 <b>6 ribaltamenti</b> orario = <b>6</b> antiorario \u2013 indifferente<br>\u2022 <b>12 ribaltamenti</b>: Ritorno al via" },
          { t: "Usa Vista del Cubo \u2013 Ricorda le Coppie", p: "La vista del cubo ti rivela le facce nascoste del cubo. Usali con intelligenza. Ricorda soprattutto le <b>coppie di numeri opposti agli spigoli</b>. Questa conoscenza accorcia drasticamente i tuoi percorsi." }
        ],
        footer: "Tanta suspense, divertimento e rompicapi\ncon il cubo nella scatola."
      },
      tr: {
        btn: "DEVIRME Prensibi",
        title: "DEVIRME PRENSIBI",
        subtitle: "S\u00fcper BulmacacÄ±lar Ä°\u00e7in",
        sections: [
          { t: "Kutudaki K\u00fcp", p: "Her biri d\u00f6rt say\u0131 ta\u015f\u0131yan \u00fc\u00e7 g\u00f6r\u00fcn\u00fcr y\u00fcz\u00fc olan bir k\u00fcp. Daire i\u00e7inde devrilir \u2013 saat y\u00f6n\u00fcnde veya tersine. Basit g\u00f6r\u00fcn\u00fcr. Ama de\u011fil." },
          { t: "Neden 21 Saniye?", p: "Algoritma alt\u0131 hedef \u00fcretir: biri 1, biri 2, biri 3, biri 4, biri 5, biri 6 devirme ile ula\u015f\u0131labilir.<br><br><b>1 + 2 + 3 + 4 + 5 + 6 = 21</b><br><br>Her devirme rahatl\u0131kla bir saniyede yap\u0131l\u0131r. Her say\u0131y\u0131 ve y\u00f6n\u00fc \u00f6nceden planlayabilen, <b>kararl\u0131l\u0131kla, h\u0131zla ve isabetle</b> devirir. B\u00f6ylece 6 hedefin tamam\u0131 rahatl\u0131kla 21 saniyenin alt\u0131nda tamamlan\u0131r." },
          { t: "48 Kombinasyon. Maksimum 6 Devirme.", p: "Tam olarak <b>48 farkl\u0131 kombinasyon</b> vard\u0131r. Her biri <b>en fazla 6 devirme</b> ile ula\u015f\u0131labilir. Her zaman. Tek soru: <b>Saat y\u00f6n\u00fcnde mi, tersine mi?</b><br><br>Do\u011fru y\u00f6n\u00fc se\u00e7en asla 6\u2019dan fazlas\u0131na ihtiya\u00e7 duymaz. 50:50 \u015fans \u2013 ya da saf bilgi." },
          { t: "Mant\u0131k Devirmesi", p: "Hedefin <b>5, Mavi\u2019de</b> \u2013 ve 5 zaten k\u00fcp\u00fcn \u00fczerinde g\u00f6r\u00fcn\u00fcyor mu? O zaman tam olarak <b>3 veya 6 devirme</b> gerekir. Nedenini anlayan, belirleyici avantaja sahip olur. Daha fazla ipucu yok." },
          { t: "Saat Kar\u015f\u0131la\u015ft\u0131rmas\u0131", p: "Bir saat hayal et. Akrebi <b>11 saat ileri</b> veya <b>1 saat geri</b> alabilirsin. Ayn\u0131 konum.<br><br>K\u00fcp tam olarak b\u00f6yle \u00e7al\u0131\u015f\u0131r:<br>\u2022 <b>11 devirme</b> saat y\u00f6n\u00fcnde = <b>1 devirme</b> tersine<br>\u2022 <b>8 devirme</b> bir y\u00f6nde = <b>4</b> ters y\u00f6nde<br>\u2022 <b>6 devirme</b> SY = <b>6</b> ters \u2013 fark etmez<br>\u2022 <b>12 devirme</b>: Ba\u015fa d\u00f6n\u00fc\u015f" },
          { t: "K\u00fcp G\u00f6r\u00fcn\u00fcm\u00fc Kullan \u2013 \u00c7iftleri Hat\u0131rla", p: "K\u00fcp g\u00f6r\u00fcn\u00fcm\u00fc sana k\u00fcp\u00fcn gizli y\u00fczlerini g\u00f6sterir. Ak\u0131ll\u0131ca kullan. \u00d6zellikle <b>kenarlarda kar\u015f\u0131l\u0131kl\u0131 duran say\u0131 \u00e7iftlerini</b> hat\u0131rla. Bu bilgi devirme yollar\u0131n\u0131 b\u00fcy\u00fck \u00f6l\u00e7\u00fcde k\u0131salt\u0131r." }
        ],
        footer: "Kutudaki k\u00fcple bol gerilim,\ne\u011flence ve kafa patlatma."
      }
    };
    
    // Button-Text setzen
    const kpLang = KIPP_PRINZIP[_digikippLang] || KIPP_PRINZIP['de'];
    document.getElementById("btnKippPrinzip").textContent = kpLang.btn;
    
    // Kipp-Prinzip Overlay befÃ¼llen und Ã¶ffnen
    function showKippPrinzip() {
      const kp = KIPP_PRINZIP[_digikippLang] || KIPP_PRINZIP['de'];
      document.getElementById('kpTitle').textContent = kp.title;
      document.getElementById('kpSubtitle').textContent = kp.subtitle;
      
      let html = '';
      kp.sections.forEach((s, i) => {
        if (i > 0) html += '<div class="kpDivider"></div>';
        html += '<div class="kpSection">';
        html += '<div class="kpSectionTitle">' + s.t + '</div>';
        html += '<div class="kpSectionText">' + s.p + '</div>';
        html += '</div>';
      });
      html += '<div class="kpDivider"></div>';
      html += '<div class="kpFooter">' + kp.footer.replace(/\n/g, '<br>') + '</div>';
      
      document.getElementById('kpBody').innerHTML = html;
      document.getElementById('kippPrinzipOverlay').style.display = 'block';
    }
    
    function hideKippPrinzip() {
      document.getElementById('kippPrinzipOverlay').style.display = 'none';
    }
    
    document.getElementById('btnKippPrinzip').addEventListener('click', () => {
      showKippPrinzip();
    });
    
    document.getElementById('kpCloseBtn').addEventListener('click', () => {
      hideKippPrinzip();
    });
    document.getElementById("sctHead").textContent = T.s1;
    document.getElementById("sctSub").innerHTML = '<span style="display:inline-block;margin-top:20px;font-size:1.4em;font-weight:bold">21</span> ' + T.ch1.replace('21 ','');
    document.getElementById("pgtHead").textContent = T.s1;
    document.getElementById("pgtSub").innerHTML = '<span style="display:inline-block;margin-top:20px;font-size:1.4em;font-weight:bold">21</span> ' + T.ch1.replace('21 ','');

    // =========================
    // Scene Setup
    // =========================
    const scene = new THREE.Scene();
    // scene.background gelÃ¶scht - body background (#000000) wird sichtbar

    const containerWidth = 360;
    const containerHeight = 720;
    
    const camera = new THREE.PerspectiveCamera(
      50,
      containerWidth / containerHeight,
      0.01,
      100
    );
    
    const baseY = 2.143;
    const verticalAngle = -1.0;
    const horizontal = 0;
    const radius = 1.25;
    const southShift = -0.143;
    
    camera.position.set(
      0 + Math.sin(horizontal) * 0.5,
      baseY + radius * Math.sin(-verticalAngle),
      radius * Math.cos(verticalAngle) + Math.cos(horizontal) * 0.3 + southShift
    );
    
    camera.lookAt(0, 0.46875, 0.7 + southShift);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(360, 720);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    document.getElementById('container').appendChild(renderer.domElement);

    // =========================
    // BELEUCHTUNG
    // =========================
    // ZusÃ¤tzliche Pause-Lichter (von allen Seiten, subtil)
    const pauseLights = [
      new THREE.DirectionalLight(0xffffff, 0.25), // links
      new THREE.DirectionalLight(0xffffff, 0.25), // rechts
      new THREE.DirectionalLight(0xffffff, 0.2),  // hinten
      new THREE.DirectionalLight(0xffffff, 0.15)  // unten
    ];
    pauseLights[0].position.set(-3, 2, 1);
    pauseLights[1].position.set(3, 2, 1);
    pauseLights[2].position.set(0, 2, -3);
    pauseLights[3].position.set(0, -1, 2);
    pauseLights.forEach(l => { l.visible = false; scene.add(l); });

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.68);
    mainLight.position.set(0, 8.708, -0.46875);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 20;
    mainLight.shadow.camera.left = -2;
    mainLight.shadow.camera.right = 2;
    mainLight.shadow.camera.top = 2;
    mainLight.shadow.camera.bottom = -2;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
    fillLight.position.set(1, 3, 1);
    scene.add(fillLight);

    const fillLightSouth = new THREE.DirectionalLight(0xffffff, 0.28);
    fillLightSouth.position.set(0, 2, 4);
    scene.add(fillLightSouth);

    // =========================
    // TISCH (Ï€1 Ebene)
    // =========================
    // Boxboden (6x6 Zellen, zentriert um Achsenmittelpunkt)
    const boxbodenTexture = new THREE.TextureLoader().load('Boxboden.png');
    const boxbodenSize = 6 * 0.15625; // 0.9375
    const boxbodenGeometry = new THREE.PlaneGeometry(boxbodenSize, boxbodenSize);
    const boxbodenMaterial = new THREE.MeshStandardMaterial({ 
      map: boxbodenTexture,
      roughness: 0.8,
      metalness: 0.2
    });
    const boxboden = new THREE.Mesh(boxbodenGeometry, boxbodenMaterial);
    boxboden.rotation.x = -Math.PI / 2;
    boxboden.position.set(0, 0.001, 0.109375);
    boxboden.receiveShadow = true;
    scene.add(boxboden); // ZurÃ¼ck zu scene direkt
    
    const gridSize = 16 * 0.15625;
    const gridDivisions = 16;
    
    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xff8800, 0xff8800);
    gridHelper.position.y = 0.001;
    gridHelper.position.z = 0.421875;
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;
    scene.add(gridHelper);
    
    const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0x888888);
    gridHelper2.position.y = 0.46875;
    gridHelper2.position.z = 0.421875;
    gridHelper2.material.opacity = 0.3;
    gridHelper2.material.transparent = true;
    gridHelper2.visible = false;
    scene.add(gridHelper2);

    // KÃ¤rtchen auf dem Spieltisch (Ï€1, orange Raster)
    const cardWidth = 0.15625;   // 1 Zelle
    const cardHeight = 0.3125;   // 2 Zellen
    const cardGap = (1.25 - 6 * cardWidth) / 5 - 4 * (2.5 / 720); // 6 Karten, Gap -4px
    const cardY = 0.001 + 3 * 0.15625 + 0.002; // auf Spieltisch (3 Zellen Ã¼ber Ï€1)
    const cardZ = 0.109375 + 4 * 0.15625 + 0.15625 + 15 * (2.5 / 720); // 4 Zeilen sÃ¼dlich, + 15px

    const totalCardsWidth = 6 * cardWidth + 5 * cardGap; // TatsÃ¤chliche Breite aller KÃ¤rtchen + Gaps
    const cardStartX = -totalCardsWidth / 2 + cardWidth / 2;

    const gameCards = [];
    
    // Farb-Ziel-Texturen als HTML Images laden
    const colorTargetImages = {};
    const colorTargetTextures = {};
    const imageLoadPromises = [];
    
    const colorNames = ['blau', 'orange', 'gruen', 'violett'];
    colorNames.forEach(name => {
      const promise = new Promise((resolve) => {
        function loadImg(attempt) {
          const img = new Image();
          img.onload = () => {
            colorTargetImages[name] = img;
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            colorTargetTextures[name] = texture;
            resolve();
          };
          img.onerror = () => {
            console.warn(`${name}zielhit.webp failed (attempt ${attempt}), retrying...`);
            if (attempt < 5) {
              setTimeout(() => loadImg(attempt + 1), 500);
            } else {
              console.error(`${name}zielhit.webp failed after 5 attempts`);
              resolve();
            }
          };
          img.src = `${name}zielhit.webp?v=${attempt}`;
        }
        loadImg(1);
      });
      imageLoadPromises.push(promise);
    });
    
    // Leer-Image laden
    let leerImage = null;
    const leerPromise = new Promise((resolve) => {
      function loadLeer(attempt) {
        const img = new Image();
        img.onload = () => {
          leerImage = img;
          resolve();
        };
        img.onerror = () => {
          console.warn(`leernohit.webp failed (attempt ${attempt}), retrying...`);
          if (attempt < 5) {
            setTimeout(() => loadLeer(attempt + 1), 500);
          } else {
            console.error('leernohit.webp failed after 5 attempts');
            resolve();
          }
        };
        img.src = `leernohit.webp?v=${attempt}`;
      }
      loadLeer(1);
    });
    imageLoadPromises.push(leerPromise);
    
    // Warten bis alle Bilder geladen sind
    let texturesReady = false;
    
    Promise.all(imageLoadPromises).then(() => {
      texturesReady = true;
      checkEnableButtons();
    }).catch(() => {
      console.error('Some textures failed to load');
      texturesReady = true;
      checkEnableButtons();
    });
    
    for (let i = 0; i < 6; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = 85;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      // Canvas leer lassen - wird durch fillCard() beim Spielstart gefÃ¼llt

      const texture = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(cardWidth, cardHeight);
      const mat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        side: THREE.DoubleSide 
      });
      const plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.set(cardStartX + i * (cardWidth + cardGap), cardY, cardZ);
      plane.castShadow = true;
      plane.receiveShadow = true;
      scene.add(plane);
      plane.visible = false;

      gameCards.push({ mesh: plane, canvas: canvas, ctx: ctx, texture: texture });
    }
    
    // === Verdecktes Kippziel als 3D-Mesh auf dem Spieltisch (Canvas-basiert) ===
    const verdecktesCanvas = document.createElement('canvas');
    verdecktesCanvas.width = 85;
    verdecktesCanvas.height = 170;
    const verdecktesCtx = verdecktesCanvas.getContext('2d');
    const verdecktesCanvasTex = new THREE.CanvasTexture(verdecktesCanvas);
    
    // leernohit.webp initial draufzeichnen sobald geladen
    function drawLeernohitOnVerdecktes() {
      if (leerImage) {
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(leerImage, 0, 0, 85, 170);
        verdecktesCanvasTex.needsUpdate = true;
      } else {
        setTimeout(drawLeernohitOnVerdecktes, 50);
      }
    }
    drawLeernohitOnVerdecktes();
    
    const verdecktesGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);
    const verdecktesMat = new THREE.MeshBasicMaterial({ 
      map: verdecktesCanvasTex, 
      side: THREE.DoubleSide,
      transparent: true
    });
    const verdecktesMesh = new THREE.Mesh(verdecktesGeo, verdecktesMat);
    verdecktesMesh.rotation.x = -Math.PI / 2;
    verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
    verdecktesMesh.visible = false; // Erst sichtbar wenn Spiel startet
    scene.add(verdecktesMesh);
    
    // === Blick-Icons auf verdeckten Kippzielen ===
    // AuÃŸen links/rechts = Eckblick, mittlere 2 = Kippblick, Rest = kein Icon
    const CARD_BLICK_MAP = { 0: 'joker3.webp', 1: null, 2: 'joker2.webp', 3: 'joker2.webp', 4: null, 5: 'joker3.webp' };
    const blickIconMeshes = [];
    const blickIconSize = cardWidth; // exakt gleiche Breite wie Kippziel = 45px
    const blickIconGeo = new THREE.PlaneGeometry(blickIconSize, blickIconSize);
    
    for (let i = 0; i < 6; i++) {
      const iconSrc = CARD_BLICK_MAP[i];
      const iconMat = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.DoubleSide, depthWrite: false });
      const iconMesh = new THREE.Mesh(blickIconGeo, iconMat);
      iconMesh.rotation.x = -Math.PI / 2;
      const cx = cardStartX + i * (cardWidth + cardGap);
      iconMesh.position.set(cx, cardY + 0.002, cardZ - cardHeight / 4);
      iconMesh.visible = false;
      scene.add(iconMesh);
      blickIconMeshes.push(iconMesh);
      
      // Textur laden (nur wenn Icon vorhanden)
      if (iconSrc) {
        (function(mesh, src) {
          const img = new Image();
          img.onload = function() {
            const tex = new THREE.Texture(img);
            tex.needsUpdate = true;
            mesh.material.map = tex;
            mesh.material.needsUpdate = true;
          };
          img.src = src;
        })(iconMesh, iconSrc);
      }
    }
    
    // Blick-Icons anzeigen/verstecken (nur Karten MIT Icon)
    function showBlickIcons() {
      for (let i = 0; i < 6; i++) {
        blickIconMeshes[i].visible = (CARD_BLICK_MAP[i] !== null && kipp21CardStates[i] === 'verdeckt');
        const cx = cardStartX + i * (cardWidth + cardGap);
        blickIconMeshes[i].position.set(cx, cardY + 0.002, cardZ - cardHeight / 4);
      }
    }
    function hideBlickIcon(idx) {
      if (idx >= 0 && idx < 6) blickIconMeshes[idx].visible = false;
    }
    
    // Gespeichertes erstes Kippziel
    let erstesKippziel = null;
    
    // === Tap-Counter Anzeige in benachbarten Quadranten ===
    // Benachbarte Quadranten pro WÃ¼rfelposition
    const ADJACENT_Q = { 0: [3, 1], 1: [0, 2], 2: [1, 3], 3: [0, 2] };
    
    const tapIndicatorY = cardY + 0.003;
    const tapIndicatorSize = 0.28;
    
    function createTapIndicator() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const tex = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(tapIndicatorSize, tapIndicatorSize);
      const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.visible = false;
      scene.add(mesh);
      return { mesh, canvas, ctx, tex };
    }
    
    const tapIndicatorA = createTapIndicator();
    const tapIndicatorB = createTapIndicator();
    
    let tapCount = 0;
    
    function drawTapIndicator(indicator, n) {
      const ctx = indicator.ctx;
      ctx.clearRect(0, 0, 128, 128);
      if (n <= 0) { indicator.tex.needsUpdate = true; return; }
      
      // Ã„uÃŸerer Ring mit metallischem Silber
      const grad = ctx.createRadialGradient(64, 64, 30, 64, 64, 56);
      grad.addColorStop(0, 'rgba(200,210,220,0)');
      grad.addColorStop(0.6, 'rgba(180,190,200,0.15)');
      grad.addColorStop(0.85, 'rgba(200,210,220,0.4)');
      grad.addColorStop(1, 'rgba(160,170,180,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 128, 128);
      
      // Zahl mit Silber-Glanz
      ctx.save();
      ctx.font = 'bold 72px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Schatten fÃ¼r Tiefe
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 2;
      
      // Silber-Gradient fÃ¼r die Zahl
      const textGrad = ctx.createLinearGradient(40, 20, 88, 108);
      textGrad.addColorStop(0, '#f0f0f0');
      textGrad.addColorStop(0.3, '#c0c8d0');
      textGrad.addColorStop(0.5, '#e8ecf0');
      textGrad.addColorStop(0.7, '#a8b0b8');
      textGrad.addColorStop(1, '#d0d8e0');
      ctx.fillStyle = textGrad;
      ctx.fillText(n.toString(), 64, 62);
      
      // Glanz-Highlight oben
      ctx.shadowColor = 'transparent';
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffffff';
      ctx.fillText(n.toString(), 64, 60);
      ctx.restore();
      
      indicator.tex.needsUpdate = true;
    }
    
    function updateTapIndicators() {
      const off = 0.234375; // cubeSize/2
      const QC = {
        0: { x: -off, z: 0.109375 - off },
        1: { x:  off, z: 0.109375 - off },
        2: { x:  off, z: 0.109375 + off },
        3: { x: -off, z: 0.109375 + off }
      };
      const adj = ADJACENT_Q[currentQuadrant];
      const qA = QC[adj[0]];
      const qB = QC[adj[1]];
      
      tapIndicatorA.mesh.position.set(qA.x, tapIndicatorY, qA.z);
      tapIndicatorB.mesh.position.set(qB.x, tapIndicatorY, qB.z);
      
      drawTapIndicator(tapIndicatorA, tapCount);
      drawTapIndicator(tapIndicatorB, tapCount);
      
      tapIndicatorA.mesh.visible = tapCount > 0;
      tapIndicatorB.mesh.visible = tapCount > 0;
    }
    // =========================
    // GRADIENT SCHATTEN ÃœBER KÃ„RTCHEN
    // =========================
    // KÃ¤rtchen: X Â±0.625, Z von 0.734375 bis 1.046875
    const shadowGradCanvas = document.createElement('canvas');
    shadowGradCanvas.width = 512;
    shadowGradCanvas.height = 512;
    const sgCtx = shadowGradCanvas.getContext('2d');
    const grad = sgCtx.createLinearGradient(0, 0, 0, 512); // oben nach unten
    grad.addColorStop(0, 'rgba(0, 0, 0, 0.5)');   // Nord: schwarz
    grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)'); // Mitte: transparent
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.0)');   // SÃ¼d: transparent
    sgCtx.fillStyle = grad;
    sgCtx.fillRect(0, 0, 512, 512);

    const shadowGradTexture = new THREE.CanvasTexture(shadowGradCanvas);
    const shadowGradW = 1.25;    // 8 Zellen
    const shadowGradH = 0.3125;  // 2 Zellen = KÃ¤rtchenhÃ¶he
    const shadowGradGeo = new THREE.PlaneGeometry(shadowGradW, shadowGradH);
    const shadowGradMat = new THREE.MeshBasicMaterial({ map: shadowGradTexture, transparent: true });
    const shadowGradPlane = new THREE.Mesh(shadowGradGeo, shadowGradMat);
    shadowGradPlane.rotation.x = -Math.PI / 2;
    shadowGradPlane.position.set(0, 0.001 + 3 * 0.15625 + 0.003, 0.890625); // auf Spieltisch
    shadowGradPlane.visible = false; // Schatten komplett entfernt
    scene.add(shadowGradPlane);


    // =========================
    // ACHSEN (X und Z)
    // =========================
    const axesMaterialPi1 = new THREE.LineBasicMaterial({ 
      color: 0xff8800, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });
    
    const axesMaterial = new THREE.LineBasicMaterial({ 
      color: 0xffffff, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });

    const xAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.002, 0.109375),
      new THREE.Vector3(2.5, 0.002, 0.109375)
    ]);
    const xAxis1 = new THREE.Line(xAxisGeometry1, axesMaterialPi1);
    xAxis1.visible = false;
    scene.add(xAxis1);

    const zAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.002, -2.5),
      new THREE.Vector3(0, 0.002, 2.5)
    ]);
    const zAxis1 = new THREE.Line(zAxisGeometry1, axesMaterialPi1);
    zAxis1.visible = false;
    scene.add(zAxis1);

    const xAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.46875, 0.109375),
      new THREE.Vector3(2.5, 0.46875, 0.109375)
    ]);
    const xAxis2 = new THREE.Line(xAxisGeometry2, axesMaterial);
    xAxis2.visible = false;
    scene.add(xAxis2);

    const zAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.46875, -2.5),
      new THREE.Vector3(0, 0.46875, 2.5)
    ]);
    const zAxis2 = new THREE.Line(zAxisGeometry2, axesMaterial);
    zAxis2.visible = false;
    scene.add(zAxis2);

    // =========================
    // WÃ„NDE mit Metallwand-Textur
    // =========================
    const wallTexture = new THREE.TextureLoader().load('metallwand.webp');
    
    const wallGeometry = new THREE.BoxGeometry(0.9375, 0.46875, 0.0335);
    const wallMaterial = new THREE.MeshBasicMaterial({ 
      map: wallTexture,
      color: 0x666666  // Dunkler (40% Helligkeit)
    });
    
    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
    wall.position.set(0, 0.234375, 0.597125);
    wall.castShadow = false;
    wall.receiveShadow = true;
    scene.add(wall);

    const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
    wall2.position.set(0, 0.234375, -0.376125);
    wall2.castShadow = false;
    wall2.receiveShadow = true;
    scene.add(wall2);

    const sideWallGeometry = new THREE.BoxGeometry(0.0335, 0.46875, 1.00675);
    
    const wallLeft = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallLeft.position.set(-0.48550, 0.234375, 0.1105);
    wallLeft.castShadow = false;
    wallLeft.receiveShadow = true;
    scene.add(wallLeft);
    
    const wallRight = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallRight.position.set(0.48550, 0.234375, 0.1105);
    wallRight.castShadow = false;
    wallRight.receiveShadow = true;
    scene.add(wallRight);

    // =========================
    // SPIELTISCH TEXTUR (ersetzt codierten Rahmen)
    // =========================
    let spieltisch = null;
    const SPIEL_WIDTH = 8 * 0.15625;
    
    new THREE.TextureLoader().load('spieltisch_21.webp', (texture) => {
      const imgAspect = texture.image.height / texture.image.width;
      const height = SPIEL_WIDTH * imgAspect;
      
      const spieltischGeometry = new THREE.PlaneGeometry(SPIEL_WIDTH, height);
      const spieltischMaterial = new THREE.MeshStandardMaterial({ 
        map: texture,
        transparent: true,
        roughness: 0.8,
        metalness: 0.2,
        depthWrite: true
      });
      spieltisch = new THREE.Mesh(spieltischGeometry, spieltischMaterial);
      
      spieltisch.rotation.x = -Math.PI / 2;
      
      // Position ABSOLUT FINAL
      const xCenter = -0.625 + SPIEL_WIDTH / 2;
      const zCenter = -0.828125 + height / 2;
      const yPos = 0.001 + 3 * 0.15625;
      
      spieltisch.position.set(xCenter, yPos, zCenter);
      spieltisch.receiveShadow = true;
      spieltisch.castShadow = false;
      spieltisch.renderOrder = 1;
      
      // Matrix komplett einfrieren
      spieltisch.matrixAutoUpdate = false;
      spieltisch.updateMatrix();
      
      // Direkt zu Scene hinzufÃ¼gen
      scene.add(spieltisch);
    });

    // =========================
    // HAND-DEMO fÃ¼r Phase 1
    // =========================
    const handTexture = new THREE.TextureLoader().load('data:image/png;base64,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');
    const handWidth = 0.46875; // 3 Zellen (75% von 4x)
    const handGeometry = new THREE.PlaneGeometry(handWidth, handWidth);
    const handMaterial = new THREE.MeshBasicMaterial({ 
      map: handTexture,
      transparent: true,
      side: THREE.DoubleSide,
      alphaTest: 0.1
    });
    const handDemo = new THREE.Mesh(handGeometry, handMaterial);
    handDemo.rotation.x = -Math.PI / 2;
    // Position: Zeile 11 Oberlinie, Spalte A Mitte
    // Zeile 11 Oberlinie: -0.359375 + 7 * 0.15625 - 0.078125 = 0.656250
    handDemo.position.set(-0.625 + handWidth/2 + 0.15625, 0.001 + 3 * 0.15625 + 0.15, 0.656250 + 0.15625);
    const handOriginalPos = handDemo.position.clone(); // Ursprungsposition speichern
    handDemo.visible = false;
    scene.add(handDemo);

    // =========================
    // WÃœRFEL mit 3x3 Grid-Textur
    // =========================
    // WÃ¼rfel-Textur WebP (fÃ¼r f0, f1, f2)
    const cubeTexImg = new Image();
    cubeTexImg.src = 'data:image/webp;base64,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';
    
    // Leere WÃ¼rfelflÃ¤chen-Textur wird weiter unten als Base64 geladen
    cubeTexImg.src = 'data:image/webp;base64,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';
    const cubeSize = 0.46875;

    // Randomdeck 1-12 mischen
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    let deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);

    // Slot-Zuordnung: welche Zelle auf welcher Face â†’ deck-Index
    // f0: 7=S1, 4=S2, 2=S3, 3=S4
    // f1: 10=S1, 11=S2, 15=S3, 18=S4
    // f2: 27=S1, 26=S2, 22=S3, 19=S4
    // deck[0-3] â†’ f0 Slots, deck[4-7] â†’ f1 Slots, deck[8-11] â†’ f2 Slots

    // Canvas-Textur: 3x3 Gitter, slotMap = { "row,col": { val, rot } }
    function createFaceTexture(slotMap, imgRotation, numberAlpha) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const cell = 256 / 3;

      // WÃ¼rfel-Textur als Hintergrund (optional rotiert, SÃ¤ttigung reduziert)
      ctx.save();
      ctx.translate(128, 128);
      if (imgRotation) ctx.rotate(imgRotation);
      ctx.drawImage(cubeTexImg, -128, -128, 256, 256);
      ctx.restore();
      
      // Kontrast reduzieren mit semi-transparentem Overlay
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fillRect(0, 0, 256, 256);

      // Slot-Zellen beschriften
      const alpha = (numberAlpha !== undefined) ? numberAlpha : 1;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#2a1810';
      ctx.font = 'bold 56px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const key in slotMap) {
        const [r, c] = key.split(',').map(Number);
        const { val, rot } = slotMap[key];
        const cx = c * cell + cell / 2;
        const cy = r * cell + cell / 2;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        // Zweistellige Zahlen leicht nach links fÃ¼r optische Zentrierung
        const xOff = val >= 10 ? -4 : 0;
        ctx.fillText(val.toString(), xOff, 0);
        // Punkt bei 6 und 9: Satzpunkt nach der Zahl, gleiche Baseline
        if (val === 6 || val === 9) {
          ctx.beginPath();
          ctx.arc(xOff + 22, 18, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Rand
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#6b5040';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, 250, 250);

      return canvas;
    }

    function mat(slotMap, imgRotation, numberAlpha) {
      return new THREE.MeshStandardMaterial({
        map: new THREE.CanvasTexture(createFaceTexture(slotMap || {}, imgRotation, numberAlpha)),
        metalness: 0.3, roughness: 0.7
      });
    }

    // Leere WÃ¼rfelflÃ¤chen-Textur (Base64 embedded)
    const leereWflTexture = new THREE.TextureLoader().load('data:image/webp;base64,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');
    function matLeer() {
      return new THREE.MeshStandardMaterial({
        map: leereWflTexture,
        metalness: 0.3, roughness: 0.7
      });
    }

    // Material-Array: [+X, -X, +Y, -Y, +Z, -Z]
    // Rotationen per-Slot:
    // f2 (+Y): S1,S2 von SÃ¼den lesbar (0), S3,S4 von Westen lesbar (-Ï€/2)
    // f0 (+Z): S1,S2 von Westen lesbar (-Ï€/2), S3,S4 stehen Kopf (Ï€)
    // f1 (-X): S1,S2 stehen Kopf (Ï€), S3,S4 von SÃ¼den lesbar (Ï€/2)
    let cubeMaterial = [];
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const offset = cubeSize / 2;

    // =========================
    // KANTEN-KIPP-WÃœRFEL
    // =========================
    const kipGroup = new THREE.Group();
    kipGroup.visible = true;
    scene.add(kipGroup);
    
    const cube = new THREE.Mesh(cubeGeometry, []);
    cube.position.set(-offset, offset, 0.109375 + offset);
    cube.castShadow = true;
    cube.receiveShadow = true;
    kipGroup.add(cube);

    // Face-Definitionen fÃ¼r Rebuild mit variablem Alpha
    let faceSlots = {
      f1: {
        slotMap: { '0,0': { val: deck[4], rot: Math.PI }, '0,1': { val: deck[5], rot: Math.PI }, '1,2': { val: deck[6], rot: -Math.PI/2 }, '2,2': { val: deck[7], rot: -Math.PI/2 } },
        imgRot: Math.PI/2, matIdx: 1
      },
      f2: {
        slotMap: { '2,2': { val: deck[8], rot: 0 }, '2,1': { val: deck[9], rot: 0 }, '1,0': { val: deck[10], rot: Math.PI/2 }, '0,0': { val: deck[11], rot: Math.PI/2 } },
        imgRot: -Math.PI/2, matIdx: 2
      },
      f0: {
        slotMap: { '2,0': { val: deck[0], rot: Math.PI/2 }, '1,0': { val: deck[1], rot: Math.PI/2 }, '0,1': { val: deck[2], rot: Math.PI }, '0,2': { val: deck[3], rot: Math.PI } },
        imgRot: 0, matIdx: 4
      }
    };

    function updateFaceSlots() {
      faceSlots.f1.slotMap = { '0,0': { val: deck[4], rot: Math.PI }, '0,1': { val: deck[5], rot: Math.PI }, '1,2': { val: deck[6], rot: -Math.PI/2 }, '2,2': { val: deck[7], rot: -Math.PI/2 } };
      faceSlots.f2.slotMap = { '2,2': { val: deck[8], rot: 0 }, '2,1': { val: deck[9], rot: 0 }, '1,0': { val: deck[10], rot: Math.PI/2 }, '0,0': { val: deck[11], rot: Math.PI/2 } };
      faceSlots.f0.slotMap = { '2,0': { val: deck[0], rot: Math.PI/2 }, '1,0': { val: deck[1], rot: Math.PI/2 }, '0,1': { val: deck[2], rot: Math.PI }, '0,2': { val: deck[3], rot: Math.PI } };
    }

    function updateAllFaceTextures() {
      updateFaceSlots();
      if (cubeMaterial && cubeMaterial.length === 6) {
        cubeMaterial[1] = mat(faceSlots.f1.slotMap, faceSlots.f1.imgRot, 1);
        cubeMaterial[2] = mat(faceSlots.f2.slotMap, faceSlots.f2.imgRot, 1);
        cubeMaterial[4] = mat(faceSlots.f0.slotMap, faceSlots.f0.imgRot, 1);
        cube.material = cubeMaterial;
      }
    }

    function rebuildFaceMat(faceKey, alpha) {
      const f = faceSlots[faceKey];
      const newMat = mat(f.slotMap, f.imgRot, alpha);
      cubeMaterial[f.matIdx] = newMat;
      cube.material = cubeMaterial;
    }

    // Materialien erst wenn Textur-Image geladen
    cubeTexImg.onload = function() {
      // Start mit unsichtbaren Zahlen (alpha=0)
      cubeMaterial = [
        matLeer(),                                    // [0] +X
        mat(faceSlots.f1.slotMap, faceSlots.f1.imgRot, 0), // [1] -X = f1
        mat(faceSlots.f2.slotMap, faceSlots.f2.imgRot, 0), // [2] +Y = f2
        matLeer(),                                    // [3] -Y
        mat(faceSlots.f0.slotMap, faceSlots.f0.imgRot, 0), // [4] +Z = f0
        matLeer()                                     // [5] -Z
      ];
      cube.material = cubeMaterial;
      
      // === LOADING ANIMATION ===
      runLoadingAnimation();
    };

    // Kipp-Hilfsfunktion fÃ¼r Loading-Animation (leichtgewichtig, ohne Spiellogik)
    function loadingKipp(direction, duration) {
      return new Promise(resolve => {
        const pivotDefs = {
          'north':         { pivot: [-offset, 0, 0.109375],         axis: [1,0,0], angle: -Math.PI/2 },
          'south':         { pivot: [-offset, 0, 0.109375],         axis: [1,0,0], angle:  Math.PI/2 },
          'east':          { pivot: [0, 0, 0.109375 + offset],      axis: [0,0,1], angle: -Math.PI/2 },
          'west':          { pivot: [0, 0, 0.109375 + offset],      axis: [0,0,1], angle:  Math.PI/2 },
          'south_from_q1': { pivot: [offset, 0, 0.109375],          axis: [1,0,0], angle:  Math.PI/2 },
          'north_from_q2': { pivot: [offset, 0, 0.109375],          axis: [1,0,0], angle: -Math.PI/2 },
          'west_from_q2':  { pivot: [0, 0, 0.109375 + offset],      axis: [0,0,1], angle:  Math.PI/2 },
          'east_from_q3':  { pivot: [0, 0, 0.109375 + offset],      axis: [0,0,1], angle: -Math.PI/2 }
        };
        const def = pivotDefs[direction];
        const pivotPoint = new THREE.Vector3(def.pivot[0], def.pivot[1], def.pivot[2]);
        const rotAxis = new THREE.Vector3(def.axis[0], def.axis[1], def.axis[2]);
        
        const pivotGroup = new THREE.Group();
        pivotGroup.position.copy(pivotPoint);
        scene.add(pivotGroup);
        
        kipGroup.remove(cube);
        cube.position.sub(pivotPoint);
        pivotGroup.add(cube);
        
        const startTime = performance.now();
        function animateKipp() {
          const elapsed = performance.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
          
          pivotGroup.quaternion.setFromAxisAngle(rotAxis, def.angle * ease);
          
          if (t < 1) {
            requestAnimationFrame(animateKipp);
          } else {
            pivotGroup.quaternion.setFromAxisAngle(rotAxis, def.angle);
            cube.position.applyQuaternion(pivotGroup.quaternion);
            cube.quaternion.premultiply(pivotGroup.quaternion);
            cube.position.add(pivotPoint);
            // Snap Y
            cube.position.y = Math.round(cube.position.y * 1000) / 1000;
            if (Math.abs(cube.position.y - offset) < 0.01) cube.position.y = offset;
            
            pivotGroup.remove(cube);
            kipGroup.add(cube);
            scene.remove(pivotGroup);
            resolve();
          }
        }
        requestAnimationFrame(animateKipp);
      });
    }

    function fadeInFace(faceKey, duration) {
      return new Promise(resolve => {
        const startTime = performance.now();
        function step() {
          const t = Math.min((performance.now() - startTime) / duration, 1);
          rebuildFaceMat(faceKey, t);
          if (t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    let loadingAnimDone = false;

    async function runLoadingAnimation() {
      const fd = 400; // Fade-Dauer ms

      // 4 CW: Q3â†’Q0â†’Q1â†’Q2â†’Q3, dann 4 CCW: Q3â†’Q2â†’Q1â†’Q0â†’Q3
      const cwDirs = ['north', 'east', 'south_from_q1', 'west_from_q2'];
      const ccwDirs = ['east_from_q3', 'north_from_q2', 'west', 'south'];

      // 1) f2 obenauf in Q3 â€“ einfaden
      await fadeInFace('f2', fd);
      await new Promise(r => setTimeout(r, 150));

      // 2) Kipp 1 CW + f0 einfaden
      await loadingKipp(cwDirs[0], 500);
      await fadeInFace('f0', fd);
      await new Promise(r => setTimeout(r, 200));

      // 3) Kipp 2 CW + f1 einfaden
      await loadingKipp(cwDirs[1], 500);
      await fadeInFace('f1', fd);
      await new Promise(r => setTimeout(r, 200));

      // 4) Kipps 3-4 CW
      await loadingKipp(cwDirs[2], 450);
      await new Promise(r => setTimeout(r, 150));
      await loadingKipp(cwDirs[3], 450);
      await new Promise(r => setTimeout(r, 250));

      // 5) Kipps 5-8 CCW (leicht beschleunigend)
      await loadingKipp(ccwDirs[0], 400);
      await new Promise(r => setTimeout(r, 100));
      await loadingKipp(ccwDirs[1], 350);
      await new Promise(r => setTimeout(r, 80));
      await loadingKipp(ccwDirs[2], 300);
      await new Promise(r => setTimeout(r, 60));
      await loadingKipp(ccwDirs[3], 250);

      // Reset: WÃ¼rfel exakt in Q3, f2 obenauf
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      rebuildFaceMat('f0', 1);
      rebuildFaceMat('f1', 1);
      rebuildFaceMat('f2', 1);

      loadingAnimDone = true;
      checkEnableButtons();
    }

    // === Start-Challenge-Text: Abwechselnd blÃ¤hen ===
    let sctTimerId = null;
    let sctRunning = false;
    
    function startChallengeSequence() {
      const head = document.getElementById('sctHead');
      const sub = document.getElementById('sctSub');
      const best = document.getElementById('sctBest');
      sctRunning = true;
      let step = 0;
      
      // Personal Best Text
      const PB_TEXT = {
        de: 'DEIN BESTER: {k} KIPPS',
        en: 'YOUR BEST: {k} TILTS',
        es: 'TU MEJOR: {k} VOLCADOS',
        fr: 'TON MEILLEUR : {k} BASCULES',
        it: 'IL TUO MIGLIORE: {k} RIBALTAMENTI',
        tr: 'EN Ä°YÄ°N: {k} DEVÄ°RME'
      };
      const hasBest = false; // Personal Best auf Intro deaktiviert
      const totalPhases = hasBest ? 6 : 4;
      
      function hideAll() {
        [head, sub, best].forEach(el => {
          el.style.animation = 'none';
          el.style.opacity = '0';
          el.style.transform = 'scale(0.6)';
        });
      }
      
      function showLine(el) {
        hideAll();
        void el.offsetWidth;
        el.style.animation = 'sctInflate 1.2s ease-out forwards';
      }
      
      function hideLine(el) {
        el.style.animation = 'none';
        void el.offsetWidth;
        el.style.animation = 'sctDeflate 0.4s ease-in forwards';
      }
      
      function tick() {
        if (!sctRunning) return;
        const phase = step % totalPhases;
        if (phase === 0) { showLine(head); }
        else if (phase === 1) { hideLine(head); }
        else if (phase === 2) { showLine(sub); }
        else if (phase === 3) { hideLine(sub); }
        else if (phase === 4) { showLine(best); }
        else if (phase === 5) { hideLine(best); }
        step++;
        const isShow = (phase % 2 === 0);
        const delay = isShow ? 1400 : 400;
        sctTimerId = setTimeout(tick, delay);
      }
      tick();
    }
    
    // Nach erstem Frame starten (blockiert nicht Kipp-Animation)
    try {
      requestAnimationFrame(() => {
        try { startChallengeSequence(); } catch(e) { console.error('SCT error:', e); }
      });
    } catch(e) { console.error('SCT init error:', e); }

    function checkEnableButtons() {
      if (texturesReady && loadingAnimDone) {
        // Sequenz stoppen
        sctRunning = false;
        if (sctTimerId) { clearTimeout(sctTimerId); sctTimerId = null; }
        
        const sct = document.getElementById('startChallengeText');
        const head = document.getElementById('sctHead');
        const sub = document.getElementById('sctSub');
        const best = document.getElementById('sctBest');
        
        // Head und Best immer verstecken
        head.style.animation = 'none';
        head.style.opacity = '0';
        if (best) { best.style.animation = 'none'; best.style.opacity = '0'; }
        
        // Sub: wenn schon sichtbar (opacity > 0.5), nicht nochmal inflaten
        const subVisible = parseFloat(getComputedStyle(sub).opacity) > 0.5;
        
        if (subVisible) {
          sub.style.animation = 'none';
          sub.style.opacity = '1';
          sub.style.transform = 'scale(1)';
          // Sanftes Nachpulsieren vor Fade
          requestAnimationFrame(() => {
            sub.style.animation = 'sctBreathe 1.6s ease-in-out';
          });
        } else {
          sub.style.animation = 'none';
          sub.style.opacity = '0';
          sub.style.transform = 'scale(0.6)';
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              sub.style.animation = 'sctInflate 1.2s ease-out forwards, sctBreathe 1.6s ease-in-out 1.2s';
            });
          });
        }
        
        // Nach Halten: Container ausfaden, Buttons rein
        const fadeDelay = subVisible ? 1600 : 2800;
        setTimeout(() => {
          sct.style.opacity = '0';
          setTimeout(() => { sct.style.display = 'none'; }, 1300);
          setTimeout(() => {
            document.getElementById('btnSpielen').disabled = false;
            document.getElementById('btnSpielen').style.opacity = '1';
            document.getElementById('btnDemo').disabled = false;
            document.getElementById('btnDemo').style.opacity = '1';
            document.getElementById('btnKippPrinzip').disabled = false;
            document.getElementById('btnBestScores').style.opacity = '1';
            document.getElementById('btnKippPrinzip').style.opacity = '1';
           
          }, 700);
        }, fadeDelay);
      }
    }

    // =========================
    // 2D-TIMING SYSTEM
    // =========================
    const FIXED_SPEED = 3;
    const TARGET_MIN = 0.55;
    const STEP_MAX = 0.80;
    let targetTimeMul = 1;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function getTiming() {
      const v = FIXED_SPEED;
      const baseHold = Math.max(520, Math.round(2400 - v * 450));
      const baseKip = Math.max(160, Math.round(baseHold * 0.50));
      const baseW = baseHold;
      
      const mul = Math.max(TARGET_MIN, Math.min(1, targetTimeMul));
      
      const hold = Math.max(260, Math.round(baseHold * mul));
      const kip = Math.max(120, Math.round(baseKip * mul));
      const wfull = Math.max(260, Math.round(baseW * mul));
      
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    // =========================
    // UI ELEMENTS
    // =========================
    const hintText = document.getElementById('hintText');
    const countdown = document.getElementById('countdown');
    const actionButton = document.getElementById('actionButton');
    const backButton = document.getElementById('backButton');
    const resetButton = document.getElementById('resetButton');
    const kippButtons = document.getElementById('kippButtons');
    
    // === SOUND TOGGLE ===
    const soundToggle = document.getElementById('soundToggle');
    const soundImg = document.getElementById('soundImg');
    let soundEnabled = localStorage.getItem('digikipp_sound') !== 'off';
    
    // Personal Best
    let personalBestKipps = parseInt(localStorage.getItem('digikipp_bestKipps') || '0');
    let personalBestGames = parseInt(localStorage.getItem('digikipp_games') || '0');
    
    function updatePersonalBest(kipps) {
      try {
        personalBestGames++;
        localStorage.setItem('digikipp_games', personalBestGames);
        if (personalBestKipps === 0 || kipps < personalBestKipps) {
          personalBestKipps = kipps;
          localStorage.setItem('digikipp_bestKipps', personalBestKipps);
          return true; // new record!
        }
      } catch(e) {
        console.warn('[PB] localStorage failed:', e);
        if (personalBestKipps === 0 || kipps < personalBestKipps) {
          personalBestKipps = kipps;
          return true;
        }
      }
      return false;
    }
    
    function updateProgressDots() { /* disabled */ }
    
    // ===== BEST SCORES SYSTEM =====
    function loadBestScores() {
      try {
        const raw = localStorage.getItem('digikipp_bestscores');
        if (raw) return JSON.parse(raw);
      } catch(e) {}
      return [];
    }

    function saveTutorialScore(kipps, secs) {
      try {
        localStorage.setItem('digikipp_tutorialscore', JSON.stringify({ kipps: kipps, secs: secs }));
        // Alten Tutorial-Eintrag aus Ranking entfernen, neuen einfÃ¼gen
        const scores = loadBestScores().filter(s => !s.tutorial);
        scores.push({ kipps: kipps, secs: secs, tutorial: true });
        scores.sort((a, b) => a.secs - b.secs);
        localStorage.setItem('digikipp_bestscores', JSON.stringify(scores.slice(0, 11)));
      } catch(e) {}
    }

    function saveBestScore(kipps, secs) {
      try {
        const scores = loadBestScores();
        // Kein Duplikat einfÃ¼gen
        const exists = scores.some(s => s.kipps === kipps && s.secs === secs && !s.tutorial);
        if (!exists) {
          scores.push({ kipps: kipps, secs: secs });
        }
        scores.sort((a, b) => a.secs - b.secs);
        const top11 = scores.slice(0, 11);
        localStorage.setItem('digikipp_bestscores', JSON.stringify(top11));
        return top11;
      } catch(e) {
        return [];
      }
    }

    function renderBestScores() {
      const titleEl = document.getElementById('bsTitleText');
      if (titleEl) titleEl.textContent = T.bs || 'HIGHSCORES';
      const SEK = { de:'Sek.', en:'sec.', es:'seg.', fr:'sec.', it:'sec.', tr:'sn.' };
      const sekT = SEK[_digikippLang] || SEK.de;
      const scores = loadBestScores();
      // Cross-check: markiere Tutorial-Eintrag anhand gespeicherter Werte
      let tutData = null;
      try { const raw = localStorage.getItem('digikipp_tutorialscore'); if (raw) tutData = JSON.parse(raw); } catch(e) {}
      for (let i = 0; i < 11; i++) {
        const el = document.getElementById('bsRow' + (i + 1));
        if (!el) continue;
        if (i < scores.length) {
          const s = scores[i];
          const isTut = s.tutorial || (tutData && s.kipps === tutData.kipps && s.secs === tutData.secs);
          const prefix = isTut ? 'TUTORIAL  |  ' : '';
          if (s.secs <= 21) {
            el.innerHTML = prefix + '<span style="color:#5cb85c;font-size:17px">' + s.secs + ' ' + sekT + '</span>';
          } else {
            const over = s.secs - 21;
            el.innerHTML = prefix + '<span style="font-size:17px">21 ' + sekT + '</span> <span style="color:#c85a5a;font-size:19px">+ ' + over + '</span>';
          }
        } else {
          el.textContent = '';
        }
      }
    }

    // Real scores only
    
    function showBestScores() {
      renderBestScores();
      document.getElementById('bestScoresOverlay').style.display = 'block';
    }
    
    document.getElementById('bestScoresClose').addEventListener('click', () => {
      document.getElementById('bestScoresOverlay').style.display = 'none';
    });
    
    document.getElementById('btnBestScores').addEventListener('click', () => {
      showBestScores();
    });
    document.getElementById('btnBestScores').addEventListener('touchend', (e) => {
      e.preventDefault(); showBestScores();
    }, { passive: false });
    
    function updateSoundIcon() {
      soundImg.src = soundEnabled ? 'tonein.webp' : 'tonaus.webp';
    }
    updateSoundIcon();
    
    function positionSoundToggle() {
      soundToggle.style.display = 'block';
    }
    
    let soundToggleBusy = false;
    function handleSoundToggle(e) {
      e.stopPropagation();
      if (e.type === 'touchend') e.preventDefault();
      if (soundToggleBusy) return;
      soundToggleBusy = true;
      setTimeout(() => { soundToggleBusy = false; }, 300);
      soundEnabled = !soundEnabled;
      localStorage.setItem('digikipp_sound', soundEnabled ? 'on' : 'off');
      updateSoundIcon();
      onSoundToggle();
    }
    soundToggle.addEventListener('click', handleSoundToggle);
    soundToggle.addEventListener('touchend', handleSoundToggle, { passive: false });
    
    // resetButton anzeigen (feste Position A-B, Zeile 1-2, 6px sÃ¼dlich)
    function positionResetButton() {
      resetButton.style.display = 'block'; soundToggle.style.display = 'block';
      positionSoundToggle();
    }
    
    // === AUDIO ENGINE ===
    const bgMusic = new Audio('colorloop.mp3');
    bgMusic.preload = 'auto';
    bgMusic.loop = true;
    bgMusic.volume = 0.35;
    let bgMusicUnlocked = false;
    
    bgMusic.addEventListener('error', () => {
      console.warn('[AUDIO] colorloop.mp3 konnte nicht geladen werden!');
    });
    
    // Sofort versuchen â€” klappt oft weil User per Tap von index.html kam
    if (soundEnabled) {
      bgMusic.play().then(() => {
        bgMusicUnlocked = true;
        console.log('[AUDIO] bgMusic autoplay success');
      }).catch(() => {
        console.log('[AUDIO] bgMusic autoplay blocked â€” waiting for touch');
      });
    }
    
    // KlackCrop als AudioBuffer fÃ¼r prÃ¤zises Timing (kein Latenz-Delay)
    let klackBuffer = null;
    let audioCtx = null;
    function initAudioContext() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      fetch('KippKlack.wav')
        .then(r => r.arrayBuffer())
        .then(buf => audioCtx.decodeAudioData(buf))
        .then(decoded => { klackBuffer = decoded; })
        .catch(e => console.warn('KlackCrop load failed:', e));
    }
    
    let audioCtxResumed = false;
    function playKlack() {
      if (!audioCtx || !klackBuffer) return;
      if (!audioCtxResumed) {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); return; }
        audioCtxResumed = true;
      }
      const src = audioCtx.createBufferSource();
      src.buffer = klackBuffer;
      src.connect(audioCtx.destination);
      src.start(0);
    }
    
    function startBgMusic() {
      if (!soundEnabled) return;
      initAudioContext();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      bgMusic.currentTime = 0;
      bgMusic.play().catch(() => {});
    }
    
    function stopBgMusic() {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }
    
    // Sound-Toggle: Musik sofort starten/stoppen
    function onSoundToggle() {
      if (soundEnabled) {
        // Wie unlockAndPlayBgMusic â€” AudioContext + Play
        initAudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        bgMusicUnlocked = true;
        bgMusic.play().catch(() => {});
      } else {
        bgMusic.pause();
      }
    }
    
    // Erster User-Touch: AudioContext initialisieren + Musik starten (Browser-Policy)
    function unlockAndPlayBgMusic() {
      initAudioContext();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      audioCtxResumed = true;
      if (!soundEnabled) return;
      bgMusicUnlocked = true;
      bgMusic.play().then(() => {
        console.log('[AUDIO] bgMusic playing');
      }).catch((err) => {
        console.log('[AUDIO] bgMusic deferred:', err.message);
        // Retry nach kurzem Delay
        setTimeout(() => {
          if (soundEnabled && bgMusic.paused && bgMusicUnlocked) {
            bgMusic.play().catch(() => {});
          }
        }, 500);
      });
    }
    // Falls play() fehlschlug weil Datei noch lÃ¤dt
    bgMusic.addEventListener('canplaythrough', () => {
      if (soundEnabled && bgMusic.paused) {
        bgMusic.play().then(() => {
          bgMusicUnlocked = true;
        }).catch(() => {});
      }
    });
    // Erster Touch IRGENDWO: Audio unlocken (capture=true, damit stopPropagation nicht blockiert)
    document.addEventListener('touchstart', function initOnTouch() {
      unlockAndPlayBgMusic();
      document.removeEventListener('touchstart', initOnTouch, true);
    }, { once: true, capture: true });
    document.addEventListener('click', function initOnClick() {
      unlockAndPlayBgMusic();
      document.removeEventListener('click', initOnClick, true);
    }, { once: true, capture: true });
    
    // WICHTIG: Button disabled bis Texturen geladen sind
    actionButton.disabled = true;

    // =========================
    // SPIELLOGIK: Treffer-PrÃ¼fung
    // =========================
    let topFace = 'f2'; // Anfangslage beim Spieleintritt

    // Physische Top-Face Erkennung aus WÃ¼rfel-Quaternion
    function getPhysicalTopFace() {
      const q = new THREE.Quaternion();
      cube.getWorldQuaternion(q);
      // Face-Normalen: f0=+Z(0,0,1), f1=-X(-1,0,0), f2=+Y(0,1,0)
      const normals = {
        f0: new THREE.Vector3(0, 0, 1).applyQuaternion(q),
        f1: new THREE.Vector3(-1, 0, 0).applyQuaternion(q),
        f2: new THREE.Vector3(0, 1, 0).applyQuaternion(q)
      };
      let best = 'f2', bestY = -Infinity;
      for (const [face, n] of Object.entries(normals)) {
        if (n.y > bestY) { bestY = n.y; best = face; }
      }
      return best;
    }

    function advanceTopFace() {
      const cw  = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccw = { f2: 'f1', f1: 'f0', f0: 'f2' };
      const oldFace = topFace;
      topFace = (kippDirection === 'cw') ? cw[topFace] : ccw[topFace];
    }

    // Welche Nachbarfarbe hat jeder Slot pro Quadrant
    const SLOT_NEIGHBOR_COLORS = {
      0: { S1: 'blau',    S2: 'violett', S3: 'gruen',   S4: 'orange'  },
      1: { S1: 'orange',  S2: 'blau',    S3: 'violett', S4: 'gruen'   },
      2: { S1: 'gruen',   S2: 'orange',  S3: 'blau',    S4: 'violett' },
      3: { S1: 'violett', S2: 'gruen',   S3: 'orange',  S4: 'blau'    }
    };

    // Zielkreis-Positionen pro Quadrant (3D-Koordinaten)
    const KIPP_TARGET_POS_3D = {
      0: new THREE.Vector3(-0.15625, 0.48, -0.046875),  // Q0 NW: Zeilen 5/6, Spalten C/D
      1: new THREE.Vector3( 0.15625, 0.48, -0.046875),  // Q1 NE: Zeilen 5/6, Spalten E/F
      2: new THREE.Vector3( 0.15625, 0.48,  0.265625),  // Q2 SE: Zeilen 7/8, Spalten E/F
      3: new THREE.Vector3(-0.15625, 0.48,  0.265625)   // Q3 SW: Zeilen 7/8, Spalten C/D
    };

    function updateKippTargetPosition() {
      const pos3D = KIPP_TARGET_POS_3D[currentQuadrant].clone();
      pos3D.project(camera);
      const targetEl = document.getElementById('kippTarget');
      targetEl.style.left = ((pos3D.x * 0.5 + 0.5) * 360) + 'px';
      targetEl.style.top = ((-pos3D.y * 0.5 + 0.5) * 720) + 'px';
    }

    // 4 Farbfelder pro Quadrant (fÃ¼r Nicht-Treffer-Animation)
    const QUADRANT_COLORS = {
      0: ['Nord_C', 'Nord_D', 'West_5', 'West_6'],
      1: ['Nord_E', 'Nord_F', 'Ost_5',  'Ost_6'],
      2: ['SÃ¼d_E',  'SÃ¼d_F',  'Ost_7',  'Ost_8'],
      3: ['SÃ¼d_C',  'SÃ¼d_D',  'West_7', 'West_8']
    };

    // Material-Index pro Face (BoxGeometry: [+X,-X,+Y,-Y,+Z,-Z])
    const TOP_FACE_MAT_IDX = { f0: 4, f1: 1, f2: 2 };

    // DesÃ¤tturierte Versionen der Spielfarben fÃ¼r das KÃ¤rtchen
    const DESAT_COLORS = {
      violett: '#6b5a6b',
      blau:    '#5a6b7b',
      gruen:   '#5b7b6b',
      orange:  '#7b6b5a'
    };

    function checkTreffer() {
      const card = gameCards[activeCardIdx];
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };

      // Ist card.zahl sichtbar?
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === card.zahl) { hitSlot = slot; break; }
      }
      if (!hitSlot) return false;

      // Nachbarfarbe prÃ¼fen
      const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
      if (neighborColor !== card.color.name) return false;
      return { slot: hitSlot, quadrant: currentQuadrant };
    }

    // =========================
    // ON-TARGET Pulse: Kippziel-Karte pulsiert wenn WÃ¼rfel richtig liegt
    // =========================
    function checkOnTargetAfterKipp() {
      if (gamePhase !== 'kipp21' || !kipp21Active) return;
      if (!kipp21CardStates.includes('offen')) return;
      const result = checkTreffer();
      if (!result) return;
      // WÃ¼rfel liegt richtig â†’ Timer SOFORT stoppen + sperren
      kipp21StopRoundTimer();
      kipp21HitLock = true;
      const openIdx = kipp21CardStates.indexOf('offen');
      if (openIdx >= 0 && gameCards[openIdx]?.mesh) {
        const mesh = gameCards[openIdx].mesh;
        const orig = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };
        // 2x Pulse
        mesh.scale.set(orig.x * 1.35, orig.y * 1.35, orig.z * 1.35);
        setTimeout(() => {
          mesh.scale.set(orig.x, orig.y, orig.z);
          setTimeout(() => {
            mesh.scale.set(orig.x * 1.25, orig.y * 1.25, orig.z * 1.25);
            setTimeout(() => {
              mesh.scale.set(orig.x, orig.y, orig.z);
              // Nach Pulse: automatisch Treffer bestÃ¤tigen
              if (kipp21CardStates[openIdx] === 'offen') {
                kipp21OnCardTap(openIdx, true);
              }
            }, 200);
          }, 150);
        }, 200);
      }
    }

    // Zielposition fÃ¼r Kippziel-Fluganimation bei Treffer
    // Card (1Ã—2 Zellen): Zahl-HÃ¤lfte auf Slot (innen), Farb-HÃ¤lfte auf Rahmen-Farbfeld (auÃŸen)
    // rotZ: 0=Zahlâ†’Nord, Ï€=Zahlâ†’SÃ¼d, -Ï€/2=Zahlâ†’Ost, Ï€/2=Zahlâ†’West
    const HIT_TARGETS = {
      0: { // Q0 (NW)
        S1: { x: -0.46875, z:  0.03125,  rotZ: -Math.PI/2 },  // West_6 (blau) â†’ Zahlâ†’Ost(innen)
        S2: { x: -0.46875, z: -0.125,    rotZ: -Math.PI/2 },  // West_5 (violett) â†’ Zahlâ†’Ost(innen)
        S3: { x: -0.23438, z: -0.359375, rotZ: Math.PI },      // Nord_C (gruen) â†’ Zahlâ†’SÃ¼d(innen)
        S4: { x: -0.07813, z: -0.359375, rotZ: Math.PI }       // Nord_D (orange) â†’ Zahlâ†’SÃ¼d(innen)
      },
      1: { // Q1 (NE)
        S1: { x:  0.07813, z: -0.359375, rotZ: Math.PI },      // Nord_E (orange) â†’ Zahlâ†’SÃ¼d(innen)
        S2: { x:  0.23438, z: -0.359375, rotZ: Math.PI },      // Nord_F (blau) â†’ Zahlâ†’SÃ¼d(innen)
        S3: { x:  0.46875, z: -0.125,    rotZ: Math.PI/2 },    // Ost_5 (violett) â†’ Zahlâ†’West(innen)
        S4: { x:  0.46875, z:  0.03125,  rotZ: Math.PI/2 }     // Ost_6 (gruen) â†’ Zahlâ†’West(innen)
      },
      2: { // Q2 (SE)
        S1: { x:  0.46875, z:  0.1875,   rotZ: Math.PI/2 },    // Ost_7 (gruen) â†’ Zahlâ†’West(innen)
        S2: { x:  0.46875, z:  0.34375,  rotZ: Math.PI/2 },    // Ost_8 (orange) â†’ Zahlâ†’West(innen)
        S3: { x:  0.23438, z:  0.580375, rotZ: 0 },             // SÃ¼d_F (blau) â†’ Zahlâ†’Nord(innen)
        S4: { x:  0.07813, z:  0.580375, rotZ: 0 }              // SÃ¼d_E (violett) â†’ Zahlâ†’Nord(innen)
      },
      3: { // Q3 (SW)
        S1: { x: -0.07813, z:  0.580375, rotZ: 0 },             // SÃ¼d_D (violett) â†’ Zahlâ†’Nord(innen)
        S2: { x: -0.23438, z:  0.580375, rotZ: 0 },             // SÃ¼d_C (gruen) â†’ Zahlâ†’Nord(innen)
        S3: { x: -0.46875, z:  0.34375,  rotZ: -Math.PI/2 },   // West_8 (orange) â†’ Zahlâ†’Ost(innen)
        S4: { x: -0.46875, z:  0.1875,   rotZ: -Math.PI/2 }    // West_7 (blau) â†’ Zahlâ†’Ost(innen)
      }
    };

    // Kippziel-Fluganimation: Card hebt ab, fliegt zum Treffer-Slot, legt sich deckungsgleich drauf
    // ZÃ¤hler-Flug: in die wÃ¼rfelfreie BoxhÃ¤lfte
    let counterOrigPos = null;
    let lastCounterTarget = { x: 180, y: 300 }; // Fallback
    
    function flyCountersToBox() {
      // Counter fliegen nicht mehr â€” nur Position fÃ¼r Kartenflug merken
      const cubeInNorth = (currentQuadrant === 0 || currentQuadrant === 1);
      const targetZ = cubeInNorth
        ? 0.1105 + 0.234375
        : 0.1105 - 0.234375;
      const target3D = new THREE.Vector3(0, 0.234375, targetZ);
      target3D.project(camera);
      const targetX = Math.round((target3D.x * 0.5 + 0.5) * 360);
      const targetY = Math.round((-target3D.y * 0.5 + 0.5) * 720) - 8;
      lastCounterTarget = { x: targetX, y: targetY };
    }
    
    function flyCountersBack() {
      // Counter fliegen nicht mehr â€” no-op
    }

    function animateCardFly(card, quadrant, slot) {
      return new Promise(resolve => {
        const target = HIT_TARGETS[quadrant][slot];
        const mesh = card.mesh;
        
        // ZÃ¤hler in die Box fliegen lassen
        flyCountersToBox();
        
        // Start-Werte
        const startX = mesh.position.x;
        const startY = mesh.position.y;
        const startZ = mesh.position.z;
        const startRotZ = mesh.rotation.z || 0;
        
        // Ziel-Werte
        const endX = target.x;
        const endY = 0.48;       // Rahmen-Oberkante
        const endZ = target.z;
        const endRotZ = target.rotZ;
        
        // FlughÃ¶he (Bogen Ã¼ber die Box)
        const peakY = 0.75;
        
        const duration = 800; // ms
        const startTime = performance.now();
        
        function tick(now) {
          const elapsed = now - startTime;
          const t = Math.min(elapsed / duration, 1);
          // Ease: schnell abheben, sanft landen
          const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
          
          // XZ: linear interpoliert
          mesh.position.x = startX + (endX - startX) * ease;
          mesh.position.z = startZ + (endZ - startZ) * ease;
          
          // Y: parabolischer Bogen (hoch in der Mitte)
          const arc = 4 * t * (1 - t); // 0â†’1â†’0 Parabel
          const baseY = startY + (endY - startY) * ease;
          mesh.position.y = baseY + (peakY - Math.max(startY, endY)) * arc;
          
          // Rotation: interpoliert
          mesh.rotation.z = startRotZ + (endRotZ - startRotZ) * ease;
          
          if (t < 1) {
            requestAnimationFrame(tick);
          } else {
            mesh.position.set(endX, endY, endZ);
            mesh.rotation.z = endRotZ;
            
            // Kurzer Puls am Ziel, dann vanish
            const landTime = performance.now();
            const pulseDur = 250;
            const holdDur = 400;
            const fadeDur = 300;
            function landPulse(now) {
              const elapsed = now - landTime;
              if (elapsed < pulseDur) {
                // Puls: 1â†’1.2â†’1
                const pt = elapsed / pulseDur;
                const s = 1 + Math.sin(pt * Math.PI) * 0.2;
                mesh.scale.set(s, s, s);
                requestAnimationFrame(landPulse);
              } else if (elapsed < pulseDur + holdDur) {
                // Kurz halten
                mesh.scale.set(1, 1, 1);
                requestAnimationFrame(landPulse);
              } else if (elapsed < pulseDur + holdDur + fadeDur) {
                // Ausblenden
                const ft = (elapsed - pulseDur - holdDur) / fadeDur;
                mesh.material.transparent = true;
                mesh.material.opacity = 1 - ft;
                mesh.material.needsUpdate = true;
                requestAnimationFrame(landPulse);
              } else {
                mesh.visible = false;
                mesh.material.opacity = 1;
                mesh.material.transparent = false;
                mesh.material.needsUpdate = true;
                // ZÃ¤hler 2s halten, dann zurÃ¼ckfliegen
                setTimeout(() => { flyCountersBack(); }, 2500);
                resolve();
              }
            }
            requestAnimationFrame(landPulse);
          }
        }
        requestAnimationFrame(tick);
      });
    }

    // "HIT"-Text an Karten-Position anzeigen (HTML-Overlay, von Osten lesbar)
    const hitTextEls = [];
    function showHitText(cardIdx) {
      const cx = cardStartX + cardIdx * (cardWidth + cardGap);
      // 3Dâ†’Screen Projektion der Kartenmitte
      const pos3D = new THREE.Vector3(cx, cardY, cardZ);
      pos3D.project(camera);
      const sx = Math.round((pos3D.x * 0.5 + 0.5) * 360);
      const sy = Math.round((-pos3D.y * 0.5 + 0.5) * 720);
      
      const el = document.createElement('div');
      el.textContent = 'HIT';
      el.className = 'hit-text-el';
      el.style.cssText = 'position:absolute;' +
        'left:' + sx + 'px; top:' + sy + 'px;' +
        'transform:translate(-50%,-50%) rotate(-90deg) scale(0.3);' +
        'font:bold 28px Arial; color:#cedb25;' +
        'text-shadow:0 1px 4px rgba(0,0,0,0.7);' +
        'pointer-events:none; opacity:0;' +
        'transition:transform 0.3s ease-out, opacity 0.3s ease-out;';
      document.getElementById('uiOverlay').appendChild(el);
      hitTextEls.push(el);
      
      // Einblenden
      requestAnimationFrame(() => {
        el.style.transform = 'translate(-50%,-50%) rotate(-90deg) scale(1)';
        el.style.opacity = '1';
      });
    }

    // Generische Animation eines Wertes Ã¼ber Zeit
    function animateVal(from, to, duration, onUpdate, onFinish) {
      const start = performance.now();
      function tick(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
        onUpdate(from + (to - from) * eased);
        if (t < 1) requestAnimationFrame(tick);
        else if (onFinish) onFinish();
      }
      requestAnimationFrame(tick);
    }

    let activeCardIdx = 0;
    const bereitsGetroffen = new Set(); // "zahl_farbe" Kombinationen die bereits Treffer waren
    const bereitsAusgegeben = new Set(); // "zahl_farbe" Kombinationen die bereits als Ziel ausgegeben wurden
    
    const GAME_COLORS = [
      { name: 'violett', hex: '#a41b85' },
      { name: 'blau',    hex: '#006bb3' },
      { name: 'gruen',   hex: '#00a652' },
      { name: 'orange',  hex: '#e67814' }
    ];
    // =================================================================
    // KIPP 21 - GAME LOGIC
    // =================================================================
    
    // 12-state CW cycle: each entry = [quadrant, face]
    const CW_CYCLE = [
      [3,'f2'],[0,'f0'],[1,'f1'],[2,'f2'],
      [3,'f0'],[0,'f1'],[1,'f2'],[2,'f0'],
      [3,'f1'],[0,'f2'],[1,'f0'],[2,'f1']
    ];
    
    function stateIndex(q, f) {
      for (let i = 0; i < 12; i++) {
        if (CW_CYCLE[i][0] === q && CW_CYCLE[i][1] === f) return i;
      }
      return -1;
    }
    
    function minKippsFromTo(fromQ, fromF, toQ, toF) {
      const fromIdx = stateIndex(fromQ, fromF);
      const toIdx = stateIndex(toQ, toF);
      if (fromIdx < 0 || toIdx < 0) return 99;
      const cwDist = (toIdx - fromIdx + 12) % 12;
      return Math.min(cwDist, 12 - cwDist);
    }
    
    // KIPP 21 state
    let kipp21Active = false;
    let kipp21HitLock = false; // WÃ¼rfel gesperrt nach Auto-Treffer
    let kipp21Generation = 0; // Incrementiert bei jedem startKipp21, alte Async-Chains prÃ¼fen dagegen
    let replayGeneration = 0; // Wird bei Replay-Start auf kipp21Generation gesetzt
    let kipp21KippCount = 0;
    let kipp21RoundKipps = 0;
    let kipp21RoundTimerStart = null;
    let kipp21TotalTime = 0;
    let kipp21Done = 0;
    let kipp21UsedDistances = [];
    let kipp21CardStates = [];
    let kipp21CardDistances = [];
    let kipp21TimerRunning = false;
    let kipp21TimerInterval = null;
    
    let kipp21WithTutorial = false;
    let kipp21TutorialTimeout = null;
    let kipp21TutorialLineIdx = 0;
    
    const KIPP21_TUTORIAL_LINES = [
      // Wird neu befÃ¼llt
    ];
    
    // === TUTORIAL REPLAY SYSTEM (Prozedural: Perfect & Random) ===
    const REPLAY_DECK = [5,11,8,3,6,7,10,12,4,2,1,9];
    
    let handEl = null;
    let _handX = 0, _handY = 0;
    let replayActive = false;
    let replayDbg = null;
    
    // Kipp-Richtungs-Maps pro Quadrant
    const CW_KIPP = {3:'north', 0:'east', 1:'south_from_q1', 2:'west_from_q2'};
    const CCW_KIPP = {3:'east_from_q3', 0:'south', 1:'west', 2:'north_from_q2'};
    
    // 3D-Schatten fÃ¼r Hand (folgt der 2D-Hand-Position)
    let handShadowMesh = null;
    function initHandShadow() {
      if (handShadowMesh) return;
      const shGeo = new THREE.PlaneGeometry(0.22, 0.33);
      const shMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.0, side: THREE.DoubleSide, depthWrite: false });
      handShadowMesh = new THREE.Mesh(shGeo, shMat);
      handShadowMesh.rotation.x = -Math.PI / 2;
      handShadowMesh.renderOrder = 50;
      scene.add(handShadowMesh);
    }
    function updateHandShadow(screenX, screenY, visible) {
      if (!handShadowMesh) return;
      if (!visible) { handShadowMesh.material.opacity = 0; return; }
      // Screen â†’ 3D auf BodenhÃ¶he (Y=0.002)
      const ndc = new THREE.Vector3((screenX / 360) * 2 - 1, -(screenY / 720) * 2 + 1, 0.5);
      ndc.unproject(camera);
      const dir = ndc.sub(camera.position).normalize();
      const t = (0.002 - camera.position.y) / dir.y;
      const hit = camera.position.clone().add(dir.multiplyScalar(t));
      handShadowMesh.position.set(hit.x, 0.002, hit.z);
      handShadowMesh.material.opacity = 0.35;
    }
    
    function initHandEl() {
      if (handEl) return;
      handEl = document.createElement('img');
      handEl.src = 'handsilber.webp';
      handEl.style.cssText = 'position:absolute;left:0;top:0;width:90px;height:auto;pointer-events:none;z-index:20;opacity:0;transition:opacity 0.25s ease;will-change:transform;';
      document.getElementById('uiOverlay').appendChild(handEl);
      initHandShadow();
    }
    
    function setHandPos(x, y) {
      if (!handEl) return;
      handEl.style.transform = 'translate(' + Math.round(x - 23) + 'px,' + Math.round(y) + 'px)';
      _handX = x; _handY = y;
      updateHandShadow(x, y, parseFloat(handEl.style.opacity) > 0);
    }
    
    function dbgLog(msg) {
      console.log('[REPLAY] ' + msg);
      if (replayDbg) replayDbg.textContent = '';
    }
    
    // --- Smooth easeInOut Bewegung ---
    function moveHandSmooth(toX, toY, durMs) {
      return new Promise(resolve => {
        const sx = _handX;
        const sy = _handY;
        const startT = performance.now();
        function tick() {
          if (!replayActive) { setHandPos(toX, toY); resolve(); return; }
          const t = Math.min((performance.now() - startT) / durMs, 1);
          const e = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
          setHandPos(sx + (toX - sx) * e, sy + (toY - sy) * e);
          if (t < 1) requestAnimationFrame(tick);
          else { setHandPos(toX, toY); resolve(); }
        }
        requestAnimationFrame(tick);
      });
    }
    
    // --- Hand von SÃ¼d-Rand zu Ziel, halten, zurÃ¼ck ---
    async function handTapFromSouth(tx, ty, holdMs) {
      if (!replayActive) return;
      holdMs = holdMs || 600;
      const SY = 740;
      
      setHandPos(tx, SY);
      handEl.style.opacity = '1';
      updateHandShadow(tx, SY, true);
      await moveHandSmooth(tx, ty, 600);
      await sleep(holdMs);
      await moveHandSmooth(tx, SY, 600);
      handEl.style.opacity = '0';
      updateHandShadow(0, 0, false);
      await sleep(100);
    }
    
    // --- WÃ¼rfel-Mitte auf Screen projizieren ---
    function cubeScreenXY() {
      const pos = cube.position.clone();
      pos.project(camera);
      return {
        x: Math.round((pos.x * 0.5 + 0.5) * 360),
        y: Math.round((-pos.y * 0.5 + 0.5) * 720)
      };
    }
    
    // --- Pixel-Offset fÃ¼r Kipprichtung (135px) ---
    function kippPixelDir(dir) {
      if (dir.includes('north')) return {dx: 0, dy: -135};
      if (dir.includes('south')) return {dx: 0, dy: 135};
      if (dir.includes('east'))  return {dx: 135, dy: 0};
      if (dir.includes('west'))  return {dx: -135, dy: 0};
      return {dx: 0, dy: 0};
    }
    
    // --- Hand-Kipp-Animation: Ã¼ber Mitte â†’ 135px mitbewegen ---
    async function handKippAnim(kippDir, kippDur) {
      if (!replayActive) return;
      const c = cubeScreenXY();
      const off = kippPixelDir(kippDir);
      
      setHandPos(c.x, c.y);
      handEl.style.opacity = '1';
      updateHandShadow(c.x, c.y, true);
      await sleep(350);
      
      // Timer GO
      if (kipp21Active && kipp21CardStates.includes('offen') && !kipp21TimerRunning) {
        kipp21StartRoundTimer();
      }
      
      // Sicherstellen dass performKipp nicht blockiert wird
      isAnimating = false;
      
      const moveP = moveHandSmooth(c.x + off.dx, c.y + off.dy, kippDur);
      await performKipp(kippDir, kippDur);
      advanceTopFace();
      await moveP;
      
      handEl.style.opacity = '0';
      updateHandShadow(0, 0, false);
      await sleep(60);
    }
    
    // --- Karten-Screen-Position ---
    function cardScreenX(ci) {
      // 3D-Projektion der tatsÃ¤chlichen Kartenposition
      if (gameCards && gameCards[ci] && gameCards[ci].mesh) {
        const pos = gameCards[ci].mesh.position.clone();
        pos.project(camera);
        return Math.round((pos.x * 0.5 + 0.5) * 360);
      }
      // Fallback: flache Berechnung
      const cw = 45, gap = (360 - 6 * cw) / 5;
      return cw / 2 + ci * (cw + gap);
    }
    
    function cardScreenY(ci) {
      if (gameCards && gameCards[ci] && gameCards[ci].mesh) {
        const pos = gameCards[ci].mesh.position.clone();
        pos.project(camera);
        return Math.round((-pos.y * 0.5 + 0.5) * 720);
      }
      return 612; // Fallback
    }
    
    // --- Kniff-Icon-Position (liest aus DOM) ---
    function getKniffIconPos(type) {
      // 2 logische Icons (je bottom+top), Mitte des Paars anzielen
      const iconCount = 2; // logisch
      const totalWidth = 360, iconW = 58;
      const gap = (totalWidth - iconCount * iconW) / (iconCount + 1);
      const edgeShift = 45;
      const idx = (type === 'wobble') ? 0 : 1;
      const centerX = gap + idx * (iconW + gap) + iconW / 2;
      const shifted = centerX + (idx === 0 ? -edgeShift : edgeShift);
      const pairCenter = Math.round(shifted - 4); // Mitte zwischen bottom(-8) und top(0)
      const rowTop = parseInt(document.getElementById('jokerIconsRow')?.style.top || '523');
      console.log('[KNIFF-POS] type='+type, 'pairCenter='+pairCenter, 'rowTop='+rowTop);
      return { x: pairCenter, y: rowTop + 29 };
    }
    
    // --- Kipp-ZÃ¤hler aktualisieren ---
    function formatKipps(n) {
      return '<span style="white-space:nowrap"><span style="font-size:28px;line-height:28px">' + n + '</span><span style="font-size:18px"> K</span></span>';
    }
    
    function formatTimer(totalMs) {
      const totalSecs = Math.floor(totalMs / 1000);
      const s = totalSecs < 10 ? '00' + totalSecs : totalSecs < 100 ? '0' + totalSecs : '' + totalSecs;
      return '<span style="white-space:nowrap"><span style="font-size:28px;line-height:28px">' + s + '</span><span style="font-size:18px"> S</span></span>';
    }
    
    function formatCountdownLabel(totalMs) {
      const totalSecs = Math.floor(totalMs / 1000);
      const remaining = 21 - totalSecs;
      if (remaining > 0) {
        const s = remaining < 10 ? '0' + remaining : '' + remaining;
        return '<span style="font-size:36px;line-height:36px">' + s + '</span>';
      } else if (remaining === 0) {
        return '<span style="font-size:36px;line-height:36px">00</span>';
      } else {
        const over = -remaining;
        const os = over < 10 ? '00' + over : over < 100 ? '0' + over : '' + over;
        return '<span style="font-size:36px;line-height:36px;color:#c85a5a">+' + os + '</span>';
      }
    }
    
    function replayUpdateKippCount() {
      kipp21KippCount++;
      kipp21RoundKipps++;
      const ht = document.getElementById('hintText');
      if (ht) ht.innerHTML = formatKipps(kipp21KippCount);
    }
    
    // --- Treffer-Richtung berechnen: CW oder CCW? ---
    function findHitDirection(cardIdx) {
      const card = gameCards[cardIdx];
      const dist = kipp21CardDistances[cardIdx];
      if (!card || !card.color || !dist) return 'cw';
      
      const fromIdx = stateIndex(currentQuadrant, topFace);
      const faceOff = {f0: 0, f1: 4, f2: 8};
      const slots = ['S1', 'S2', 'S3', 'S4'];
      
      // CW zuerst probieren, dann CCW
      for (const dir of ['cw', 'ccw']) {
        const delta = (dir === 'cw') ? dist : -dist;
        const toIdx = ((fromIdx + delta) % 12 + 12) % 12;
        const [tQ, tF] = CW_CYCLE[toIdx];
        const off = faceOff[tF];
        
        for (let s = 0; s < 4; s++) {
          if (deck[off + s] === card.zahl) {
            const nColor = SLOT_NEIGHBOR_COLORS[tQ][slots[s]];
            if (nColor === card.color.name) return dir;
          }
        }
      }
      return 'cw'; // Fallback
    }
    
    // --- Karte aufdecken (manuell per Tap) ---
    // --- Kippziel-Karte kurz pulsieren bei Klick ---
    function pulseCard(ci) {
      const mesh = gameCards[ci]?.mesh;
      if (!mesh) return;
      const origScale = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };
      mesh.scale.set(origScale.x * 1.2, origScale.y * 1.2, origScale.z * 1.2);
      setTimeout(() => {
        mesh.scale.set(origScale.x, origScale.y, origScale.z);
      }, 150);
    }
    
    async function replayOpenCard(ci) {
      if (!replayActive || replayGeneration !== kipp21Generation) return;
      const nextV = kipp21NextVerdeckt();
      if (nextV < 0) return;
      dbgLog('Karte ' + nextV + ' aufdecken');
      
      const hasIcon = CARD_BLICK_MAP[nextV] !== null;
      const tx = cardScreenX(nextV);
      const ty = cardScreenY(nextV) + 15;
      const SY = 740;
      
      if (!hasIcon) {
        // Kein Blick-Icon â†’ Hand hinfliegen, sofort beim Kontakt pulsen+Ã¶ffnen
        setHandPos(tx, SY);
        handEl.style.opacity = '1';
        updateHandShadow(tx, SY, true);
        await moveHandSmooth(tx, ty, 600);
        // Sofort bei Kontakt: Pulse + Open
        pulseCard(nextV);
        kipp21OnCardTap(nextV, true);
        await sleep(350);
        // Hand zurÃ¼ck
        await moveHandSmooth(tx, SY, 500);
        handEl.style.opacity = '0';
        updateHandShadow(0, 0, false);
        await sleep(100);
        return;
      }
      
      // MIT Blick-Icon: volle Hand-Tap-Animation, dann Kniff
      await handTapFromSouth(tx, ty, 600);
      pulseCard(nextV);
      
      // Blick-Animation starten
      const prevOpenCount = kipp21CardStates.filter(s => s === 'offen' || s === 'erledigt').length;
      kipp21BlickTargetCard = nextV;
      hideBlickIcon(nextV);
      const blickType = CARD_BLICK_MAP[nextV].includes('joker2') ? 'wobble' : 'eckblick';
      
      try {
        if (blickType === 'eckblick') {
          const eckP = runKipp21EckblickKniff();
          await sleep(7000);
          if (replayActive) kipp21KniffAbort = true;
          await eckP;
        } else {
          await runKipp21WobbleKniff();
        }
      } catch(e) { console.error('[REPLAY-OPEN] kniff error:', e); }
      
      // Fallback falls Karte nicht geÃ¶ffnet wurde
      const newOpenCount = kipp21CardStates.filter(s => s === 'offen' || s === 'erledigt').length;
      if (newOpenCount <= prevOpenCount) {
        const nv = kipp21NextVerdeckt();
        if (nv >= 0) { pulseCard(nv); kipp21OnCardTap(nv, true); }
      }
      await sleep(400);
    }
    
    // --- KNIFF ausfÃ¼hren: Hand sucht Kartenreihe, klickt Zielkarte ---
    async function replayKniff(type, targetCard) {
      if (!replayActive || replayGeneration !== kipp21Generation) return;
      
      const prevOpenCount = kipp21CardStates.filter(s => s === 'offen' || s === 'erledigt').length;
      const isFirstKniff = (kipp21WobbleUsed + kipp21EckblickUsed === 0);
      const cardY_screen = cardScreenY(targetCard >= 0 ? targetCard : 0) + 15; // leicht unter Kartenmitte
      
      if (targetCard < 0) targetCard = kipp21NextVerdeckt();
      if (targetCard < 0) return;
      
      if (isFirstKniff) {
        // Suchend: linksâ†’rechtsâ†’zurÃ¼ckâ†’auf Zielkarte klicken
        const leftX = cardScreenX(0);
        const rightX = cardScreenX(5);
        const targetX = cardScreenX(targetCard);
        
        setHandPos(leftX, 740);
        handEl.style.opacity = '1';
        updateHandShadow(leftX, 740, true);
        // Hoch zur Kartenreihe
        await moveHandSmooth(leftX, cardY_screen, 800);
        await sleep(200);
        // Nach rechts suchen
        await moveHandSmooth(rightX, cardY_screen, 1400);
        await sleep(250);
        // ZurÃ¼ck nach links
        await moveHandSmooth(leftX, cardY_screen, 1200);
        await sleep(250);
        // Zum Ziel
        await moveHandSmooth(targetX, cardY_screen, 700);
      } else {
        // Direkt zur Zielkarte
        const targetX = cardScreenX(targetCard);
        setHandPos(targetX, 740);
        handEl.style.opacity = '1';
        updateHandShadow(targetX, 740, true);
        await moveHandSmooth(targetX, cardY_screen, 900);
      }
      
      // Karte pulsieren ("klick")
      pulseCard(targetCard);
      await sleep(300);
      
      // Hand weg
      await moveHandSmooth(cardScreenX(targetCard), 740, 500);
      handEl.style.opacity = '0';
      updateHandShadow(0, 0, false);
      await sleep(100);
      
      // Blick-Animation auslÃ¶sen
      kipp21BlickTargetCard = targetCard;
      hideBlickIcon(targetCard);
      const blickSrc = CARD_BLICK_MAP[targetCard];
      const blickType = (blickSrc && blickSrc.includes('joker2')) ? 'wobble' : 'eckblick';
      
      try {
        if (blickType === 'eckblick') {
          console.log('[REPLAY-KNIFF] calling eckblick for card ' + targetCard);
          const eckP = runKipp21EckblickKniff();
          await sleep(7000);
          if (replayActive) kipp21KniffAbort = true;
          await eckP;
        } else {
          console.log('[REPLAY-KNIFF] calling wobble for card ' + targetCard);
          await runKipp21WobbleKniff();
        }
      } catch (err) {
        console.error('[REPLAY-KNIFF] ERROR:', err);
      }
      
      // Fallback prÃ¼fen
      const newOpenCount = kipp21CardStates.filter(s => s === 'offen' || s === 'erledigt').length;
      if (newOpenCount <= prevOpenCount) {
        console.warn('[REPLAY-KNIFF] Fallback: Karte manuell Ã¶ffnen');
        const nv = kipp21NextVerdeckt();
        if (nv >= 0) { pulseCard(nv); kipp21OnCardTap(nv, true); }
      }
      
      await sleep(400);
    }
    
    // --- Kippen fÃ¼r offene Karte ---
    async function replayKippSequence(ci, kippDur) {
      if (!replayActive) return;
      const dist = kipp21CardDistances[ci];
      if (!dist || dist <= 0) return;
      
      const dir = findHitDirection(ci);
      dbgLog('Karte ' + ci + ': ' + dist + 'x ' + dir + ' Q' + currentQuadrant + ' ' + topFace);
      
      for (let k = 0; k < dist; k++) {
        if (!replayActive) break;
        const Q = currentQuadrant;
        const kDir = (dir === 'cw') ? CW_KIPP[Q] : CCW_KIPP[Q];
        kippDirection = dir;
        
        await handKippAnim(kDir, kippDur);
        replayUpdateKippCount();
        
        if (k < dist - 1) await sleep(40);
      }
      // Nach letztem Kipp: Auto-Confirm wenn HIT (Kippziel fliegt selbststÃ¤ndig)
      checkOnTargetAfterKipp();
    }
    
    // --- BestÃ¤tigen: Timer SOFORT stoppen, dann Hand animieren, dann CardTap ---
    async function replayConfirm(ci) {
      if (!replayActive || replayGeneration !== kipp21Generation) return;
      const openIdx = kipp21CardStates.indexOf('offen');
      if (openIdx < 0 || kipp21RoundKipps <= 0) return;
      dbgLog('BestÃ¤tigen Karte ' + openIdx);
      
      // Timer sofort stoppen (ohne CardTap auszulÃ¶sen)
      kipp21StopRoundTimer();
      
      // Hand sichtbar auf Karte tippen
      await handTapFromSouth(cardScreenX(openIdx), cardScreenY(openIdx), 700);
      if (replayGeneration !== kipp21Generation) return; // Abgebrochen
      pulseCard(openIdx);
      
      // DANN erst Karte verarbeiten (Treffer-Check etc.)
      kipp21OnCardTap(openIdx, true);
      await sleep(300);
    }
    
    // ============================================================
    //  PERFECT GAME: alle 6 Treffer, optimale Richtungen
    //  Kniff-Plan: 0=Eckblick, 2=Wobble, 3=Eckblick, 5=Wobble
    // ============================================================
    async function startPerfectReplay() {
      const myGen = kipp21Generation; // Meine Generation merken
      replayGeneration = myGen;
      console.log('[REPLAY] === startPerfectReplay ENTER === gen='+myGen);
      console.log('[REPLAY] gamePhase='+gamePhase, 'kipp21Active='+kipp21Active, 'isAnim='+isAnimating, 'dragActive='+dragActive);
      try {
        initHandEl();
        console.log('[REPLAY] handEl created:', !!handEl);
      } catch(e) {
        console.error('[REPLAY] initHandEl FAILED:', e);
      }
      replayActive = true;
      enableReplayBlocker();
      renderer.domElement.style.pointerEvents = 'none'; // Canvas komplett blocken
      
      if (!replayDbg) {
        replayDbg = document.createElement('div');
        replayDbg.id = 'replayDbg';
        replayDbg.style.cssText = 'position:absolute;top:2px;left:2px;font:10px monospace;color:transparent;background:transparent;padding:2px 4px;z-index:30;pointer-events:none;white-space:pre;max-width:356px;';
        document.getElementById('uiOverlay').appendChild(replayDbg);
      }
      
      const jr = document.getElementById('jokerIconsRow');
      if (jr) jr.style.pointerEvents = 'none';
      const _eyeR1 = document.getElementById('eyeIcon');
      if (_eyeR1) _eyeR1.style.pointerEvents = 'none';
      const kniffPlan = {}; // Nicht mehr gebraucht, Blick-Typ kommt aus cardIdx % 2
      const KIPP_DUR = 550; // ~1 Sek pro Kipp (550+350+60+40)
      
      await sleep(500);
      if (myGen !== kipp21Generation) return; // Abgebrochen
      dbgLog('Perfect Game Start');
      console.log('[REPLAY] START phase='+gamePhase, 'kipp21Active='+kipp21Active, 'isAnim='+isAnimating, 'Q='+currentQuadrant, 'F='+topFace);
      
      // Sichtbarer Schritt-ZÃ¤hler oben im Bild
      if (replayDbg) replayDbg.style.cssText = 'position:absolute;top:2px;left:2px;font:bold 14px monospace;color:transparent;background:transparent;padding:4px 8px;z-index:30;pointer-events:none;white-space:pre;max-width:356px;';
      
      for (let ci = 0; ci < 6; ci++) {
        if (!replayActive || myGen !== kipp21Generation) break;
        dbgLog('Runde ' + ci + ' Q' + currentQuadrant + ' ' + topFace + ' anim=' + isAnimating);
        console.log('[REPLAY] === RUNDE', ci, '===');
        console.log('[REPLAY] states:', JSON.stringify(kipp21CardStates));
        console.log('[REPLAY] dists:', JSON.stringify(kipp21CardDistances));
        
        // === KARTE AUFDECKEN ===
        dbgLog('R' + ci + ': Aufdecken...');
        let useKniff = kniffPlan[ci] || null;
        // PrÃ¼fen ob geplanter KNIFF noch verfÃ¼gbar
        if (useKniff === 'eckblick' && kipp21EckblickUsed >= KNIFF_MAX_USES) useKniff = null;
        if (useKniff === 'wobble' && kipp21WobbleUsed >= KNIFF_MAX_USES) useKniff = null;
        
        // Tutorial-Text vor Aktion
        await sleep(600);
        
        if (ci === 0) {
          // Erste Runde: Hand sucht Kartenreihe, klickt 3. Kippziel (idx 2)
          console.log('[REPLAY] R0: Suche + Klick auf Karte 2');
          await replayKniff(null, 2);
        } else {
          // Folgerunden: direkt nÃ¤chste verdeckte Karte
          console.log('[REPLAY] R'+ci+': OpenCard');
          await replayOpenCard(ci);
        }
        console.log('[REPLAY] R'+ci+': Aufdecken fertig');
        if (!replayActive || myGen !== kipp21Generation) break;
        
        // PrÃ¼fen ob eine Karte offen ist
        const openCheck = kipp21CardStates.indexOf('offen');
        if (openCheck < 0) {
          console.warn('[REPLAY] Runde ' + ci + ': Keine offene Karte nach Aufdecken!');
          dbgLog('SKIP R' + ci + ': keine offene Karte');
          continue;
        }
        dbgLog('R' + ci + ': Karte ' + openCheck + ' offen, dist=' + kipp21CardDistances[openCheck]);
        
        // Denkpause nach Aufdecken
        await sleep(2200);
        
        // === KIPPEN ===
        console.log('[REPLAY] R'+ci+': Kippen start, isAnim='+isAnimating);
        dbgLog('R' + ci + ': Kippen...');
        const actualOpen = kipp21CardStates.indexOf('offen');
        await replayKippSequence(actualOpen >= 0 ? actualOpen : ci, KIPP_DUR);
        console.log('[REPLAY] R'+ci+': Kippen fertig');
        if (!replayActive || myGen !== kipp21Generation) break;
        
        // === BESTÃ„TIGEN ===
        await sleep(800);
        // Wenn checkOnTargetAfterKipp bereits auto-confirmed hat â†’ Ã¼berspringen
        if (kipp21CardStates[ci] === 'erledigt' || !kipp21CardStates.includes('offen')) {
          console.log('[REPLAY] R'+ci+': Auto-confirmed by checkOnTarget, skip hand confirm');
        } else {
          dbgLog('R' + ci + ': BestÃ¤tigen...');
          await replayConfirm(ci);
        }
        console.log('[REPLAY] R'+ci+': Confirm fertig, states:', JSON.stringify(kipp21CardStates));
        
        await sleep(800); // Kurz warten bis Kartenflug + HIT sichtbar
      }
      
      // === ERGEBNIS ===
      // Abbruch? Dann kein End-UI zeigen
      if (!replayActive || gamePhase === 'start' || myGen !== kipp21Generation) {
        replayCleanup(jr);
        return;
      }
      // KniffIcons und Karten ausblenden
      hideKniffIcons();
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      for (let i = 0; i < 6; i++) {
        if (gameCards[i].mesh.visible) gameCards[i].mesh.visible = false;
      }
      
      const totalKipps = kipp21KippCount;
      const totalMs = kipp21TotalTime || 0;
      const totalSec = Math.floor(totalMs / 1000);
      const zeitStr = totalSec + ' Sek.';
      // Score steht schon in der Box-HÃ¤lfte â€” kein Extra-Text nÃ¶tig
      document.getElementById('perfektGameText').style.display = 'none';
      document.getElementById('gameEndText').style.display = 'none';
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      // Subtitle auch weg
      const subEl = document.getElementById('subtitleText');
      if (subEl) subEl.style.display = 'none';
      
      // Tutorial-Score speichern
      saveTutorialScore(totalKipps, totalSec);
      
      // "kipps21Label" zeigt schon den finalen Countdown-Stand â€” nichts zu Ã¤ndern
      
      // End-Buttons zeigen (Tutorial)
      showEndButtons(true);
      
      // Hand zum Pokal fahren, klicken, Scoretafel Ã¶ffnen
      (async () => {
        await sleep(2000);
        
        // Hand einblenden in Bildmitte
        if (handEl) {
          setHandPos(180, 400);
          handEl.style.opacity = '1';
          updateHandShadow(180, 400, true);
          await sleep(300);
          
          // Pokal-Zentrum im 360px-Raster: right:9 + 57/2 = 37.5 von rechts = 322 von links, top:11 + 57/2 = 39
          await moveHandSmooth(322, 40, 800);
          
          // Klick-Pulse auf Pokal
          const pokalEl = document.getElementById('btnBestScores');
          pokalEl.style.transition = 'transform 0.15s ease-out';
          pokalEl.style.transform = 'scale(1.2)';
          await sleep(150);
          pokalEl.style.transform = 'scale(1.0)';
          await sleep(300);
          
          // Hand weg
          handEl.style.opacity = '0';
          updateHandShadow(0, 0, false);
          await sleep(200);
          await sleep(200);
          
          // Scoretafel zeigen
          showBestScores();
        }
        
        replayCleanup(jr);
      })();
    }
    
    // ============================================================
    //  RANDOM GAME: zufÃ¤llige Richtungen, keine KNIFFs,
    //  lÃ¤ngere Denkpausen, zÃ¶gerlicheres Kippen
    // ============================================================
    // --- AufrÃ¤umen ---
    function replayCleanup(jr) {
      replayActive = false;
      disableReplayBlocker();
      renderer.domElement.style.pointerEvents = 'auto';
      if (handEl) { handEl.style.opacity = '0'; updateHandShadow(0,0,false); }
      if (jr) jr.style.pointerEvents = 'auto';
      const _eye = document.getElementById('eyeIcon');
      if (_eye) _eye.style.pointerEvents = 'auto';
      dbgLog('Replay fertig!');
      setTimeout(() => { if (replayDbg) replayDbg.style.display = 'none'; }, 3000);
    }
    
    // Tutorial-Text updaten
    function setTutText(line1, line2) {
      const el = document.getElementById('perfektGameText');
      if (!el) return;
      if (line2) {
        el.innerHTML = '<div style="line-height:1.5">' + line1 + '</div><div style="margin-top:4px;line-height:1.5">' + line2 + '</div>';
      } else {
        el.innerHTML = '<div>' + line1 + '</div>';
      }
    }
    
    // --- Wrapper: Default = Perfect ---
    async function startReplay() {
      try {
        await startPerfectReplay();
      } catch(e) {
        if (e instanceof ReplayAbort) {
          console.log('[startReplay] Aborted (Reset)');
          replayCleanup(document.getElementById('jokerIconsRow'));
          return;
        }
        console.error('[startReplay] UNCAUGHT:', e);
        const errDiv = document.createElement('div');
        errDiv.style.cssText = 'position:absolute;top:100px;left:10px;right:10px;font:bold 11px monospace;color:#ff0;background:rgba(0,0,0,0.9);padding:8px;z-index:35;word-break:break-all;';
        errDiv.textContent = 'UNCAUGHT: ' + e.message + '\n' + (e.stack || '');
        document.getElementById('uiOverlay').appendChild(errDiv);
      }
    }
    
    // ============================================================
    //  REPLAY TOUCH-BLOCKER: Unsichtbares Overlay Ã¼ber ALLES
    //  Schluckt jeden Touch/Click wÃ¤hrend Tutorial lÃ¤uft
    // ============================================================
    let replayBlocker = null;
    function enableReplayBlocker() {
      if (!replayBlocker) {
        replayBlocker = document.createElement('div');
        replayBlocker.id = 'replayBlocker';
        replayBlocker.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;z-index:30;background:transparent;pointer-events:auto;touch-action:none;';
        // Jeden Event schlucken
        ['touchstart','touchmove','touchend','click','mousedown','mouseup','pointerdown','pointerup'].forEach(evt => {
          replayBlocker.addEventListener(evt, (e) => { e.stopPropagation(); e.preventDefault(); }, { capture: true, passive: false });
        });
        document.body.appendChild(replayBlocker);
      }
      replayBlocker.style.display = 'block';
    }
    function disableReplayBlocker() {
      if (replayBlocker) replayBlocker.style.display = 'none';
    }

    // === END-BUTTONS (WIEDERHOLEN + SPIELEN) ===
    function showEndButtons(isTutorial, isNewRecord) {
      // Guard: Reset wurde gedrÃ¼ckt, wir sind schon am Start-Screen
      if (gamePhase === 'start') return;
      // DEBUG
      let dbg = document.getElementById('endDebug');
      if (dbg) dbg.textContent += ' | sEB(tut='+isTutorial+',rec='+isNewRecord+')';
      // HIT-Texte entfernen
      hitTextEls.forEach(el => el.remove());
      hitTextEls.length = 0;
      // Auch verspÃ¤tete HIT-Texte abfangen
      document.querySelectorAll('.hit-text-el').forEach(el => el.remove());
      
      // Position berechnen (KÃ¤rtchen-Reihe)
      const cardCenter3D = new THREE.Vector3(0, cardY, cardZ);
      cardCenter3D.project(camera);
      const btnBaseY = Math.round((-cardCenter3D.y * 0.5 + 0.5) * 720);
      
      const btnCSS = (top, fs, ls) => 'position:absolute; display:block; left:50%; transform:translateX(-50%);' +
        ' top:' + top + 'px; width:280px; height:49px;' +
        ' background:url(button_lang.webp) center/contain no-repeat;' +
        ' border:none; cursor:pointer; pointer-events:auto; z-index:15;' +
        ' font-family:Arial,sans-serif; font-size:' + fs + 'px; font-weight:bold;' +
        ' letter-spacing:' + ls + 'px; padding-top:4px;' +
        ' color:#d0d0d0; text-shadow:0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);';
      
      let abtn = document.getElementById('auswertungBtn');
      if (!abtn) {
        abtn = document.createElement('button');
        abtn.id = 'auswertungBtn';
        abtn.className = 'end-btn-dynamic';
        document.getElementById('uiOverlay').appendChild(abtn);
      }
      
      if (isTutorial) {
        // Tutorial-Ende: WIEDERHOLEN + SPIELEN + HIGHSCORES (Intro-AbstÃ¤nde: 421, 480, 539)
        abtn.textContent = T.wh;
        abtn.style.cssText = btnCSS(421, 16, 2);
        abtn.onclick = () => {
          abtn.style.display = 'none';
          const esb = document.getElementById('endSpielenBtn');
          if (esb) esb.style.display = 'none';
          document.getElementById('perfektGameText').style.display = 'none'; document.getElementById('gameEndText').style.display = 'none';
          countdown.style.display = 'none';
          hintText.style.display = 'none';
          counterOrigPos = null;
          if (soundEnabled && bgMusic.paused) { bgMusic.play().catch(() => {}); }
          startKipp21(true);
        };
        
        let spielenBtn = document.getElementById('endSpielenBtn');
        if (!spielenBtn) {
          spielenBtn = document.createElement('button');
          spielenBtn.id = 'endSpielenBtn';
          spielenBtn.className = 'end-btn-dynamic';
          document.getElementById('uiOverlay').appendChild(spielenBtn);
        }
        spielenBtn.textContent = T.sp;
        spielenBtn.style.cssText = btnCSS(480, 18, 2.5);
        spielenBtn.onclick = () => {
          spielenBtn.style.display = 'none';
          abtn.style.display = 'none';
          document.getElementById('perfektGameText').style.display = 'none'; document.getElementById('gameEndText').style.display = 'none';
          countdown.style.display = 'none';
          hintText.style.display = 'none';
          // Counter zurÃ¼ck an Originalposition falls noch in Mitte
          counterOrigPos = null;
          if (soundEnabled && bgMusic.paused) { bgMusic.play().catch(() => {}); }
          startKipp21(false);
        };
        
      } else {
        // Spiel-Ende: gameEndText + BEST SCORES + KIPP PRINZIP + NEUES SPIEL
        try {
        console.log('[END] showEndButtons game-end, kipps='+kipp21KippCount);
        const esb = document.getElementById('endSpielenBtn');
        if (esb) esb.style.display = 'none';
        
        // Ergebnis speichern
        const totalSec = Math.floor((kipp21TotalTime || 0) / 1000);
        const zeitStr = totalSec + ' Sek.';
        const lang = _digikippLang || 'de';
        
        // Score in Best Scores speichern (nur echte Spiele, nicht Tutorial)
        saveBestScore(kipp21KippCount, totalSec);
        
        let motivEl = document.getElementById('endMotivText');
        if (motivEl) motivEl.style.display = 'none';
        
        // gameEndText nicht mehr benÃ¶tigt
        const geText = document.getElementById('gameEndText');
        geText.style.display = 'none';
        
        // kipps21Label zeigt schon den finalen Countdown-Stand
        
        // Funktion zum AufrÃ¤umen aller End-Buttons
        function hideAllEndBtns() {
          abtn.style.display = 'none';
          const ekpb = document.getElementById('endKippPrinzipBtn');
          if (ekpb) ekpb.style.display = 'none';
          if (motivEl) motivEl.style.display = 'none';
          document.getElementById('perfektGameText').style.display = 'none';
          document.getElementById('gameEndText').style.display = 'none';
          countdown.style.display = 'none';
          hintText.style.display = 'none';
          counterOrigPos = null;
        }
        
        // Button 1: KIPP PRINZIP (421px)
        let kpBtn = document.getElementById('endKippPrinzipBtn');
        if (!kpBtn) {
          kpBtn = document.createElement('button');
          kpBtn.id = 'endKippPrinzipBtn';
          kpBtn.className = 'end-btn-dynamic';
          document.getElementById('uiOverlay').appendChild(kpBtn);
        }
        kpBtn.textContent = (KIPP_PRINZIP[_digikippLang] || KIPP_PRINZIP['de']).btn;
        kpBtn.style.cssText = btnCSS(421, 16, 2);
        kpBtn.style.display = 'block';
        kpBtn.onclick = () => { showKippPrinzip(); };
        
        // Button 2: NEUES SPIEL (480px)
        abtn.textContent = T.nm;
        abtn.style.cssText = btnCSS(480, 18, 2.5);
        abtn.onclick = () => {
          hideAllEndBtns();
          if (soundEnabled && bgMusic.paused) { bgMusic.play().catch(() => {}); }
          startKipp21(false);
        };
        
        console.log('[END] Buttons created successfully');
        if (dbg) dbg.textContent += ' | OK 2btn';
        } catch(e) {
          console.error('[showEndButtons] CRASH:', e);
          let dbg2 = document.getElementById('endDebug');
          if (dbg2) dbg2.textContent += ' | CRASH:'+e.message;
          abtn.textContent = T.nm || 'NEUES SPIEL';
          abtn.style.cssText = 'position:absolute;display:block;left:50%;transform:translateX(-50%);top:500px;width:280px;height:49px;background:#333;border:2px solid #d4a843;border-radius:8px;cursor:pointer;pointer-events:auto;z-index:15;font:bold 18px Arial;color:#d4a843;text-align:center;line-height:45px;';
          abtn.onclick = () => { abtn.style.display='none'; startKipp21(false); };
        }
      }
    }
    
    function stopReplay() {
      replayActive = false;
      disableReplayBlocker();
      renderer.domElement.style.pointerEvents = 'auto';
      // Alle UI-Elemente wieder freigeben
      const _jr = document.getElementById('jokerIconsRow');
      if (_jr) _jr.style.pointerEvents = 'auto';
      const _eye = document.getElementById('eyeIcon');
      if (_eye) _eye.style.pointerEvents = 'auto';
      if (handEl) { handEl.style.opacity = '0'; updateHandShadow(0,0,false); }
    }


        function showKipp21TutorialLine() {
      const tutEl = document.getElementById('tutorialText');
      if (!tutEl) return;
      if (kipp21TutorialLineIdx >= KIPP21_TUTORIAL_LINES.length) {
        tutEl.style.display = 'none';
        return;
      }
      let line = KIPP21_TUTORIAL_LINES[kipp21TutorialLineIdx];
      
      // Replace KIPPZIEL_EXAMPLE with actual example from card 1
      if (line === 'KIPPZIEL_EXAMPLE' && gameCards[1] && gameCards[1].zahl) {
        const FD = { 'violett': T.fV, 'blau': T.fB, 'gruen': T.fG, 'orange': T.fO };
        line = gameCards[1].zahl + ' | ' + (FD[gameCards[1].color.name] || gameCards[1].color.name);
      }
      
      if (line === '') {
        tutEl.innerHTML = '&nbsp;';
      } else {
        tutEl.innerHTML = '<b>' + line + '</b>';
      }
      tutEl.style.display = 'block';
      kipp21TutorialLineIdx++;
      const delay = line === '' ? 800 : 2200;
      kipp21TutorialTimeout = setTimeout(showKipp21TutorialLine, delay);
    }
    
    function stopKipp21Tutorial() {
      if (kipp21TutorialTimeout) { clearTimeout(kipp21TutorialTimeout); kipp21TutorialTimeout = null; }
      const tutEl = document.getElementById('tutorialText');
      if (tutEl) tutEl.style.display = 'none';
    }
    
    function startKipp21(withTutorial) {
      // ===== HARTER CLEANUP: Alles aus vorherigem Tutorial/Spiel killen =====
      kipp21Generation++; // Alte Async-Chains werden ungÃ¼ltig
      // Replay/Async stoppen
      replayActive = false;
      kipp21Active = false;
      disableReplayBlocker();
      renderer.domElement.style.pointerEvents = 'auto';
      // Alle Timer/Timeouts/Intervals clearen
      if (kipp21TimerInterval) { clearInterval(kipp21TimerInterval); kipp21TimerInterval = null; }
      if (kipp21KniffTimeout) { clearTimeout(kipp21KniffTimeout); kipp21KniffTimeout = null; }
      if (kipp21TutorialTimeout) { clearTimeout(kipp21TutorialTimeout); kipp21TutorialTimeout = null; }
      stopCountdown();
      // Dynamische Elemente entfernen
      ['auswertungBtn', 'endSpielenBtn', 'endKippPrinzipBtn', 'endMotivText', 'endScoreBtn', 'kipps21Label', 'timeoutNeuesSpielBtn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.remove();
      });
      document.querySelectorAll('.end-btn-dynamic, .hit-text-el').forEach(el => el.remove());
      hitTextEls.length = 0;
      // Progress dots verstecken
      const _pd = document.getElementById('progressDots');
      if (_pd) _pd.style.display = 'none';
      // Hand ausblenden
      if (handEl) { handEl.style.opacity = '0'; updateHandShadow(0,0,false); }
      kipp21KniffActive = false;
      kipp21BlickTargetCard = -1;
      kipp21KniffAbort = false;
      kipp21PendingCardTap = -1;
      kippenWarningActive = false;
      // ===== CLEANUP ENDE =====
      
      kipp21WithTutorial = !!withTutorial;
      autoDemoActive = false; // Intro-Demo stoppen falls noch aktiv
      isAnimating = false;    // Sicherstellen
      dragActive = false;     // Touch-Drag stoppen
      counterOrigPos = null;  // Counter-Fly-State zurÃ¼cksetzen
      // Counter-Transitions komplett clearen
      countdown.style.transition = 'none';
      hintText.style.transition = 'none';
      void countdown.offsetWidth;
      void hintText.offsetWidth;
      // Hide old UI
      document.getElementById('startOverlay').style.display = 'none';
      // tutEndButtons entfernt - Buttons werden dynamisch erzeugt
      ['instructionText','tutorialText','spielZielText','entscheidungText'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
      ['eyeIcon','kippButtons','richtungButtons','kippTarget','demoSubtitle'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
      document.querySelectorAll('.eckeHaken').forEach(el => el.style.display = 'none');
      
      // === CHALLENGE TEXT zuerst zeigen (Inflate-Sequenz) ===
      const pgt = document.getElementById('perfektGameText');
      // FIX: setTutText zerstÃ¶rt pgtHead/pgtSub via innerHTML â€“ bei Bedarf neu erstellen
      let pgtH = document.getElementById('pgtHead');
      let pgtS = document.getElementById('pgtSub');
      if (!pgtH || !pgtS) {
        pgt.innerHTML = '';
        pgtH = document.createElement('div');
        pgtH.id = 'pgtHead';
        pgtH.className = 'pgtLine pgtHead';
        pgtS = document.createElement('div');
        pgtS.id = 'pgtSub';
        pgtS.className = 'pgtLine pgtSub';
        pgt.appendChild(pgtH);
        pgt.appendChild(pgtS);
      }
      pgtH.innerHTML = T.s1 + '  <span style="font-size:1.4em;font-weight:bold">21</span> ' + T.ch1.replace('21 ','');
      pgtS.style.display = 'none';
      // Einzeilig im Sub-Stil
      pgtH.style.fontSize = '21px';
      pgtH.style.letterSpacing = '0';
      pgtH.style.color = '';
      pgtH.style.animation = 'none'; pgtH.style.opacity = '0'; pgtH.style.transform = 'scale(0.6)';
      pgtS.style.animation = 'none'; pgtS.style.opacity = '0'; pgtS.style.transform = 'scale(0.6)';
      pgt.style.display = 'block';
      pgt.style.opacity = '1';
      pgt.style.transition = 'none'; // Kein CSS transition â€“ alles manuell
      
      // Hilfsfunktionen mit Promise â€“ nÃ¤chster Schritt startet erst wenn FERTIG
      function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
      
      function pgtInflate(el, other) {
        return new Promise(resolve => {
          other.style.animation = 'none'; other.style.opacity = '0'; other.style.transform = 'scale(0.6)';
          el.style.animation = 'none'; el.style.opacity = '0'; el.style.transform = 'scale(0.6)';
          void el.offsetWidth;
          el.style.animation = 'sctInflate 1.2s ease-out forwards';
          el.addEventListener('animationend', resolve, { once: true });
        });
      }
      
      function pgtDeflate(el) {
        return new Promise(resolve => {
          el.style.animation = 'none'; void el.offsetWidth;
          el.style.animation = 'sctDeflate 0.4s ease-in forwards';
          el.addEventListener('animationend', resolve, { once: true });
        });
      }
      
      function fadeOutText() {
        return new Promise(resolve => {
          const start = performance.now();
          const dur = 600;
          function tick(now) {
            const t = Math.min((now - start) / dur, 1);
            pgt.style.opacity = String(1 - t);
            if (t < 1) requestAnimationFrame(tick);
            else { pgt.style.display = 'none'; resolve(); }
          }
          requestAnimationFrame(tick);
        });
      }
      
      function fadeInUIs() {
        return new Promise(resolve => {
          // Alles auf opacity 0 vorbereiten
          for (let i = 0; i < 6; i++) {
            const m = gameCards[i].mesh;
            m.visible = true;
            m.material.transparent = true;
            m.material.opacity = 0;
            m.material.needsUpdate = true;
          }
          // Blick-Icons auf Kippzielen (statt jokerIconsRow)
          showBlickIcons();
          for (let i = 0; i < 6; i++) {
            if (blickIconMeshes[i].visible) {
              blickIconMeshes[i].material.transparent = true;
              blickIconMeshes[i].material.opacity = 0;
              blickIconMeshes[i].material.needsUpdate = true;
            }
          }
          // JokerIconsRow versteckt lassen
          const jr2 = document.getElementById('jokerIconsRow');
          jr2.style.display = 'none';
          const zsb2 = document.getElementById('zumSpielBtn');
          if (zsb2) { zsb2.style.transition = 'none'; zsb2.style.opacity = '0'; }
          countdown.style.display = 'none'; countdown.style.opacity = '0';
          hintText.style.display = 'none'; hintText.style.opacity = '0';
          const pd = document.getElementById('progressDots');
          if (!kipp21WithTutorial) {
            pd.style.display = 'flex'; pd.style.opacity = '0';
            updateProgressDots(kipp21Done, -1);
          } else {
            pd.style.display = 'none';
          }
          
          const start = performance.now();
          const dur = 1200;
          function tick(now) {
            const t = Math.min((now - start) / dur, 1);
            const e = t * t * (3 - 2 * t);
            for (let i = 0; i < 6; i++) {
              gameCards[i].mesh.material.opacity = e;
              gameCards[i].mesh.material.needsUpdate = true;
            }
            jr2.style.display = 'none';
            for (let i = 0; i < 6; i++) {
              if (blickIconMeshes[i].visible) {
                blickIconMeshes[i].material.opacity = e;
                blickIconMeshes[i].material.needsUpdate = true;
              }
            }
            if (zsb2) zsb2.style.opacity = String(e);
            countdown.style.opacity = String(e);
            hintText.style.opacity = String(e);
            if (pd.style.display !== 'none') pd.style.opacity = String(e);
            if (t < 1) {
              requestAnimationFrame(tick);
            } else {
              for (let i = 0; i < 6; i++) {
                gameCards[i].mesh.material.opacity = 1;
                gameCards[i].mesh.material.transparent = false;
                gameCards[i].mesh.material.needsUpdate = true;
                if (blickIconMeshes[i].visible) {
                  blickIconMeshes[i].material.opacity = 1;
                  blickIconMeshes[i].material.needsUpdate = true;
                }
              }
              if (zsb2) zsb2.style.transition = '';
              resolve();
            }
          }
          requestAnimationFrame(tick);
        });
      }
      
      // gamePhase SOFORT setzen, BEVOR async Sequenz startet (die prÃ¼ft darauf)
      gamePhase = 'kipp21';
      currentMode = 'kanten';
      
      // SEQUENZ: Jeder Schritt wartet auf den vorherigen
      // PrÃ¼ft gamePhase â€” Reset setzt 'start' und bricht die Sequenz ab
      (async () => {
        if (gamePhase !== 'kipp21') return;
        await pgtInflate(pgtH, pgtS);    // "SPIEL ZIEL 21 SEKUNDEN" erscheint
        if (gamePhase !== 'kipp21') return;
        await wait(1000);                 // stehen lassen
        if (gamePhase !== 'kipp21') return;
        await fadeOutText();              // Text KOMPLETT weg
        if (gamePhase !== 'kipp21') return;
        await wait(100);                  // Sicherheitspause
        if (gamePhase !== 'kipp21') return;
        await fadeInUIs();                // ERST JETZT UIs rein
        // JETZT erst Input freigeben
        kipp21Active = true;
      })();
      
      // Joker-Icons und Karten erst nach Delay
      const jr = document.getElementById('jokerIconsRow');
      jr.style.display = 'none';
      jr.style.opacity = '0';
      document.getElementById('zumSpielBtn').style.display = 'none';
      document.getElementById('zumSpielBtn').style.opacity = '0';
      for (let i = 0; i < 6; i++) gameCards[i].mesh.visible = false;
      
      verdecktesMesh.visible = false;
      
      // Show 6 verdeckte cards
      for (let i = 0; i < 6; i++) {
        const card = gameCards[i];
        card.ctx.clearRect(0, 0, 85, 170);
        if (leerImage) {
          card.ctx.drawImage(leerImage, 0, 0, 85, 170);
        }
        card.texture.needsUpdate = true;
        card.mesh.visible = true;
        card.mesh.material.transparent = false;
        card.mesh.material.opacity = 1;
        card.mesh.material.needsUpdate = true;
        card.mesh.scale.set(1, 1, 1);
        // Position + Rotation zurÃ¼cksetzen (nach Fluganimation)
        card.mesh.position.set(cardStartX + i * (cardWidth + cardGap), cardY, cardZ);
        card.mesh.rotation.set(-Math.PI / 2, 0, 0);
        card.zahl = null;
        card.color = null;
        card.isHit = false;
        card.isMiss = false;
      }
      
      // HIT-Texte aus vorherigem Spiel entfernen
      hitTextEls.forEach(el => el.remove());
      hitTextEls.length = 0;
      
      // Countdown-Timer unter den Kippzielen (ersetzt alten Kipp-Counter + Timer)
      const SEK_TERM = { de:'Sek.', en:'sec.', es:'seg.', fr:'sec.', it:'sec.', tr:'sn.' };
      const _sekTerm = SEK_TERM[_digikippLang] || SEK_TERM.de;
      let kLabel = document.getElementById('kipps21Label');
      if (!kLabel) {
        kLabel = document.createElement('div');
        kLabel.id = 'kipps21Label';
        document.getElementById('uiOverlay').appendChild(kLabel);
      }
      const cardSouth3D = new THREE.Vector3(0, cardY, cardZ + cardHeight / 2 + 0.02);
      cardSouth3D.project(camera);
      const labelY = Math.round((-cardSouth3D.y * 0.5 + 0.5) * 720) + 22;
      kLabel.innerHTML = '<span style="font-size:36px;line-height:36px">21</span>';
      kLabel.style.cssText = 'position:absolute; left:50%; transform:translateX(-50%); top:' + labelY + 'px; font-family:Arial,sans-serif; font-weight:bold; color:#d4b48c; text-shadow:0 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(212,180,140,0.5); pointer-events:none; z-index:13; white-space:nowrap;';
      kLabel.style.display = 'block';
      kLabel.dataset.sekterm = _sekTerm;
      kLabel.dataset.labely = labelY;
      
      // Blick-Icons auf Kippzielen anzeigen
      showBlickIcons();
      
      kipp21Active = false; // Wird erst nach fadeInUIs() aktiviert
      kipp21KippCount = 0;
      
      // WÃ¼rfel zurÃ¼ck in Startposition (Q3, f2)
      kipGroup.add(cube); // WICHTIG: Falls Cube noch in pivotGroup steckt
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      currentQuadrant = 3;
      topFace = 'f2';
      kippDirection = 'cw';
      isAnimating = false;
      kipp21RoundKipps = 0;
      kipp21HitLock = false;
      kipp21TotalTime = 0;
      kipp21Done = 0;
      kipp21UsedDistances = [];
      kipp21CardStates = ['verdeckt','verdeckt','verdeckt','verdeckt','verdeckt','verdeckt'];
      kipp21CardDistances = [0,0,0,0,0,0];
      kipp21TimerRunning = false;
      kipp21WobbleUsed = 0;
      kipp21EckblickUsed = 0;
      bereitsAusgegeben.clear();
      bereitsGetroffen.clear();
      kipp21KniffActive = false;
      kipp21BlickTargetCard = -1;
      kipp21KniffAbort = false;
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      activeCardIdx = 0;
      kipp21TutorialLineIdx = 0;
      
      // Timer und KippAnzahl in 3D-Rasterzeile 10 projizieren (Rahmenoberkante)
      const row10Z = 0.658; // Zeile 10 Z-Position (SÃ¼d-Rahmen Farbfelder)
      const row10Pt = new THREE.Vector3(0, 0.48, row10Z); // Y=0.48 = Rahmenoberkante
      row10Pt.project(camera);
      const row10Y = Math.round((-row10Pt.y * 0.5 + 0.5) * 720);
      
      // Spalte A|B Mitte projizieren (X = -0.46875)
      const abPt = new THREE.Vector3(-0.46875, 0.48, row10Z);
      abPt.project(camera);
      const abX = Math.round((abPt.x * 0.5 + 0.5) * 360);
      
      // Spalte G|H Mitte projizieren (X = +0.46875)
      const ghPt = new THREE.Vector3(0.46875, 0.48, row10Z);
      ghPt.project(camera);
      const ghX = Math.round((ghPt.x * 0.5 + 0.5) * 360);
      
      // Timer mittig G|H
      countdown.innerHTML = formatTimer(0);
      countdown.style.cssText = 'position:absolute; top:' + row10Y + 'px; left:' + ghX + 'px; transform:translate(-50%,-50%); width:auto; text-align:center; font-size:28px; font-weight:bold; background:linear-gradient(180deg,#ffffff 0%,#f0f0f0 50%,#e0e0e0 100%); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; text-shadow:0 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255,255,255,0.5); filter:drop-shadow(0 1px 2px rgba(0,0,0,0.5)); pointer-events:none; display:none; line-height:28px; white-space:nowrap;';
      
      // KippAnzahl mittig A|B
      hintText.style.cssText = 'position:absolute; top:' + row10Y + 'px; left:' + abX + 'px; transform:translate(-50%,-50%); width:auto; text-align:center; font-size:28px; font-weight:bold; background:linear-gradient(180deg,#ffffff 0%,#f0f0f0 50%,#e0e0e0 100%); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; text-shadow:0 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255,255,255,0.5); filter:drop-shadow(0 1px 2px rgba(0,0,0,0.5)); pointer-events:none; display:none; opacity:1; overflow:visible; line-height:28px;';
      hintText.innerHTML = formatKipps(0);
      
      // Karten nach Setup wieder verstecken (werden nach Challenge-Text gezeigt)
      for (let i = 0; i < 6; i++) gameCards[i].mesh.visible = false;
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      
      // Tutorial = Geskriptetes Demo starten
      if (kipp21WithTutorial) {
        deck = REPLAY_DECK.slice();
        updateAllFaceTextures();
        const replayStartGen = kipp21Generation;
        setTimeout(() => { 
          if (kipp21Generation !== replayStartGen) return; // Reset/Neustart
          startReplay().catch(err => {
            if (err instanceof ReplayAbort) return;
            console.error('[REPLAY] ERROR:', err);
          });
        }, 4500);
      } else {
        // Normales Spiel: Deck neu mischen, Faces neu bauen, Recording starten
        deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);
        updateAllFaceTextures();
      }
      
      positionResetButton();
    }
    
    // === KIPP KNIFF SYSTEM (beide Joker) ===
    let kipp21KniffActive = false;
    let kipp21BlickTargetCard = -1; // Welche Karte nach Blick-Animation Ã¶ffnen
    let kipp21KniffAbort = false;
    let kipp21KniffsUsed = 0;
    let kipp21PendingCardTap = -1;
    let kipp21KniffTimeout = null;
    let kipp21WobbleUsed = 0;
    let kipp21EckblickUsed = 0;
    const KNIFF_MAX_USES = 2; // 2 Eckblick (Karten 0,5), 2 Kippblick (Karten 2,3)
    const KNIFF_SHOW_DURATION = 11500; // 11,5 Sekunden Showzeit
    
    function refreshKniffIcons() {
      const allImgs = document.querySelectorAll('#jokerIconsRow img');
      allImgs.forEach(img => {
        const idx = parseInt(img.dataset.kniffIdx);
        const isTop = img.dataset.layer === 'top';
        const used = idx === 0 ? kipp21WobbleUsed : kipp21EckblickUsed;
        
        if (isTop) {
          // Top verschwindet nach 1. Nutzung
          if (used >= 1) {
            img.style.display = 'none';
          } else {
            img.style.display = ''; img.style.opacity = '1'; img.style.pointerEvents = 'auto';
          }
        } else {
          // Bottom verschwindet nach 2. Nutzung
          if (used >= KNIFF_MAX_USES) {
            img.style.display = 'none';
          } else {
            img.style.display = ''; img.style.opacity = '1'; img.style.pointerEvents = 'auto';
          }
        }
      });
      // Ganze Reihe verstecken wenn beide verbraucht
      if (kipp21WobbleUsed >= KNIFF_MAX_USES && kipp21EckblickUsed >= KNIFF_MAX_USES) {
        document.getElementById('jokerIconsRow').style.display = 'none';
        document.getElementById('zumSpielBtn').style.display = 'none';
      }
    }
    
    function kipp21NextVerdeckt() {
      for (let i = 0; i < 6; i++) {
        if (kipp21CardStates[i] === 'verdeckt') return i;
      }
      return -1;
    }
    
    function kipp21EndKniffAndOpenCard() {
      if (kipp21KniffTimeout) { clearTimeout(kipp21KniffTimeout); kipp21KniffTimeout = null; }
      const target = (kipp21BlickTargetCard >= 0) ? kipp21BlickTargetCard : kipp21NextVerdeckt();
      kipp21BlickTargetCard = -1;
      if (target >= 0) {
        kipp21OnCardTap(target, true); // _fromReplay=true â†’ Ã¶ffnet direkt
      }
    }
    
    // --- "Kippen!" Warnung wenn Joker bei offenem Kippziel gedrÃ¼ckt ---
    let kippenWarningActive = false;
    function showKippenWarning() {
      const jLabel = jokerRow.querySelector('.jokerLabel');
      if (!jLabel) return;
      jLabel.textContent = T.kp || 'Kippen!';
      jLabel.style.display = 'block';
      jLabel.style.animation = 'none';
      void jLabel.offsetWidth;
      jLabel.style.animation = 'kippenPulse 0.6s ease-in-out 3';
      kippenWarningActive = true;
      jLabel.addEventListener('animationend', () => {
        if (kippenWarningActive) {
          jLabel.style.opacity = '0';
          setTimeout(() => { jLabel.style.display = 'none'; kippenWarningActive = false; }, 300);
        }
      }, { once: true });
    }
    function dismissKippenWarning() {
      if (!kippenWarningActive) return;
      kippenWarningActive = false;
      const jLabel = jokerRow.querySelector('.jokerLabel');
      if (jLabel) { jLabel.style.animation = 'none'; jLabel.style.display = 'none'; }
    }
    
    // --- KNIFF 1: Wobble-Kipp-Schau (joker2, links) ---
    async function runKipp21WobbleKniff() {
      console.log('[WOBBLE] Guards: kniffActive='+kipp21KniffActive, 'phase='+gamePhase, 'used='+kipp21WobbleUsed+'/'+KNIFF_MAX_USES, 'nextV='+kipp21NextVerdeckt());
      if (kipp21KniffActive || gamePhase !== 'kipp21') { console.warn('[WOBBLE] BLOCKED: active/phase'); return false; }
      if (kipp21WobbleUsed >= KNIFF_MAX_USES) { console.warn('[WOBBLE] BLOCKED: max uses'); return false; }
      if (kipp21NextVerdeckt() < 0) { console.warn('[WOBBLE] BLOCKED: no verdeckt'); return false; }
      // Kippziel offen? Erst kippen!
      if (kipp21CardStates.includes('offen')) { showKippenWarning(); return false; }
      kipp21KniffActive = true;
      kipp21KniffAbort = false;
      kipp21PendingCardTap = -1;
      
      // "WÃ¼rfel-Einblick wÃ¤hlen" sofort ausblenden
      const jLabelWob = document.querySelector('#jokerIconsRow .jokerLabel');
      if (jLabelWob) jLabelWob.style.display = 'none';
      
      // Icon-Layer mit Pulse ausblenden
      const kniffImgs = document.querySelectorAll('#jokerIconsRow img');
      kniffImgs.forEach(img => {
        img.style.pointerEvents = 'none';
        if (img.dataset.kniffIdx === '0') {
          // 1. Nutzung: top verschwindet, 2. Nutzung: bottom verschwindet
          const targetLayer = (kipp21WobbleUsed === 0) ? 'top' : 'bottom';
          if (img.dataset.layer === targetLayer) {
            img.style.transition = 'transform 0.18s ease-out';
            img.style.transform = 'translateX(-50%) scale(1.3)';
            setTimeout(() => {
              img.style.transform = 'translateX(-50%) scale(0.5)';
              img.style.opacity = '0';
              setTimeout(() => { img.style.transition = ''; }, 200);
            }, 180);
          }
        }
      });
      
      // Auge-Icon Ã¼ber Boxmitte
      const wobEyePos = new THREE.Vector3(0, 7 * 0.15625, 0.109375);
      wobEyePos.project(camera);
      const wobEyeX = (wobEyePos.x * 0.5 + 0.5) * 360;
      const wobEyeY = (-wobEyePos.y * 0.5 + 0.5) * 720;
      const wobEye = document.getElementById('eyeIcon');
      wobEye.style.cssText = 'position:absolute; left:' + wobEyeX + 'px; top:' + wobEyeY + 'px; transform:translate(-50%,-50%); width:125px; pointer-events:none; display:block; opacity:0; transition:opacity 0.4s ease;';
      setTimeout(() => { wobEye.style.opacity = '1'; }, 50);

      
      function nextCwDir() {
        if (currentQuadrant === 3) return 'north';
        if (currentQuadrant === 0) return 'east';
        if (currentQuadrant === 1) return 'south_from_q1';
        return 'west_from_q2';
      }
      
      const savedDir = kippDirection;
      kippDirection = 'cw';
      
      for (let hw = 0; hw < 3; hw++) {
        if (gamePhase !== 'kipp21' || kipp21KniffAbort) break;
        const wobbles = 3 - hw;
        const pause = (hw < 2) ? 300 : 100;
        await halfKippWithWobble(nextCwDir(), wobbles, pause);
        if (hw < 2 && !kipp21KniffAbort) await sleep(200);
      }
      
      if (!kipp21KniffAbort) {
        const extra = Math.floor(Math.random() * 3);
        if (extra === 1 && gamePhase === 'kipp21') {
          kippDirection = 'cw';
          await sleep(300);
          if (!kipp21KniffAbort) await halfKippWithWobble(nextCwDir(), 2, 100);
        }
      }
      
      kippDirection = savedDir;

      wobEye.style.opacity = '0';
      kipp21KniffActive = false;
      kipp21KniffsUsed++;
      kipp21WobbleUsed++;
      setTimeout(() => { wobEye.style.display = 'none'; }, 400);
      
      // Joker-Status aktualisieren
      refreshKniffIcons();
      
      // Ausstehenden Card-Tap oder Auto-Open
      if (kipp21PendingCardTap >= 0) {
        const pending = kipp21PendingCardTap;
        kipp21PendingCardTap = -1;
        kipp21KniffAbort = false;
        kipp21OnCardTap(pending, true);
      } else {
        kipp21KniffAbort = false;
        kipp21EndKniffAndOpenCard();
      }
    }
    
    // --- KNIFF 2: Eckblick (joker3, rechts) ---
    let eckblickPivot = null;
    
    async function runKipp21EckblickKniff() {
      console.log('[ECKBLICK] Guards: kniffActive='+kipp21KniffActive, 'phase='+gamePhase, 'used='+kipp21EckblickUsed+'/'+KNIFF_MAX_USES, 'nextV='+kipp21NextVerdeckt());
      if (kipp21KniffActive || gamePhase !== 'kipp21') { console.warn('[ECKBLICK] BLOCKED: active/phase'); return false; }
      if (kipp21EckblickUsed >= KNIFF_MAX_USES) { console.warn('[ECKBLICK] BLOCKED: max uses'); return false; }
      if (kipp21NextVerdeckt() < 0) { console.warn('[ECKBLICK] BLOCKED: no verdeckt'); return false; }
      // Kippziel offen? Erst kippen!
      if (kipp21CardStates.includes('offen')) { showKippenWarning(); return false; }
      kipp21KniffActive = true;
      kipp21KniffAbort = false;
      kipp21PendingCardTap = -1;
      
      // "WÃ¼rfel-Einblick wÃ¤hlen" sofort ausblenden
      const jLabelEck = document.querySelector('#jokerIconsRow .jokerLabel');
      if (jLabelEck) jLabelEck.style.display = 'none';
      
      // Icon-Layer mit Pulse ausblenden
      const kniffImgs = document.querySelectorAll('#jokerIconsRow img');
      kniffImgs.forEach(img => {
        img.style.pointerEvents = 'none';
        if (img.dataset.kniffIdx === '1') {
          const targetLayer = (kipp21EckblickUsed === 0) ? 'top' : 'bottom';
          if (img.dataset.layer === targetLayer) {
            img.style.transition = 'transform 0.18s ease-out';
            img.style.transform = 'translateX(-50%) scale(1.3)';
            setTimeout(() => {
              img.style.transform = 'translateX(-50%) scale(0.5)';
              img.style.opacity = '0';
              setTimeout(() => { img.style.transition = ''; }, 200);
            }, 180);
          }
        }
      });
      
      // Position merken fÃ¼r RÃ¼ckkehr
      const savedPos = cube.position.clone();
      const savedQuat = cube.quaternion.clone();
      const savedQ = currentQuadrant;
      const savedF = topFace;
      
      // --- Auf Ecke stellen ---
      const cornerPos = new THREE.Vector3(0, 0, 0.109375);
      const aufEckeDur = 1200;
      
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(cornerPos);
      kipGroup.add(pivotGroup);
      
      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      const cubeWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(cubeWorldQuat);
      
      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(cornerPos));
      cube.quaternion.copy(cubeWorldQuat);
      pivotGroup.add(cube);
      
      // Exakter analytischer Vektor Eckeâ†’WÃ¼rfelmitte (KÃ¶rperdiagonale)
      // Jeder Quadrant hat eine der 4 Raumdiagonalen
      const o = 0.234375; // offset = halbe KantenlÃ¤nge
      const diagVectors = {
        0: new THREE.Vector3(-o,  o, -o), // Q0 NW
        1: new THREE.Vector3( o,  o, -o), // Q1 NE
        2: new THREE.Vector3( o,  o,  o), // Q2 SE
        3: new THREE.Vector3(-o,  o,  o)  // Q3 SW
      };
      const diag = diagVectors[currentQuadrant].clone().normalize();
      const targetDir = new THREE.Vector3(0, 1, 0);
      const aufEckeQuat = new THREE.Quaternion().setFromUnitVectors(diag, targetDir);
      
      // Animation: auf Ecke kippen
      await new Promise(resolve => {
        const startTime = performance.now();
        function animate() {
          const t = Math.min((performance.now() - startTime) / aufEckeDur, 1);
          const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
          pivotGroup.quaternion.copy(new THREE.Quaternion().slerp(aufEckeQuat, ease));
          if (t < 1) requestAnimationFrame(animate);
          else { pivotGroup.quaternion.copy(aufEckeQuat); resolve(); }
        }
        animate();
      });
      
      eckblickPivot = pivotGroup;
      
      // Auge-Icon Ã¼ber Boxmitte (3.5 Zellen Ã¼ber Ï€1)
      const eckEyePos = new THREE.Vector3(0, 7 * 0.15625, 0.109375);
      eckEyePos.project(camera);
      const eckEyeScreenX = (eckEyePos.x * 0.5 + 0.5) * 360;
      const eckEyeScreenY = (-eckEyePos.y * 0.5 + 0.5) * 720;
      const eckEye = document.getElementById('eyeIcon');
      eckEye.style.cssText = 'position:absolute; left:' + eckEyeScreenX + 'px; top:' + eckEyeScreenY + 'px; transform:translate(-50%,-50%); width:125px; pointer-events:none; display:block; opacity:0; transition:opacity 0.4s ease;';
      setTimeout(() => { eckEye.style.opacity = '1'; }, 50);

      
      // Timeout starten: nach KNIFF_SHOW_DURATION automatisch zurÃ¼ckfallen
      if (!kipp21KniffAbort) {
        await new Promise(resolve => {
          kipp21KniffTimeout = setTimeout(resolve, KNIFF_SHOW_DURATION);
          // Abort-Check alle 100ms
          const checkAbort = setInterval(() => {
            if (kipp21KniffAbort) {
              clearInterval(checkAbort);
              clearTimeout(kipp21KniffTimeout);
              kipp21KniffTimeout = null;
              resolve();
            }
          }, 100);
        });
      }
      
      // Auge-Icon ausblenden

      eckEye.style.opacity = '0';
      
      // --- Von Ecke zurÃ¼ckfallen lassen ---
      const inverseQuat = aufEckeQuat.clone().invert();
      const fallDur = 800;
      
      await new Promise(resolve => {
        const startTime = performance.now();
        function animate() {
          const t = Math.min((performance.now() - startTime) / fallDur, 1);
          const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
          pivotGroup.quaternion.copy(aufEckeQuat.clone().slerp(new THREE.Quaternion(), ease));
          if (t < 1) requestAnimationFrame(animate);
          else { pivotGroup.quaternion.set(0,0,0,1); resolve(); }
        }
        animate();
      });
      
      // Cleanup: Cube zurÃ¼ck in kipGroup
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);
      
      pivotGroup.remove(cube);
      kipGroup.remove(pivotGroup);
      cube.position.copy(savedPos);
      cube.quaternion.copy(savedQuat);
      kipGroup.add(cube);
      
      currentQuadrant = savedQ;
      topFace = savedF;
      eckblickPivot = null;
      
      kipp21KniffActive = false;
      kipp21KniffsUsed++;
      kipp21EckblickUsed++;
      eckEye.style.display = 'none';
      
      // Joker-Status aktualisieren
      refreshKniffIcons();
      
      // Ausstehenden Card-Tap oder Auto-Open
      if (kipp21PendingCardTap >= 0) {
        const pending = kipp21PendingCardTap;
        kipp21PendingCardTap = -1;
        kipp21KniffAbort = false;
        kipp21OnCardTap(pending, true);
      } else {
        kipp21KniffAbort = false;
        kipp21EndKniffAndOpenCard();
      }
    }
    
    // Click-Handler fÃ¼r linken Joker wird unten nach Icon-Erstellung angehÃ¤ngt
    
    let kipp21ReplayMode = false;
    let kipp21ReplayTargetIdx = 0;
    
    function kipp21GenerateTarget(cardIdx) {
      console.log('[GENTARGET] cardIdx='+cardIdx, 'usedDists:', kipp21UsedDistances);
      
      const available = [];
      for (let d = 1; d <= 6; d++) {
        if (!kipp21UsedDistances.includes(d)) available.push(d);
      }
      if (available.length === 0) return false;
      
      // Shuffle available distances for randomness
      for (let i = available.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [available[i], available[j]] = [available[j], available[i]];
      }
      
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      const slots = ['S1', 'S2', 'S3', 'S4'];
      const currentFulfilled = getCurrentErfuellteKombis();
      
      // Try each available distance
      for (const dist of available) {
        const fromIdx = stateIndex(currentQuadrant, topFace);
        const cwIdx = (fromIdx + dist) % 12;
        const ccwIdx = (fromIdx - dist + 12) % 12;
        const targetStates = [CW_CYCLE[cwIdx]];
        if (cwIdx !== ccwIdx) targetStates.push(CW_CYCLE[ccwIdx]);
        
        const validCombos = [];
        for (const [tQ, tF] of targetStates) {
          const off = faceOff[tF];
          slots.forEach((slot, i) => {
            const zahl = deck[off + i];
            const farbe = SLOT_NEIGHBOR_COLORS[tQ][slot];
            const key = zahl + '_' + farbe;
            if (!bereitsAusgegeben.has(key) && !currentFulfilled.has(key)) {
              const colorObj = GAME_COLORS.find(c => c.name === farbe);
              if (colorObj) validCombos.push({ zahl, color: colorObj, key });
            }
          });
        }
        
        if (validCombos.length > 0) {
          const pick = validCombos[Math.floor(Math.random() * validCombos.length)];
          console.log('[GENTARGET] FOUND: zahl='+pick.zahl, 'color='+pick.color.name, 'dist='+dist, 'key='+pick.key);
          fillCardWithKombi(cardIdx, pick.zahl, pick.color);
          bereitsAusgegeben.add(pick.key);
          kipp21UsedDistances.push(dist);
          kipp21CardDistances[cardIdx] = dist;
          kipp21CardStates[cardIdx] = 'offen';
          activeCardIdx = cardIdx;
          updateProgressDots(kipp21Done, cardIdx);
          kipp21RoundKipps = 0;
          kipp21HitLock = false;
          kipp21RoundTimerStart = null;
          kipp21TimerRunning = false;
          return true;
        }
      }
      
      console.warn('KIPP21: No valid target found!');
      return false;
    }
    
    function kipp21StartRoundTimer() {
      if (kipp21TimerRunning) return;
      kipp21RoundTimerStart = performance.now();
      kipp21TimerRunning = true;
      
      if (kipp21TimerInterval) clearInterval(kipp21TimerInterval);
      kipp21TimerInterval = setInterval(() => {
        if (!kipp21TimerRunning) return;
        const elapsed = kipp21TotalTime + (performance.now() - kipp21RoundTimerStart);
        const kl = document.getElementById('kipps21Label');
        if (kl) kl.innerHTML = formatCountdownLabel(elapsed);
      }, 100);
    }
    
    function kipp21StopRoundTimer() {
      if (!kipp21TimerRunning) return;
      kipp21TotalTime += (performance.now() - kipp21RoundTimerStart);
      kipp21TimerRunning = false;
    }
    
    function show60SecTimeout() {
      // ALLES STOPPEN â€” Standbild
      hideKniffIcons();
      stopReplay();
      kipp21KniffActive = false;
      kipp21KniffAbort = true;
      isAnimating = false;
      dragActive = false;
      if (handEl) { handEl.style.opacity = '0'; handEl.style.transition = 'none'; }
      
      // Achsmittelpunkt â†’ Screen projizieren
      const axisCenter = new THREE.Vector3(0, 0.234375, 0.109375);
      axisCenter.project(camera);
      const acX = Math.round((axisCenter.x * 0.5 + 0.5) * 360);
      const acY = Math.round((-axisCenter.y * 0.5 + 0.5) * 720);
      
      // "60 S" fliegt zum Achsmittelpunkt wie ein HIT
      const flyEl = document.createElement('div');
      flyEl.textContent = '60 S';
      flyEl.style.cssText = 'position:absolute;' +
        'left:' + acX + 'px; top:' + acY + 'px;' +
        'transform:translate(-50%,-50%) scale(0.3);' +
        'font:bold 42px Arial; color:#cedb25;' +
        'text-shadow:0 2px 6px rgba(0,0,0,0.8);' +
        'pointer-events:none; opacity:0;' +
        'transition:transform 0.4s ease-out, opacity 0.3s ease-out;';
      document.getElementById('uiOverlay').appendChild(flyEl);
      
      requestAnimationFrame(() => {
        flyEl.style.transform = 'translate(-50%,-50%) scale(1)';
        flyEl.style.opacity = '1';
      });
      
      // Nach Fly-in: Kippziele ausblenden, Text + Button zeigen
      setTimeout(() => {
        // Alle nicht-erledigten Kippziele ausblenden
        for (let i = 0; i < 6; i++) {
          if (kipp21CardStates[i] !== 'erledigt') {
            const m = gameCards[i].mesh;
            m.material.transparent = true;
            m.material.needsUpdate = true;
            const startOp = m.material.opacity;
            const startT = performance.now();
            (function fadeCard(mesh, sOp, sT) {
              function fadeTick() {
                const t = Math.min((performance.now() - sT) / 400, 1);
                mesh.material.opacity = sOp * (1 - t);
                mesh.material.needsUpdate = true;
                if (t < 1) requestAnimationFrame(fadeTick);
                else mesh.visible = false;
              }
              requestAnimationFrame(fadeTick);
            })(m, startOp, startT);
          }
        }
        
        // "60 S" â†’ mehrzeiliger Text Ã¼ber Achsmitte
        flyEl.innerHTML = '60 Sek.<br>\u00fcberschritten';
        flyEl.style.fontSize = '30px';
        flyEl.style.textAlign = 'center';
        flyEl.style.lineHeight = '1.3';
        
        // HIT-Texte entfernen
        hitTextEls.forEach(el => el.remove());
        hitTextEls.length = 0;
        
        // Countdown + Hint ausblenden
        countdown.style.display = 'none';
        hintText.style.display = 'none';
        
        // NEUES SPIEL Button an Stelle der Kippziele
        const cardCenter3D = new THREE.Vector3(0, cardY, cardZ);
        cardCenter3D.project(camera);
        const btnY = Math.round((-cardCenter3D.y * 0.5 + 0.5) * 720);
        
        const neuesBtn = document.createElement('button');
        neuesBtn.id = 'timeoutNeuesSpielBtn';
        neuesBtn.textContent = 'NEUES SPIEL';
        neuesBtn.style.cssText = 'position:absolute; display:block; left:50%; transform:translateX(-50%);' +
          ' top:' + btnY + 'px; width:280px; height:49px;' +
          ' background:url(button_lang.webp) center/contain no-repeat;' +
          ' border:none; cursor:pointer; pointer-events:auto; z-index:15;' +
          ' font-family:Arial,sans-serif; font-size:18px; font-weight:bold;' +
          ' letter-spacing:2.5px; padding-top:4px;' +
          ' color:#d0d0d0; text-shadow:0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);' +
          ' opacity:0; transition:opacity 0.4s ease;';
        document.getElementById('uiOverlay').appendChild(neuesBtn);
        
        requestAnimationFrame(() => { neuesBtn.style.opacity = '1'; });
        
        function doRestart() {
          flyEl.remove();
          neuesBtn.remove();
          const abtn = document.getElementById('auswertungBtn');
          if (abtn) abtn.style.display = 'none';
          const esb = document.getElementById('endSpielenBtn');
          if (esb) esb.style.display = 'none';
          document.getElementById('perfektGameText').style.display = 'none'; document.getElementById('gameEndText').style.display = 'none';
          countdown.style.display = 'none';
          hintText.style.display = 'none';
          counterOrigPos = null;
          if (soundEnabled && bgMusic.paused) { bgMusic.play().catch(() => {}); }
          startKipp21(false);
        }
        
        neuesBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          doRestart();
        });
        neuesBtn.addEventListener('touchend', (e) => {
          e.stopPropagation();
          e.preventDefault();
          doRestart();
        });
      }, 800);
    }
    
    function kipp21OnCardTap(cardIdx, _fromReplay) {
      console.log('[CARDTAP] idx='+cardIdx, 'active='+kipp21Active, 'state='+kipp21CardStates[cardIdx], 'kniffActive='+kipp21KniffActive);
      // Tutorial lÃ¤uft: NUR Replay-Code darf Karten Ã¶ffnen
      if (replayActive && !_fromReplay) return;
      // Alte Replay-Generation: ignorieren (nur wenn Replay tatsÃ¤chlich lÃ¤uft)
      if (_fromReplay && replayActive && replayGeneration !== kipp21Generation) return;
      if (!kipp21Active) return;
      if (cardIdx < 0 || cardIdx >= 6) return;
      
      // Wobble-KNIFF abbrechen wenn aktiv â€” Tap wird nach Fall verarbeitet
      if (kipp21KniffActive) {
        kipp21KniffAbort = true;
        kipp21PendingCardTap = cardIdx;
        return;
      }
      
      const state = kipp21CardStates[cardIdx];
      
      if (state === 'verdeckt') {
        // GUARD: Nie 2 Kippziele gleichzeitig offen
        if (kipp21CardStates.indexOf('offen') >= 0) return;
        // GUARD: Kein Kniff wÃ¤hrend anderer Kniff lÃ¤uft
        if (kipp21KniffActive) return;
        
        if (_fromReplay) {
          // Nach Blick-Animation oder Tutorial: direkt Ã¶ffnen
          hideBlickIcon(cardIdx);
          if (!kipp21GenerateTarget(cardIdx)) return;
          const mesh = gameCards[cardIdx].mesh;
          mesh.scale.set(1.15, 1.15, 1.15);
          setTimeout(() => { mesh.scale.set(1, 1, 1); }, 180);
          return;
        }
        
        // Karte OHNE Blick-Icon â†’ direkt Ã¶ffnen (kein Kniff)
        const iconSrc = CARD_BLICK_MAP[cardIdx];
        if (!iconSrc) {
          if (!kipp21GenerateTarget(cardIdx)) return;
          const mesh = gameCards[cardIdx].mesh;
          mesh.scale.set(1.15, 1.15, 1.15);
          setTimeout(() => { mesh.scale.set(1, 1, 1); }, 180);
          return;
        }
        
        // Karte MIT Blick-Icon â†’ Blick-Animation starten
        const blickType = iconSrc.includes('joker2') ? 'wobble' : 'eckblick';
        hideBlickIcon(cardIdx);
        kipp21BlickTargetCard = cardIdx;
        if (blickType === 'wobble') runKipp21WobbleKniff();
        else runKipp21EckblickKniff();
        return;
      }
      
      if (state === 'offen') {
        // Einmaliges Pulse beim BestÃ¤tigen
        const cmesh = gameCards[cardIdx].mesh;
        cmesh.scale.set(1.15, 1.15, 1.15);
        setTimeout(() => { cmesh.scale.set(1, 1, 1); }, 180);
        // CONFIRM
        kipp21StopRoundTimer();
        
        activeCardIdx = cardIdx;
        const treffer = checkTreffer();
        
        if (treffer) {
          kipp21CardStates[cardIdx] = 'erledigt';
          drawGoldenBorder(gameCards[cardIdx]);
          gameCards[cardIdx].mesh.scale.set(1, 1, 1);
          kipp21Done++;
          updateProgressDots(kipp21Done, -1);
          
          // Card fliegt zum Treffer-Slot
          const card = gameCards[cardIdx];
          const isLastHit = (kipp21Done >= 6);
          const flyPromise = animateCardFly(card, treffer.quadrant, treffer.slot).then(() => {
            showHitText(cardIdx);
          });
          
          hintText.innerHTML = formatKipps(kipp21KippCount);
          
          if (kipp21Done >= 6) {
            // Bei Tutorial: der Replay-Code handelt das Ende selbst
            if (kipp21WithTutorial) {
              console.log('[END] Tutorial done=6, skip game-end (replay handles it)');
              return;
            }
            console.log('[END] kipp21Done='+kipp21Done+', calling showEndButtons');
            // DEBUG: Sichtbarer Status am Spielende
            let dbg = document.getElementById('endDebug');
            if (!dbg) {
              dbg = document.createElement('div');
              dbg.id = 'endDebug';
              dbg.style.cssText = 'position:absolute;bottom:4px;left:4px;font:bold 10px monospace;color:#0f0;background:rgba(0,0,0,0.85);padding:3px 6px;z-index:35;pointer-events:none;max-width:350px;word-wrap:break-word;';
              document.getElementById('uiOverlay').appendChild(dbg);
            }
            dbg.textContent = 'END: done='+kipp21Done+' kipps='+kipp21KippCount+' phase='+gamePhase;
            let isNewRecord = false;
            try {
              kipp21Active = false;
              gamePhase = 'ende';
              stopReplay();
              if (kipp21TimerInterval) clearInterval(kipp21TimerInterval);
              // Progress dots ausblenden
              const pd = document.getElementById('progressDots');
              if (pd) pd.style.display = 'none';
              // Personal Best aktualisieren
              isNewRecord = updatePersonalBest(kipp21KippCount);
              // Finalen Timer-Wert anzeigen
              countdown.innerHTML = formatTimer(kipp21TotalTime);
              const kl = document.getElementById('kipps21Label');
              if (kl) kl.innerHTML = formatCountdownLabel(kipp21TotalTime);
              // Joker-Reihe ausblenden
              hideKniffIcons();
            } catch(e) {
              console.error('[END] Pre-button error:', e);
              gamePhase = 'ende';
              kipp21Active = false;
            }
            // End-Buttons erst nach Kartenflug + 1s Pause, HITs bleiben bis dahin stehen
            const _isNewRecord = isNewRecord;
            flyPromise.then(() => setTimeout(() => {
              // JETZT erst HITs entfernen (alle 6 waren sichtbar)
              hitTextEls.forEach(el => {
                el.style.transition = 'opacity 0.5s ease-out';
                el.style.opacity = '0';
              });
              setTimeout(() => {
                hitTextEls.forEach(el => el.remove());
                hitTextEls.length = 0;
                document.querySelectorAll('.hit-text-el').forEach(el => el.remove());
              }, 500);
              showEndButtons(false, _isNewRecord);
            }, 1000));
            }
          }
        } else {
          // WRONG - red flash
          const card = gameCards[cardIdx];
          card.ctx.strokeStyle = '#ff3333';
          card.ctx.lineWidth = 4;
          card.ctx.strokeRect(2, 2, 81, 166);
          card.texture.needsUpdate = true;
          
          setTimeout(() => {
            if (kipp21CardStates[cardIdx] === 'offen') {
              const img = colorTargetImages[card.color.name];
              card.ctx.clearRect(0, 0, 85, 170);
              card.ctx.drawImage(img, 0, 0, 85, 170);
              const displayText = card.zahl + ((card.zahl === 6 || card.zahl === 9) ? '.' : '');
              card.ctx.fillStyle = '#2a1810';
              card.ctx.font = 'bold 56px Arial';
              card.ctx.textAlign = 'center';
              card.ctx.textBaseline = 'middle';
              card.ctx.fillText(displayText, 42, 42);
              card.texture.needsUpdate = true;
            }
          }, 600);
          
          // Timer lÃ¤uft erst bei nÃ¤chster WÃ¼rfelberÃ¼hrung weiter
        }
      }


    // === Offene Kippziele: genau 2 von 6 haben eine Zahl, die in der aktuellen Ausgangslage sichtbar ist ===
    function pickTwoRandomPositions() {
      const all = [0, 1, 2, 3, 4, 5];
      for (let i = all.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [all[i], all[j]] = [all[j], all[i]];
      }
      return new Set([all[0], all[1]]);
    }
    let openKippzielPositions = pickTwoRandomPositions();
    let offeneKippzieleVergeben = 0; // ZÃ¤hlt wie viele offene bereits generiert wurden
    let isReplay = false; // Nach "Neues Spiel" â†’ kein ErklÃ¤rtext

    // Aktuell sichtbare Zahlen auf der Oberseite ermitteln (aus aktuellem topFace)
    function getCurrentVisibleZahlen() {
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      return new Set([deck[off], deck[off+1], deck[off+2], deck[off+3]]);
    }

    function fillCardWithKombi(idx, zahl, colorObj) {
      const card = gameCards[idx];
      
      // Zahl und Farbe im Card-Object speichern
      card.zahl = zahl;
      card.color = colorObj;
      
      // Farb-Image auf Canvas zeichnen
      const img = colorTargetImages[colorObj.name];
      if (!img) {
        console.error(`Image ${colorObj.name} not loaded!`);
        return;
      }
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      // Zahl 42px unter Oberkante
      const displayText = zahl + ((zahl === 6 || zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.visible = true; // KÃ¤rtchen sichtbar machen
      
      // Kombi als ausgegeben markieren
      bereitsAusgegeben.add(zahl + '_' + colorObj.name);
    }
    
    function drawGoldenBorder(card) {
      // CMYK: 18, 20, 85, 3 â†’ RGB: #cedb25
      card.ctx.strokeStyle = '#cedb25';
      card.ctx.lineWidth = 4;
      card.ctx.strokeRect(2, 2, 85 - 4, 170 - 4);
      card.texture.needsUpdate = true;
      
      // Markieren dass dieses KÃ¤rtchen ein Treffer ist
      card.isHit = true;
    }
    

    function generateNeueKombiOhne(ausschlussSet, zahlenFilter, visibleZahlen) {
      // zahlenFilter: 'open' = nur sichtbare Zahlen, 'closed' = nur NICHT sichtbare, undefined = alle
      // visibleZahlen: Set der aktuell sichtbaren Zahlen (nur nÃ¶tig wenn zahlenFilter gesetzt)
      const alleMoeglichenKombis = [];
      for (let z = 1; z <= 12; z++) {
        if (zahlenFilter === 'open' && visibleZahlen && !visibleZahlen.has(z)) continue;
        if (zahlenFilter === 'closed' && visibleZahlen && visibleZahlen.has(z)) continue;
        
        for (const colorObj of GAME_COLORS) {
          const key = z + '_' + colorObj.name;
          if (!bereitsAusgegeben.has(key) && !ausschlussSet.has(key)) {
            alleMoeglichenKombis.push({ zahl: z, color: colorObj });
          }
        }
      }
      
      if (alleMoeglichenKombis.length === 0) return null;
      
      const idx = Math.floor(Math.random() * alleMoeglichenKombis.length);
      return alleMoeglichenKombis[idx];
    }

    function getCurrentErfuellteKombis() {
      // Aktuelle WÃ¼rfellage ermitteln und erfÃ¼llte Kombis zurÃ¼ckgeben
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const erfuellteKombis = new Set();
      const slots = ['S1', 'S2', 'S3', 'S4'];
      slots.forEach((slot, i) => {
        const zahl = deck[off + i];
        const farbe = SLOT_NEIGHBOR_COLORS[currentQuadrant][slot];
        erfuellteKombis.add(zahl + '_' + farbe);
      });
      return erfuellteKombis;
    }


    function onRunde() {
      activeCardIdx++;
      
      // Nach 6 Versuchen: Spielende
      if (activeCardIdx >= 6) {
        showGameEnd();
        return;
      }
      
      // ERST: NEUES KÃ„RTCHEN GENERIEREN
      if (activeCardIdx < 6) {
        const erfuellteKombis = getCurrentErfuellteKombis();
        const visibleZahlen = getCurrentVisibleZahlen();
        let zahlenFilter;
        if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
          zahlenFilter = 'open';
        } else {
          zahlenFilter = 'closed';
        }
        let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
        if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis); // Fallback
        if (neueKombi) {
          if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
          fillCardWithKombi(activeCardIdx, neueKombi.zahl, neueKombi.color);
        }
      }
      
      // DANN: Pause-Check (ÃœBERSPRUNGEN - Pause-Phase deaktiviert)
      // if (activeCardIdx === 3) {
      //   setButtonsDisabled(true);
      //   document.getElementById('richtungButtons').classList.add('hidden');
      //   kippButtons.classList.add('hidden');
      //   savedCubePosition = cube.position.clone();
      //   savedCubeQuaternion = cube.quaternion.clone();
      //   savedTopFace = topFace;
      //   savedCurrentQuadrant = currentQuadrant;
      //   animateAufEcke().then(() => {
      //     startPausePhase();
      //   });
      //   return;
      // }
      
      // Weiterspielen
      setButtonsDisabled(false);
    }
    

    function showGameEnd() {
      // Tutorial: Replay-Code handelt das Ende selbst
      if (kipp21WithTutorial) { console.log('[showGameEnd] skip â€” tutorial'); return; }
      gamePhase = 'ende';
      let isNewRec = false;
      try {
        hideKniffIcons();
        schauenWobbleActive = false; isDemoAnimating = false;
        handDemo.visible = false;
        stopCountdown();
        setButtonsDisabled(true);
        document.getElementById('richtungButtons').classList.add('hidden');
        kippButtons.classList.add('hidden');
        document.getElementById('kippTarget').style.display = 'none';
        document.getElementById('tutorialText').style.display = 'none';
        document.getElementById('instructionText').style.display = 'none';
        document.getElementById('entscheidungText').style.display = 'none';
        document.getElementById('eyeIcon').style.display = 'none';
        const jr1 = document.getElementById('jokerIconsRow');
        if (jr1) { jr1.style.display = 'none'; jr1.style.opacity = '0'; }
        document.getElementById('zumSpielBtn').style.display = 'none';
        document.getElementById('perfektGameText').style.display = 'none'; document.getElementById('gameEndText').style.display = 'none';
        countdown.style.display = 'none';
        hintText.style.display = 'none';
        const _pd2 = document.getElementById('progressDots');
        if (_pd2) _pd2.style.display = 'none';
        isNewRec = updatePersonalBest(kipp21KippCount);
        actionButton.style.display = 'none';
      } catch(e) {
        console.error('[showGameEnd] cleanup error:', e);
      }
      // End-Buttons zeigen â€” IMMER
      showEndButtons(false, isNewRec);
    }
    
    // === AUSWERTUNG Overlay ===
    // Array zum Speichern der ursprÃ¼nglichen opacity-Werte
    const savedCardOpacities = [];

    function startPausePhase() {
      gamePhase = 'pause';
      pauseExiting = false;
      hideKniffIcons();
      document.getElementById('kippTarget').style.display = 'none';

      // Aktuelle opacity aller 6 KÃ¤rtchen speichern
      savedCardOpacities.length = 0;
      gameCards.forEach(c => {
        savedCardOpacities.push(c.mesh.material.opacity);
        c.mesh.material.transparent = true;
        c.mesh.material.needsUpdate = true;
      });
      
      shadowGradPlane.material.transparent = true;
      shadowGradPlane.material.needsUpdate = true;
      shadowGradPlane.material.opacity = 1;

      // Alle 6 KÃ¤rtchen auf opacity 0 animieren
      const startOpacities = savedCardOpacities.slice();
      animateVal(1, 0, 350, (t) => {
        gameCards.forEach((c, i) => { 
          c.mesh.material.opacity = startOpacities[i] * t; 
        });
        shadowGradPlane.material.opacity = t;
      }, () => {
        // KÃ¤rtchen komplett ausblenden
        gameCards.forEach(c => c.mesh.visible = false);
        pauseLights.forEach(l => l.visible = true);

        // Pause-Pivot auf der Ecke erstellen
        const cornerPos = new THREE.Vector3(0, 0, 0.109375);
        pausePivotGroup = new THREE.Group();
        pausePivotGroup.position.copy(cornerPos);
        kipGroup.add(pausePivotGroup);

        cube.updateMatrixWorld();
        const wp = new THREE.Vector3();
        cube.getWorldPosition(wp);
        const wq = new THREE.Quaternion();
        cube.getWorldQuaternion(wq);

        kipGroup.remove(cube);
        cube.position.copy(wp.clone().sub(cornerPos));
        cube.quaternion.copy(wq);
        pausePivotGroup.add(cube);

        pauseAlpha = 0;
        pauseBeta  = 0;
        pauseDragActive = false;

        // UI faden ein (ohne Text)
        hintText.style.display = 'none';
        actionButton.textContent = T.w;
        actionButton.style.opacity = '0';
        actionButton.style.display = 'block';

        // requestAnimationFrame damit display:block erstmal greift
        requestAnimationFrame(() => {
          actionButton.style.transition = 'opacity 0.4s ease';
          actionButton.style.opacity = '1';
        });
      });
    }

    function endPausePhase() {
      if (pauseExiting) return;
      pauseExiting = true;
      pauseSpringRunning = false;
      pauseDragActive = false;
      if (pauseTimerRef) { clearInterval(pauseTimerRef); pauseTimerRef = null; }

      // UI faden aus
      hintText.style.transition = 'opacity 0.35s ease';
      actionButton.style.transition = 'opacity 0.35s ease';
      hintText.style.opacity = '0';
      actionButton.style.opacity = '0';
      setTimeout(() => {
        hintText.style.display = 'none';
        actionButton.style.display = 'none';
      }, 350);

      // Schritt 1: Aufrichten von aktueller Position auf senkrecht (alpha=0, beta=0)
      const startAlpha = pauseAlpha;
      const startBeta  = pauseBeta;
      const aufrichtDur = 600;
      const aufrichtStart = Date.now();

      function animateAufrichten() {
        const elapsed = Date.now() - aufrichtStart;
        const progress = Math.min(elapsed / aufrichtDur, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        pauseAlpha = startAlpha * (1 - eased);
        pauseBeta  = startBeta  * (1 - eased);
        if (pausePivotGroup) pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');

        if (progress < 1) {
          requestAnimationFrame(animateAufrichten);
        } else {
          pauseAlpha = 0;
          pauseBeta  = 0;
          if (pausePivotGroup) pausePivotGroup.rotation.set(0, 0, 0, 'YXZ');
          // Schritt 2: Inverse aufEcke â€” zurÃ¼ck auf letzte Spielposition
          animateInverseAufEcke();
        }
      }
      animateAufrichten();
    }

    function animateInverseAufEcke() {
      const duration = 1200;
      const startTime = Date.now();
      const inverseQuat = aufEckeTargetQuat.clone().invert();

      function animateZurÃ¼ck() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        const currentQuat = new THREE.Quaternion().slerp(inverseQuat, eased);
        if (pausePivotGroup) pausePivotGroup.quaternion.copy(currentQuat);

        if (progress < 1) {
          requestAnimationFrame(animateZurÃ¼ck);
        } else {
          finishPauseToSpiel();
        }
      }
      animateZurÃ¼ck();
    }

    async function animateAufEcke() {
      const cornerPos = new THREE.Vector3(0, 0, 0.109375); // Die feste Ecke
      const duration = 1200;

      // Cube aus kipGroup nehmen, in pivotGroup bei der Ecke platzieren
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(cornerPos);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      const cubeWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(cubeWorldQuat);

      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(cornerPos));
      cube.quaternion.copy(cubeWorldQuat);
      pivotGroup.add(cube);

      // Ziel-Rotation: KÃ¶rperdiagonale senkrecht zu Ï€1
      // Exakter analytischer Vektor statt cube.position (Gleitkomma-Drift vermeiden)
      const o = 0.234375;
      const diagVecs = {
        0: new THREE.Vector3(-o, o, -o),
        1: new THREE.Vector3( o, o, -o),
        2: new THREE.Vector3( o, o,  o),
        3: new THREE.Vector3(-o, o,  o)
      };
      const relativePos = diagVecs[currentQuadrant].clone().normalize();
      const targetDir = new THREE.Vector3(0, 1, 0);
      const targetQuat = new THREE.Quaternion().setFromUnitVectors(relativePos, targetDir);
      aufEckeTargetQuat = targetQuat.clone();

      const startTime = Date.now();

      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          const currentQuat = new THREE.Quaternion().copy(new THREE.Quaternion()).slerp(targetQuat, eased);
          pivotGroup.quaternion.copy(currentQuat);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Cleanup: wie finalizeKipp
            cube.updateMatrixWorld();
            const newWorldPos = new THREE.Vector3();
            cube.getWorldPosition(newWorldPos);
            const newWorldQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newWorldQuat);

            pivotGroup.remove(cube);
            kipGroup.remove(pivotGroup);

            cube.position.copy(newWorldPos);
            cube.quaternion.copy(newWorldQuat);
            kipGroup.add(cube);

            resolve();
          }
        }
        animate();
      });
    }

    function animateTreffer(hitInfo) {
      const card = gameCards[activeCardIdx];
      const mesh = card.mesh;
      
      // Goldenen Rahmen sofort zeichnen
      drawGoldenBorder(card);
      
      // Kurze Puls-Animation (2 Pulse), dann Flug
      const pulseDuration = 180;
      const pulseCount = 2;
      let currentPulse = 0;
      
      function doPulse() {
        if (currentPulse >= pulseCount) {
          // Flug zum Treffer-Slot
          animateCardFly(card, hitInfo.quadrant, hitInfo.slot).then(() => {
            showHitText(activeCardIdx);
            setTimeout(() => onRunde(), 600);
          });
          return;
        }
        
        const startTime = performance.now();
        function animatePulse(now) {
          const t = Math.min((now - startTime) / pulseDuration, 1);
          const scale = 1.0 + Math.sin(t * Math.PI) * 0.15;
          mesh.scale.set(scale, scale, scale);
          
          if (t < 1) {
            requestAnimationFrame(animatePulse);
          } else {
            mesh.scale.set(1, 1, 1);
            currentPulse++;
            setTimeout(doPulse, 80);
          }
        }
        requestAnimationFrame(animatePulse);
      }
      
      doPulse();
    }

    function animateNichtTreffer() {
      const card = gameCards[activeCardIdx];
      
      // Aktuelles KÃ¤rtchen durch leernohit ersetzen
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(leerImage, 0, 0, 85, 170);
      card.texture.needsUpdate = true;
      
      // Auf 60% transparent setzen
      card.mesh.material.transparent = true;
      card.mesh.material.opacity = 0.6;
      card.mesh.material.needsUpdate = true;
      
      // Markieren als gespielt (Nicht-Treffer) und zahl/color lÃ¶schen
      card.zahl = null;
      card.color = null;
      card.isMiss = true;
      
      // Weiter zur nÃ¤chsten Runde (onRunde erhÃ¶ht activeCardIdx und generiert nÃ¤chstes KÃ¤rtchen)
      onRunde();
    }

    let gamePhase = 'start';
    let currentMode = 'kanten';
    let kippCount = 0;
    let liegeZeiten = [];
    let liegeStartTime = null;
    let countdownTimer = null;
    


    // UI fÃ¼r Demo-Phase initialisieren
    hintText.textContent = ''; // Leer lassen - Text-Sequenz Ã¼bernimmt
    actionButton.style.display = 'none';
    countdown.style.display = 'none';
    
    // Flag um Demo-Animation abbrechen zu kÃ¶nnen
    let isDemoAnimating = false;
    let schauenWobbleActive = false;
    let schauenFromSpielen = false;
    
    function startCountdown(onFinish, maxTime) {
      let timeRemaining = maxTime;
      countdown.textContent = timeRemaining;
      countdown.style.display = 'none'; // Timer jetzt unter Kippzielen
      countdown.style.left = '180px';
      
      countdownTimer = setInterval(() => {
        timeRemaining--;
        countdown.textContent = timeRemaining;
        if (timeRemaining <= 0) {
          stopCountdown();
          countdown.style.display = 'none';
          if (onFinish) onFinish();
        }
      }, 1000);
    }
    
    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }
    
    // Timer deaktiviert
    let timerStarted = false;

    // =========================
    // DEMO-ANIMATION Phase 1
    // =========================
    
    function showTextAtWobble() {
      // Text-Animation deaktiviert
    }
    
    
    // === PHASE 1: SPIEL ZIEL ===
    // Farbnamen fÃ¼r Tutorial-Anzeige
    var FARB_DISPLAY = {"violett":T.fV,"blau":T.fB,"gruen":T.fG,"orange":T.fO};


    
    // Beispiel-Kippziel aus aktueller WÃ¼rfellage (Q3, f2 oben) generieren
    function initSpielzielPhase() {
      // Bei Replay: Spielziel Ã¼berspringen, direkt zur Entscheidung
      if (isReplay) {
        initEntscheidungPhase();
        return;
      }
      
      gamePhase = 'spielziel';
      
      // Position immer auf erstes KÃ¤rtchen zurÃ¼cksetzen (wichtig nach "Neues Spiel")
      verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
      
      // ZufÃ¤lligen Slot wÃ¤hlen (S1-S4)
      const slotIdx = Math.floor(Math.random() * 4);
      const slotNames = ['S1', 'S2', 'S3', 'S4'];
      const beispielZahl = deck[8 + slotIdx]; // f2 offset = 8
      const beispielFarbe = SLOT_NEIGHBOR_COLORS[3][slotNames[slotIdx]]; // Q3
      const farbDisplay = FARB_DISPLAY[beispielFarbe] || beispielFarbe;
      
      // Beispiel-Kippziel auf verdecktesMesh zeichnen
      function drawBeispiel() {
        if (!texturesReady || !colorTargetImages[beispielFarbe]) {
          setTimeout(drawBeispiel, 50);
          return;
        }
        const img = colorTargetImages[beispielFarbe];
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(img, 0, 0, 85, 170);
        const displayText = beispielZahl + ((beispielZahl === 6 || beispielZahl === 9) ? '.' : '');
        verdecktesCtx.fillStyle = '#2a1810';
        verdecktesCtx.font = 'bold 56px Arial';
        verdecktesCtx.textAlign = 'center';
        verdecktesCtx.textBaseline = 'middle';
        verdecktesCtx.fillText(displayText, 42, 42);
        verdecktesCanvasTex.needsUpdate = true;
      }
      drawBeispiel();
      
      // Mesh sichtbar mit Beispiel, kein Puls
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Texte
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      
      // ZurÃ¼ck-Button zur Startseite zeigen (per 3D-Projektion positioniert)
      positionResetButton();
      
      const szText = document.getElementById('spielZielText');
      szText.innerHTML = "<b>" + T.s1 + "</b><br>" + T.s2.replace("{zahl}",beispielZahl).replace("{farbe}",farbDisplay);


      szText.style.display = 'block';
      
      // weiter-Button zentriert unter Text positionieren
      actionButton.textContent = T.w;
      actionButton.disabled = false;
      actionButton.style.display = 'block';
      actionButton.style.opacity = '1';
      
      setTimeout(() => {
        const szRect = szText.getBoundingClientRect();
        const containerRect = renderer.domElement.getBoundingClientRect();
        const topVal = (szRect.bottom - containerRect.top + 32) + 'px';
        actionButton.style.top = topVal;
        actionButton.style.left = '180px';
        timerTopPos = topVal; // Position fÃ¼r alle Timer merken
      }, 10);
    }
    let timerTopPos = null;
    // === START-OVERLAY: Warten auf Spieler-Wahl ===
    // =========================
    // AUTO-DEMO MODULE
    // =========================
    let autoDemoActive = false;

    // === SUBTITLE ENGINE ===
    const subEl = document.getElementById('demoSubtitle');
    const jokerRow = document.getElementById('jokerIconsRow');

    // Kniff Joker Icons (90x90 WebP, display 45x45)
    const KNIFF_ICONS = [
      "joker2.webp",
      "joker3.webp"
    ];

    // Populate jokerIconsRow: je 2 unabhÃ¤ngige Bilder Ã¼bereinander (bottom + top)
    try {
      KNIFF_ICONS.forEach((src, i) => {
        // Bottom icon (unterer, 8px westlicher versetzt)
        const bot = document.createElement('img');
        bot.src = src;
        bot.dataset.kniffIdx = i;
        bot.dataset.layer = 'bottom';
        bot.style.zIndex = '1';
        jokerRow.appendChild(bot);
        
        // Top icon (oberer, auf Originalposition)
        const top = document.createElement('img');
        top.src = src;
        top.dataset.kniffIdx = i;
        top.dataset.layer = 'top';
        top.style.zIndex = '2';
        jokerRow.appendChild(top);
      });
    } catch(e) { console.error('Joker icon setup error:', e); }

    // Click-Handler fÃ¼r alle Joker-Icons (bottom + top)
    (function() {
      let kniffTouchHandled = false;
      jokerRow.querySelectorAll('img').forEach(img => {
        img.addEventListener('touchend', (e) => {
          e.stopPropagation(); e.preventDefault();
          if (replayActive) return; // Tutorial: keine Interaktion
          const idx = parseInt(img.dataset.kniffIdx);
          kniffTouchHandled = true;
          if (idx === 0) runKipp21WobbleKniff();
          else runKipp21EckblickKniff();
          setTimeout(() => { kniffTouchHandled = false; }, 300);
        });
        img.addEventListener('click', (e) => {
          e.stopPropagation(); e.preventDefault();
          if (replayActive || kniffTouchHandled) return;
          const idx = parseInt(img.dataset.kniffIdx);
          if (idx === 0) runKipp21WobbleKniff();
          else runKipp21EckblickKniff();
        });
      });
    })();

    // === KNIFF ICONS: Show/Hide ===
    // === ECKE-HAKEN: BestÃ¤tigungsbuttons in den 4 Rahmenecken ===
    const hakenEls = [
      document.getElementById('hakenQ0'),
      document.getElementById('hakenQ1'),
      document.getElementById('hakenQ2'),
      document.getElementById('hakenQ3')
    ];
    // 3D-Positionen der 4 Rahmenecken (auf Rahmen-Oberkante)
    const hakenPos3D = [
      new THREE.Vector3(-0.546875, 0.479, -0.437500), // Q0 NW
      new THREE.Vector3( 0.546875, 0.479, -0.437500), // Q1 NE
      new THREE.Vector3( 0.546875, 0.479,  0.658000), // Q2 SE
      new THREE.Vector3(-0.546875, 0.479,  0.658000)  // Q3 SW
    ];
    
    function positionEckeHaken() {
      for (let i = 0; i < 4; i++) {
        const p = hakenPos3D[i].clone().project(camera);
        const sx = (p.x * 0.5 + 0.5) * 360 - 20; // zentriert (40px breit)
        const sy = (-p.y * 0.5 + 0.5) * 720 - 20; // zentriert (40px hoch)
        hakenEls[i].style.left = sx + 'px';
        hakenEls[i].style.top = sy + 'px';
      }
    }
    
    function showEckeHaken() {
      positionEckeHaken();
      hakenEls.forEach(el => { el.style.display = 'block'; });
    }
    
    function hideEckeHaken() {
      hakenEls.forEach(el => { el.style.display = 'none'; });
    }
    
    // Click-Handler fÃ¼r alle 4 Haken
    hakenEls.forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        if (gamePhase !== 'spielen' || kippzielChecked || kippCount < 1) return;
        hideEckeHaken();
        checkKippzielTap();
      });
      el.addEventListener('touchend', (e) => {
        e.stopPropagation();
        e.preventDefault();
        if (gamePhase !== 'spielen' || kippzielChecked || kippCount < 1) return;
        hideEckeHaken();
        checkKippzielTap();
      });
    });

    function showKniffIcons() {
      // Kniff Icons 12px nÃ¶rdlich der alten Position
      jokerRow.style.top = '523px';
      
      // 2 logische Icons, je bottom+top = 4 img Elemente
      const allImgs = jokerRow.querySelectorAll('img');
      const totalWidth = 360, iconW = 58;
      const iconCount = 2; // logisch 2 Icons
      const gap = (totalWidth - iconCount * iconW) / (iconCount + 1);
      const edgeShift = 45; // je 45px weiter zum Bildschirmrand
      
      for (let i = 0; i < allImgs.length; i++) {
        const kniffIdx = parseInt(allImgs[i].dataset.kniffIdx);
        const isTop = allImgs[i].dataset.layer === 'top';
        const centerX = gap + kniffIdx * (iconW + gap) + iconW / 2;
        const shifted = centerX + (kniffIdx === 0 ? -edgeShift : edgeShift);
        // Bottom: 8px westlicher, Top: auf Originalposition
        allImgs[i].style.left = Math.round(shifted + (isTop ? 0 : -8)) + 'px';
        allImgs[i].style.display = '';
        allImgs[i].style.opacity = '1';
        allImgs[i].style.visibility = 'visible';
        allImgs[i].style.transform = 'translateX(-50%)';
        allImgs[i].style.transition = '';
        allImgs[i].style.pointerEvents = 'auto';
      }
      
      // "WÃ¼rfel-Einblick wÃ¤hlen" nur vor erster Wahl zeigen
      let jLabel = jokerRow.querySelector('.jokerLabel');
      if (!jLabel) {
        jLabel = document.createElement('div');
        jLabel.className = 'jokerLabel';
        jLabel.style.cssText = 'position:absolute; top:29px; left:50%; transform:translate(-50%,-50%); font-family:Arial,sans-serif; font-size:18px; font-weight:bold; color:#e0d0b8; text-shadow:0 1px 3px rgba(0,0,0,0.9); text-align:center; line-height:1.3; pointer-events:none;';
        jLabel.innerHTML = T.jw;
        jokerRow.appendChild(jLabel);
      }
      const jokerUsed = kipp21WobbleUsed + kipp21EckblickUsed;
      jLabel.innerHTML = T.jw; // ZurÃ¼cksetzen (Kippen-Warnung Ã¼berschreibt)
      jLabel.style.display = jokerUsed > 0 ? 'none' : 'block';
      
      // "zum SPIEL" Button nicht mehr zeigen
      const zsb = document.getElementById('zumSpielBtn');
      zsb.style.display = 'none';
      
      jokerRow.style.display = 'block';
      jokerRow.style.opacity = '1';
    }
    
    function hideKniffIcons() {
      jokerRow.style.opacity = '0';
      const zsb = document.getElementById('zumSpielBtn');
      if (zsb) { zsb.style.opacity = '0'; }
      setTimeout(() => {
        jokerRow.style.display = 'none';
        if (zsb) zsb.style.display = 'none';
      }, 350);
    }
    
    
    // Kniff-Icon Klick: ausblenden (Funktionen folgen spÃ¤ter)
    jokerRow.addEventListener('click', (e) => {
      const img = e.target.closest('img');
      if (!img || (gamePhase !== 'spielen' && gamePhase !== 'kipp21')) return;
      e.stopPropagation();
      hideKniffIcons();
    });
    
    // "zum SPIEL" Button: Joker-Reihe schlieÃŸen
    (function() {
      const zsBtn = document.getElementById('zumSpielBtn');
      let zsTouchHandled = false;
      zsBtn.addEventListener('touchend', (e) => {
        e.stopPropagation(); e.preventDefault();
        zsTouchHandled = true;
        hideKniffIcons();
        setTimeout(() => { zsTouchHandled = false; }, 300);
      });
      zsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (zsTouchHandled) return;
        hideKniffIcons();
      });
    })();

    async function showSubtitle(text, duration) {
      duration = duration || 2000;
      if (!text || text === '') return await sleep(duration); // skip empty lines
      // LinksbÃ¼ndig neben dem Kippziel positionieren
      const vp = verdecktesMesh.position.clone();
      vp.x += cardWidth / 2 + 0.02; // rechte Kante + kleiner Abstand
      vp.project(camera);
      const screenLeft = (vp.x * 0.5 + 0.5) * 360;
      subEl.style.left = Math.round(screenLeft + 12) + 'px';
      subEl.innerHTML = text;
      subEl.style.display = 'block';
      subEl.style.opacity = '1';
      await sleep(duration);
      if (!autoDemoActive) { subEl.style.opacity = '0'; return; }
      subEl.style.opacity = '0';
      await sleep(350); // fade out transition time
    }

    async function showSubtitleSequence(lines, perLine) {
      perLine = perLine || 2500;
      for (let i = 0; i < lines.length; i++) {
        if (!autoDemoActive) return;
        const dur = (i === 0) ? 4000 : perLine;
        await showSubtitle(lines[i], dur);
      }
    }

    function hideSubtitle() {
      subEl.style.opacity = '0';
      setTimeout(() => { subEl.style.display = 'none'; }, 350);
    }

    // Solver: Find (steps, direction) to reach target (zahl + color) from current state
    function solveKippziel(zahl, colorName, fromQ, fromFace) {
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      let targetFace = null, targetQ = null;
      for (const face of ['f0', 'f1', 'f2']) {
        const off = faceOff[face];
        const slots = ['S1', 'S2', 'S3', 'S4'];
        for (let i = 0; i < 4; i++) {
          if (deck[off + i] === zahl) {
            for (let q = 0; q < 4; q++) {
              if (SLOT_NEIGHBOR_COLORS[q][slots[i]] === colorName) {
                targetFace = face; targetQ = q;
                break;
              }
            }
          }
          if (targetFace) break;
        }
        if (targetFace) break;
      }
      if (!targetFace) return null;
      const cwF = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccwF = { f2: 'f1', f1: 'f0', f0: 'f2' };
      const cwQ = { 3: 0, 0: 1, 1: 2, 2: 3 };
      const ccwQ = { 3: 2, 2: 1, 1: 0, 0: 3 };
      // Try CW
      let sQ = fromQ, sF = fromFace;
      for (let s = 1; s <= 6; s++) {
        sQ = cwQ[sQ]; sF = cwF[sF];
        if (sQ === targetQ && sF === targetFace) return { steps: s, dir: 'cw' };
      }
      // Try CCW
      sQ = fromQ; sF = fromFace;
      for (let s = 1; s <= 6; s++) {
        sQ = ccwQ[sQ]; sF = ccwF[sF];
        if (sQ === targetQ && sF === targetFace) return { steps: s, dir: 'ccw' };
      }
      return null;
    }

    // Draw kippziel on verdecktes mesh without side effects
    function autoRevealKippziel(zahl, colorObj) {
      erstesKippziel = { zahl: zahl, color: colorObj };
      const img = colorTargetImages[colorObj.name];
      verdecktesCtx.clearRect(0, 0, 85, 170);
      verdecktesCtx.drawImage(img, 0, 0, 85, 170);
      const displayText = zahl + ((zahl === 6 || zahl === 9) ? '.' : '');
      verdecktesCtx.fillStyle = '#2a1810';
      verdecktesCtx.font = 'bold 56px Arial';
      verdecktesCtx.textAlign = 'center';
      verdecktesCtx.textBaseline = 'middle';
      verdecktesCtx.fillText(displayText, 42, 42);
      // Nuclear: fresh texture object â€” Three.js cannot cache what it never saw
      const freshTex = new THREE.CanvasTexture(verdecktesCanvas);
      verdecktesMat.map = freshTex;
      verdecktesMat.transparent = true;
      verdecktesMat.opacity = 1;
      verdecktesMat.needsUpdate = true;
      verdecktesMesh.material = verdecktesMat;
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMesh.userData.revealed = true;
    }

    // Perform N kipps in given direction (no game-state side effects)
    async function autoPerformKipps(steps, dir) {
      for (let i = 0; i < steps; i++) {
        let direction;
        if (dir === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north';
        } else {
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3';
        }
        isAnimating = false;
        kippDirection = dir;
        await performKipp(direction, 700);
        advanceTopFace();
        if (i < steps - 1) await sleep(300);
      }
      isAnimating = false;
    }

    // === HALF-KIPP WITH WOBBLE ===
    // Realistic "peek at 2 faces" technique: tilt to edge, wobble slowly, then complete
    async function halfKippWithWobble(direction, wobbleCount, wobblePause) {
      wobbleCount = wobbleCount || 3;
      wobblePause = wobblePause || 0; // extra pause after wobble before completing

      // Direction â†’ pivot definitions (same as performKipp)
      const defs = {
        'north':         { pivot: [-0.234375, 0, 0.109375],       ax: 'x', angle: -Math.PI/2, toQ: 0 },
        'south':         { pivot: [-0.234375, 0, 0.109375],       ax: 'x', angle:  Math.PI/2, toQ: 3 },
        'east':          { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle: -Math.PI/2, toQ: 1 },
        'west':          { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivot: [0.234375, 0, 0.109375],        ax: 'x', angle:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivot: [0.234375, 0, 0.109375],        ax: 'x', angle: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle: -Math.PI/2, toQ: 2 }
      };
      const def = defs[direction];
      if (!def) return;

      const pivotPoint = new THREE.Vector3(def.pivot[0], def.pivot[1], def.pivot[2]);
      const fullAngle = def.angle;
      const halfAngle = fullAngle * 0.5;           // 45Â°
      const wobbleMin = fullAngle * 0.35;           // ~31.5Â°
      const wobbleMax = fullAngle * 0.65;           // ~58.5Â°

      // --- Setup pivot (cube stays in pivot for entire sequence) ---
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(pivotPoint));
      pivotGroup.add(cube);

      function setAngle(a) {
        if (def.ax === 'x') pivotGroup.rotation.x = a;
        else pivotGroup.rotation.z = a;
      }

      // Helper: animate angle from â†’ to
      function animAngle(from, to, dur) {
        return new Promise(resolve => {
          const startTime = performance.now();
          function tick() {
            const t = Math.min((performance.now() - startTime) / dur, 1);
            const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
            setAngle(from + (to - from) * ease);
            if (t < 1) requestAnimationFrame(tick);
            else { setAngle(to); resolve(); }
          }
          requestAnimationFrame(tick);
        });
      }

      // 1) Tilt to half angle (45Â°) â€” 600ms, smooth
      await animAngle(0, halfAngle, 600);

      // 2) Wobble: slow oscillation between wobbleMin and wobbleMax
      let currentAnglePos = halfAngle;
      for (let w = 0; w < wobbleCount; w++) {
        const target = (w % 2 === 0) ? wobbleMin : wobbleMax;
        await animAngle(currentAnglePos, target, 800);
        currentAnglePos = target;
      }
      // Return to halfAngle
      if (Math.abs(currentAnglePos - halfAngle) > 0.01) {
        await animAngle(currentAnglePos, halfAngle, 500);
      }

      // Optional extra pause (player is memorizing)
      if (wobblePause > 0) await sleep(wobblePause);

      // 3) Complete: animate from halfAngle to fullAngle â€” 500ms
      await animAngle(halfAngle, fullAngle, 500);

      // --- Finalize: extract cube from pivot ---
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);

      pivotGroup.remove(cube);
      kipGroup.remove(pivotGroup);
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);

      // Snap Y
      if (Math.abs(cube.position.y - offset) < 0.01) cube.position.y = offset;

      currentQuadrant = def.toQ;
      advanceTopFace();
    }

    // Show HIT/MISS on verdecktes mesh (no proceedToNextRound timer)
    function autoDemoShowResult(isHit) {
      if (isHit) {
        verdecktesCtx.shadowColor = '#FFD700';
        verdecktesCtx.shadowBlur = 12;
        verdecktesCtx.strokeStyle = '#FFD700';
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCtx.shadowBlur = 0;
        verdecktesCtx.strokeStyle = '#FFF0A0';
        verdecktesCtx.lineWidth = 1;
        verdecktesCtx.strokeRect(7, 7, 71, 156);
        const hitTex = new THREE.CanvasTexture(verdecktesCanvas);
        verdecktesMat.map = hitTex;
        verdecktesMat.needsUpdate = true;
        // Pulse animation
        const startTime = performance.now();
        function pulseTick(now) {
          const t = Math.min((now - startTime) / 300, 1);
          const s = t < 0.5 ? 1 + 0.25 * (t * 2) : 1.25 - 0.25 * ((t - 0.5) * 2);
          verdecktesMesh.scale.set(s, s, s);
          if (t < 1) requestAnimationFrame(pulseTick);
          else verdecktesMesh.scale.set(1, 1, 1);
        }
        requestAnimationFrame(pulseTick);
      } else {
        const img = colorTargetImages[erstesKippziel.color.name];
        if (img) {
          verdecktesCtx.clearRect(0, 0, 85, 170);
          verdecktesCtx.drawImage(img, 0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'saturation';
          verdecktesCtx.fillStyle = 'hsl(0, 40%, 50%)';
          verdecktesCtx.fillRect(0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'source-over';
          const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
          verdecktesCtx.fillStyle = '#888888';
          verdecktesCtx.font = 'bold 56px Arial';
          verdecktesCtx.textAlign = 'center';
          verdecktesCtx.textBaseline = 'middle';
          verdecktesCtx.fillText(displayText, 42, 42);
        }
        verdecktesCtx.strokeStyle = '#FF2020';
        verdecktesCtx.lineWidth = 2;
        verdecktesCtx.strokeRect(1, 1, 83, 168);
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        const missTex = new THREE.CanvasTexture(verdecktesCanvas);
        verdecktesMat.map = missTex;
        verdecktesMat.needsUpdate = true;
      }
      // Show subtitle
      showSubtitle(isHit ? T.d4h : T.d4m, 2000);
    }

    // Transfer verdecktes visual to gameCard
    function autoDemoTransferToCard(idx) {
      const card = gameCards[idx];
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(verdecktesCanvas, 0, 0);
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.visible = true;
    }

    // === MAIN AUTO-DEMO ORCHESTRATOR ===
    async function runAutoDemo() {
      autoDemoActive = true;
      gamePhase = 'autoDemo';

      // Hide start overlay
      document.getElementById('startOverlay').style.display = 'none';

      // Stop any lingering timers/animations from previous runs
      stopCountdown();
      schauenWobbleActive = false; isDemoAnimating = false;
      handDemo.visible = false;

      // Reset cube to Q3, f2
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      currentQuadrant = 3;
      topFace = 'f2';
      kippDirection = 'cw';
      isAnimating = false;

      // Reset game state - COMPREHENSIVE
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      kippzielChecked = false;
      cubeLocked = false;
      erstesKippziel = null;
      tapCount = 0;
      kippCount = 0;
      lockedKippDir = null;
      currentDragDir = null;
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      timerStarted = false;
      dragActive = false;

      // Reset cards
      gameCards.forEach(c => { c.mesh.visible = false; c.zahl = null; c.color = null; c.isHit = false; c.isMiss = false; });
      blickIconMeshes.forEach(m => { m.visible = false; });

      // Hide all UI
      document.getElementById('spielZielText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('skipEndBtn').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      const esb = document.getElementById('endSpielenBtn'); if (esb) esb.style.display = 'none';
      jokerRow.style.display = 'none'; jokerRow.style.opacity = '0'; // reset for demo
      document.getElementById('zumSpielBtn').style.display = 'none';
      document.getElementById('perfektGameText').style.display = 'none'; document.getElementById('gameEndText').style.display = 'none';
      actionButton.style.display = 'none';
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      hideSubtitle();
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      // Show reset button
      positionResetButton();

      // Compute timerTopPos if not yet set (demo may run before spielziel)
      if (!timerTopPos) {
        timerTopPos = '553px';
      }

      // Hit/Miss: random for single tutorial round
      const shouldHit = Math.random() < 0.6;

      // ==========================================
      // 1 TUTORIAL ROUND
      // ==========================================
      if (!autoDemoActive) return;
      await autoDemoRound(0, shouldHit);
      if (!autoDemoActive) return;

      // ==========================================
      // TUTORIAL END â€” show d5a/d5b/d5c
      // ==========================================
      document.getElementById('kippTarget').style.display = 'none';
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      await sleep(1500);
      if (!autoDemoActive) return;
      await showSubtitle(T.d5a, 3000);
      if (!autoDemoActive) return;
      await showSubtitle(T.d5b, 3000);
      if (!autoDemoActive) return;

      // Show Beginn-Button (skipEndBtn) instead of eye during d5c
      const skipBtnD5 = document.getElementById('skipEndBtn');
      skipBtnD5.style.display = 'block';
      document.getElementById('eyeIcon').style.display = 'none';

      // Show kniff icons at eye height, aligned with cards
      showKniffIcons();

      await showSubtitle(T.d5c, 4000);
      if (!autoDemoActive) return;

      // Keep eye + joker icons visible for user to explore
      hideSubtitle();

      // Stay here â€” user can reset via button or interact with icons
      autoDemoActive = false;
    }

    // === Single demo round ===
    async function autoDemoRound(roundIdx, shouldHit) {
      if (!autoDemoActive) return;

      activeCardIdx = roundIdx;

      // Helper: next CW direction from current quadrant
      function nextCwDir() {
        if (currentQuadrant === 3) return 'north';
        if (currentQuadrant === 0) return 'east';
        if (currentQuadrant === 1) return 'south_from_q1';
        return 'west_from_q2';
      }
      function nextCcwDir() {
        if (currentQuadrant === 3) return 'east_from_q3';
        if (currentQuadrant === 2) return 'north_from_q2';
        if (currentQuadrant === 1) return 'west';
        return 'south';
      }

      // ==========================================
      // 1) SHOW EYE ONLY + subtitle sequence
      // ==========================================
      const eyeIcon = document.getElementById('eyeIcon');
      eyeIcon.style.top = (parseInt(timerTopPos || '553') - 34) + 'px';
      eyeIcon.style.animation = '';
      eyeIcon.style.display = 'block';
      document.getElementById('skipEndBtn').style.display = 'none';
      countdown.style.display = 'none';

      // Subtitle: explain eye (1.5s pause first to let user settle)
      await sleep(1500);
      if (!autoDemoActive) return;
      await showSubtitleSequence(T.d1, 2500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 2) AUTO-"CLICK" EYE â†’ SCHAUEN
      // ==========================================
      eyeIcon.style.display = 'none';

      await sleep(400);
      if (!autoDemoActive) return;

      // WOBBLES + d1b SUBTITLES run in parallel
      async function doWobbles() {
        kippDirection = 'cw';
        for (let hw = 0; hw < 3; hw++) {
          const wobbles = 3 - hw;
          const pause = (hw < 2) ? 300 : 100;
          await halfKippWithWobble(nextCwDir(), wobbles, pause);
          if (!autoDemoActive) return;
          if (hw < 2) await sleep(200);
        }

        // Random extra move
        const extraOption = Math.floor(Math.random() * 4);
        if (extraOption === 1) {
          kippDirection = 'ccw';
          await sleep(300);
          await halfKippWithWobble(nextCcwDir(), 2, 100);
        } else if (extraOption === 2) {
          kippDirection = 'cw';
          await sleep(300);
          await halfKippWithWobble(nextCwDir(), 2, 100);
        } else if (extraOption === 3) {
          kippDirection = 'ccw';
          await sleep(300);
          await halfKippWithWobble(nextCcwDir(), 2, 200);
          if (!autoDemoActive) return;
          await sleep(200);
          await halfKippWithWobble(nextCcwDir(), 1, 0);
        }
      }

      // WOBBLES + d1b SUBTITLES: first 3 in parallel with wobbles, 4th with kippTarget
      async function doSubtitlesWithTarget() {
        // Show first 3 d1b lines normally
        for (let i = 0; i < T.d1b.length - 1; i++) {
          if (!autoDemoActive) return;
          const dur = (i === 0) ? 4000 : (i === 2) ? 3500 : 2500;
          await showSubtitle(T.d1b[i], dur);
        }
        if (!autoDemoActive) return;

        // Last d1b line: "FrÃ¼her abbrechen? Auf WÃ¼rfel tippen."
        // kippTarget entfernt in dieser Phase

        await showSubtitle(T.d1b[T.d1b.length - 1], 3500);
        if (!autoDemoActive) return;
      }

      await Promise.all([
        doWobbles(),
        doSubtitlesWithTarget()
      ]);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 3) PAUSE after SCHAUEN â€” counter keeps running
      // ==========================================
      await sleep(2000);
      if (!autoDemoActive) return;

      // Stop counter
      stopCountdown();
      countdown.style.display = 'none';

      // ==========================================
      // 4) SHOW VERDECKTES KIPPZIEL (pulsing) + subtitle
      // ==========================================
      const posX = cardStartX + roundIdx * (cardWidth + cardGap);
      verdecktesMesh.position.set(posX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      verdecktesMat.transparent = true;
      verdecktesMat.needsUpdate = true;
      verdecktesMesh.material = verdecktesMat;
      drawLeernohitOnVerdecktes();

      // Subtitle: "Klick dir dein KIPP ZIEL."
      await showSubtitle(T.d2, 2500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 5) AUTO-"CLICK" KIPPZIEL â†’ REVEAL
      // ==========================================

      const erfuellteKombis = getCurrentErfuellteKombis();
      let kz = generateNeueKombiOhne(erfuellteKombis);
      if (!kz) kz = generateNeueKombiOhne(new Set());
      if (!kz) { console.error('No kombi available!'); return; }

      autoRevealKippziel(kz.zahl, kz.color);
      bereitsAusgegeben.add(kz.zahl + '_' + kz.color.name);

      // Auge ausblenden, skipEnd-Button einblenden (nur Tutorial)
      document.getElementById('eyeIcon').style.display = 'none';
      const skipBtnEl = document.getElementById('skipEndBtn');
      skipBtnEl.style.top = (parseInt(timerTopPos || '553') + 50) + 'px';
      skipBtnEl.style.display = 'block';

      // ==========================================
      // 6) Show target circle + indicators (empty) immediately
      // ==========================================
      const kippTargetEl = document.getElementById('kippTarget');
      updateKippTargetPosition();
      kippTargetEl.style.width = '21px';
      kippTargetEl.style.height = '21px';
      kippTargetEl.style.animation = '';
      kippTargetEl.style.display = 'block';

      // Show indicator circles in adjacent quadrants (without numbers)
      tapCount = 0;
      updateTapIndicators();
      tapIndicatorA.mesh.visible = true;
      tapIndicatorB.mesh.visible = true;

      // ==========================================
      // 7) SUBTITLE SEQUENCE: explain kippziel + tippen/schubsen
      // ==========================================
      // Build d3 with actual zahl+farbe
      const farbDisplay = { violett: T.fV, blau: T.fB, gruen: T.fG, orange: T.fO };
      const d3Lines = T.d3.map(l => l.replace('{z}', kz.zahl).replace('{f}', (farbDisplay[kz.color.name] || kz.color.name)));

      await sleep(1500);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[0], 4000);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[1], 4500);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[2], 4500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 8) SOLVE & TAP
      // ==========================================
      const solution = solveKippziel(kz.zahl, kz.color.name, currentQuadrant, topFace);

      if (!solution) {
        console.error('No solution found!');
        return;
      }

      kippDirection = solution.dir;

      let execSteps;
      if (shouldHit) {
        execSteps = solution.steps;
      } else {
        execSteps = (solution.steps < 6) ? solution.steps + 1 : solution.steps - 1;
      }

      // TAP sequence: 1 per second, circle grows, cube flashes
      const baseSize = 14;
      kippTargetEl.style.animation = 'none';
      tapCount = 0;
      for (let i = 1; i <= execSteps; i++) {
        tapCount = i;
        updateTapIndicators();

        const newSize = baseSize + i * 7;
        kippTargetEl.style.width = newSize + 'px';
        kippTargetEl.style.height = newSize + 'px';

        // Flash cube
        const origEmissive = cube.material[2].emissive.getHex();
        cube.material.forEach(m => { m.emissive.setHex(0x444444); });
        setTimeout(() => {
          cube.material.forEach(m => { m.emissive.setHex(origEmissive); });
        }, 150);

        await sleep(1000);
        if (!autoDemoActive) return;
      }

      // 1.3 sec after last tap â†’ execute
      await sleep(1300);

      // Hide target + indicators, execute kipps
      kippTargetEl.style.display = 'none';
      kippTargetEl.style.animation = '';
      kippTargetEl.style.width = '21px';
      kippTargetEl.style.height = '21px';
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      await autoPerformKipps(execSteps, solution.dir);
      if (!autoDemoActive) return;

      // 2 sec wait â†’ show result
      await sleep(2000);

      autoDemoShowResult(shouldHit);
      if (shouldHit) {
        bereitsGetroffen.add(kz.zahl + '_' + kz.color.name);
      }

      // 2 sec with result visible
      await sleep(2000);
      if (!autoDemoActive) return;

      // Transfer to gameCard
      autoDemoTransferToCard(roundIdx);
    }

    // =========================
    // BUTTON EVENT LISTENERS
    // =========================
    let _startBtnLock = false;
    function handleStart(withTutorial) {
      if (!texturesReady || _startBtnLock) return;
      _startBtnLock = true;
      unlockAndPlayBgMusic();
      document.getElementById('startOverlay').style.display = 'none';
      startKipp21(withTutorial);
      setTimeout(() => { _startBtnLock = false; }, 1000);
    }
    document.getElementById('btnSpielen').addEventListener('click', () => handleStart(false));
    document.getElementById('btnSpielen').addEventListener('touchend', (e) => {
      e.preventDefault(); handleStart(false);
    }, { passive: false });
    document.getElementById('btnDemo').addEventListener('click', () => handleStart(true));
    document.getElementById('btnDemo').addEventListener('touchend', (e) => {
      e.preventDefault(); handleStart(true);
    }, { passive: false });
    
    
    // ZurÃ¼ck zur Startseite (resetButton in Start/Spielziel-Phase)
    function backToStartScreen() {
      // KIPP-TIPP Overlay schlieÃŸen falls offen
      // ReplayBlocker MUSS weg, sonst sind Buttons tot
      disableReplayBlocker();
      replayActive = false;
      document.getElementById('spielZielText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('skipEndBtn').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      const esb = document.getElementById('endSpielenBtn'); if (esb) esb.style.display = 'none';
      actionButton.style.display = 'none';
      countdown.style.display = 'none';
      hideSubtitle();
      verdecktesMesh.visible = false;
      // Alle KÃ¤rtchen ausblenden
      gameCards.forEach(c => c.mesh.visible = false);
      // Tap-Indikatoren ausblenden
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      // Start-Buttons wieder zeigen
      document.getElementById('startOverlay').style.display = 'block';
      const btnS = document.getElementById('btnSpielen');
      const btnD = document.getElementById('btnDemo');
      btnS.textContent = T.sp;
      btnD.textContent = T.dm;
      btnS.disabled = false;
      btnS.style.opacity = '1';
      btnD.disabled = false;
      btnD.style.opacity = '1';
      // Full state reset so SPIELEN starts clean
      erstesKippziel = null;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      activeCardIdx = 0;
      // WÃ¼rfelzahlen neu mischen und Faces neu aufbauen
      deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);
      updateFaceSlots();
      rebuildFaceMat('f0', 1);
      rebuildFaceMat('f1', 1);
      rebuildFaceMat('f2', 1);
      
      gamePhase = 'start';
    }
    
    // === ENTSCHEIDUNGS-PHASE ===
    function initEntscheidungPhase() {
      gamePhase = 'entscheidung';
      
      // SpielZiel-Text ausblenden
      document.getElementById('spielZielText').style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      
      // Reset-Button zeigen (1/2 A|B positioniert)
      positionResetButton();
      
      // WÃ¼rfel in Q3, ruhig liegend (kein Reset nÃ¶tig - steht schon)
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      // Verdecktes KÃ¤rtchen NICHT zeigen in Entscheidungsphase
      verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = false;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Augen-Icon 60px nÃ¶rdlicher positionieren (ohne verdecktes Kippziel)
      const eyeIcon = document.getElementById('eyeIcon');
      eyeIcon.style.top = (parseInt(timerTopPos || '553') - 34) + 'px';
      eyeIcon.style.animation = '';
      eyeIcon.style.display = 'block';
      document.getElementById('skipEndBtn').style.display = 'none';
      
      // Entscheidungs-Text nur beim ersten Mal zeigen
      const etText = document.getElementById('entscheidungText');
      if (isReplay) {
        etText.style.display = 'none';
      } else {
        etText.innerHTML = "<b>" + T.e1 + "</b><br>\u2022 " + T.e2 + "<br>\u2022 " + T.e3;
        etText.style.display = 'block';
      }
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }
    
    // Eye-Icon Click â†’ Schauen-Phase (Demo)
    const eyeEl = document.getElementById('eyeIcon');
    eyeEl.addEventListener('touchstart', (e) => {
      e.stopPropagation();
    }, { passive: false });
    eyeEl.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (replayActive) return; // Tutorial: keine Interaktion
      if (gamePhase === 'entscheidung') {
        if (activeCardIdx === 0) {
          spielzielToDemoPhase();
        } else {
          startFreeSchauenPhase();
        }
      } else if (gamePhase === 'spielen') {
        startSchauenDemo();
      } else {
      }
    }, { passive: false });
    eyeEl.addEventListener('click', (e) => {
      e.stopPropagation();
      if (gamePhase === 'entscheidung') {
        if (activeCardIdx === 0) {
          spielzielToDemoPhase();
        } else {
          startFreeSchauenPhase();
        }
      } else if (gamePhase === 'spielen') {
        startSchauenDemo();
      } else {
      }
    });
    
    // SkipEnd-Button Click â†’ Tutorial neu starten
    const skipEndEl = document.getElementById('skipEndBtn');
    skipEndEl.addEventListener('touchstart', (e) => {
      e.stopPropagation();
    }, { passive: false });
    skipEndEl.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      skipEndEl.style.display = 'none';
      if (texturesReady) runAutoDemo();
    }, { passive: false });
    skipEndEl.addEventListener('click', (e) => {
      e.stopPropagation();
      skipEndEl.style.display = 'none';
      if (texturesReady) runAutoDemo();
    });
    

    
    // Spielziel â†’ Demo Ãœbergang (jetzt von Entscheidung aufgerufen)
    function spielzielToDemoPhase() {
      gamePhase = 'demo';
      schauenWobbleActive = false;
      
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      const instrText = document.getElementById('instructionText');
      instrText.innerHTML = '<b>' + T.k1 + '</b><br>' + T.k2;
      instrText.style.display = isReplay ? 'none' : 'block';
      actionButton.style.display = 'none';
      countdown.style.display = 'none';
      
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      
      if (cube.parent !== kipGroup) {
        const oldP = cube.parent;
        if (oldP) oldP.remove(cube);
        kipGroup.add(cube);
      }
      
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      runSchauenWobbles();
    }
    
    function phaseKippenToSpielen() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      cubeLocked = false;
      
      // resetButton sichtbar halten in Spielen-Phase
      resetButton.style.display = 'block'; soundToggle.style.display = 'block';
      
      // WÃ¼rfel bleibt wo er in SCHAUEN war (kein Reset!)
      // topFace und currentQuadrant sind korrekt getrackt

      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons UNSICHTBAR und INAKTIV lassen
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Tutorial-Text nicht mehr nÃ¶tig (freies Kippen statt Tap-Mechanik)
      document.getElementById('tutorialText').style.display = 'none';
      
      // Zielscheibe NICHT mehr anzeigen (kein Tap-Count-System)
      document.getElementById('kippTarget').style.display = 'none';
      
      // Kein Timer-Display in Spielphase
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zurÃ¼cksetzen fÃ¼r Kipp-Regel
      kippCount = 0;
      // Tap-Counter nicht mehr nÃ¶tig
      tapCount = 0;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      
      // Eye-Icon nicht mehr zeigen (nur einmalig zu Spielbeginn)
      document.getElementById('eyeIcon').style.display = 'none';
      
      // Liegezeit-Tracking (erste Liegezeit = Denkzeit, kein Auto-Eval)
      liegeZeiten = [];
      liegeStartTime = performance.now();
      // KÃ¤rtchen werden in fillAllCards() sichtbar gemacht - NICHT hier

      // KÃ¤rtchen befÃ¼llen: Nur das erste (Index 0) initial generieren
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      
      // Alle Card-Flags zurÃ¼cksetzen
      gameCards.forEach(c => {
        c.zahl = null;
        c.color = null;
        c.isHit = false;
        c.isMiss = false;
      });
      
      // Warten bis Texturen geladen sind, dann KÃ¤rtchen befÃ¼llen
      function fillAllCards() {
        if (!texturesReady || !leerImage) {
          setTimeout(fillAllCards, 50);
          return;
        }
        
        // Erstes KÃ¤rtchen mit bereits generiertem Kippziel befÃ¼llen
        if (erstesKippziel) {
          fillCardWithKombi(0, erstesKippziel.zahl, erstesKippziel.color);
        } else {
          // Fallback falls kein Kippziel vorgemerkt
          const erfuellteKombis = getCurrentErfuellteKombis();
          const visibleZahlen = getCurrentVisibleZahlen();
          const zahlenFilter = openKippzielPositions.has(0) && offeneKippzieleVergeben < 2 ? 'open' : 'closed';
          let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
          if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis);
          if (neueKombi) {
            if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
            fillCardWithKombi(0, neueKombi.zahl, neueKombi.color);
          }
        }
        
        // Restliche 5 KÃ¤rtchen (i=1 bis i=5) UNSICHTBAR machen
        for (let i = 1; i < 6; i++) {
          gameCards[i].mesh.visible = false;
        }
      }
      fillAllCards();
      
      // Hinweis: Tippe auf Kippziel wenn fertig
      const tut1 = document.getElementById('tutorialText');
      tut1.innerHTML = '<span style="font-size:13px;color:#d4b48c;opacity:0.8;">Wenn du mit deinem Kippzug fertig bist, tippe auf dein Kippziel.</span>';
      tut1.style.display = 'block';
      
      setButtonsDisabled(false);
    }
    
    // === Spielen-Phase fÃ¼r Runde 2+ (ohne Reset) ===
    function startSpielenForCurrentRound() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      cubeLocked = false;
      
      // resetButton sichtbar halten
      resetButton.style.display = 'block'; soundToggle.style.display = 'block';
      
      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      // Eye-Icon nicht mehr zeigen (nur einmalig zu Spielbeginn)
      document.getElementById('eyeIcon').style.display = 'none';
      
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons versteckt
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Zielscheibe NICHT mehr anzeigen
      document.getElementById('kippTarget').style.display = 'none';
      
      // Timer aus
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zurÃ¼cksetzen
      kippCount = 0;
      // Tap-Counter nicht mehr nÃ¶tig
      tapCount = 0;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      
      // Liegezeit-Tracking
      liegeZeiten = [];
      liegeStartTime = performance.now();
      // Aktuelles KÃ¤rtchen mit dem generierten Kippziel befÃ¼llen
      if (erstesKippziel) {
        fillCardWithKombi(activeCardIdx, erstesKippziel.zahl, erstesKippziel.color);
      }
      
      // Hinweis: Tippe auf Kippziel wenn fertig
      const tut = document.getElementById('tutorialText');
      tut.innerHTML = '<span style="font-size:13px;color:#d4b48c;opacity:0.8;">Wenn du mit deinem Kippzug fertig bist, tippe auf dein Kippziel.</span>';
      tut.style.display = 'block';
      
      setButtonsDisabled(false);
    }

    actionButton.addEventListener('click', () => {
      if (gamePhase === 'spielziel') {
        initEntscheidungPhase();
      } else if (gamePhase === 'kippen') {
        phaseKippenToSpielen();
      } else if (gamePhase === 'pause') {
        endPausePhase();
      } else if (gamePhase === 'ende') {
        // Ende-Phase: actionButton ist versteckt, nichts tun
        return;
      }
    });
    
    // === Aufdecken des verdeckten Kippziels ===
    function revealVerdecktesKippziel() {
      if (!texturesReady) return;
      
      // SCHAUEN-Timer stoppen
      stopCountdown();
      countdown.style.display = 'none';
      
      // Demo-Animation stoppen falls noch aktiv
      schauenWobbleActive = false; isDemoAnimating = false;
      handDemo.visible = false;
      
      // Kippziel generieren mit open/closed Filter
      const erfuellteKombis = getCurrentErfuellteKombis();
      const visibleZahlen = getCurrentVisibleZahlen();
      
      let zahlenFilter = undefined;
      if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
        zahlenFilter = 'open';
      } else {
        zahlenFilter = 'closed';
      }
      
      erstesKippziel = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
      
      // Fallback: wenn Filter nichts liefert, ohne Filter versuchen
      if (!erstesKippziel) {
        erstesKippziel = generateNeueKombiOhne(erfuellteKombis);
      }
      if (!erstesKippziel) return;
      
      // Tracking: war es eine sichtbare Zahl?
      if (visibleZahlen.has(erstesKippziel.zahl)) {
        offeneKippzieleVergeben++;
      }
      
      // Farb-Image + Zahl auf verdecktes Canvas zeichnen
      const img = colorTargetImages[erstesKippziel.color.name];
      if (!img) return;
      
      verdecktesCtx.clearRect(0, 0, 85, 170);
      verdecktesCtx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
      verdecktesCtx.fillStyle = '#2a1810';
      verdecktesCtx.font = 'bold 56px Arial';
      verdecktesCtx.textAlign = 'center';
      verdecktesCtx.textBaseline = 'middle';
      verdecktesCtx.fillText(displayText, 42, 42);
      verdecktesCanvasTex.needsUpdate = true;
      
      // Puls stoppen, volle Deckkraft
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      verdecktesMesh.userData.revealed = true;
      
      // instructionText ausblenden
      document.getElementById('instructionText').style.display = 'none';
      // Entscheidungs-UI ausblenden
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('skipEndBtn').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      // KNIFF-Icons sofort mit Kippziel zeigen
      showKniffIcons();
      
      // Nach 1,5s Spielphase starten
      setTimeout(() => {
        if (activeCardIdx === 0) {
          phaseKippenToSpielen(); // Erste Runde: volles Init
        } else {
          startSpielenForCurrentRound(); // Folgerunden: ohne Reset
        }
      }, 1500);
    }
    
    // Tap-auf-WÃ¼rfel Flag
    let kippzielChecked = false;
    let cubeLocked = false;  // Sperre nach 1s Auswertung - kein Kippen bis nÃ¤chstes Kippziel
    let kipp21CardTouchHandled = false; // Verhindert synthetischen Click nach Touchend
    
    // verdecktes Kippziel Tap-Erkennung (Raycaster)
    const vkRaycaster = new THREE.Raycaster();
    const vkMouse = new THREE.Vector2();
    let lastTouchPos = null;
    
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (replayActive) return; // Tutorial: keine Interaktion
      if ((gamePhase === 'kippen' || gamePhase === 'entscheidung') && verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
        lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      // KIPP 21: Card tap detection
      if (gamePhase === 'kipp21' && kipp21Active) {
        dismissKippenWarning();
        lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }, { passive: true });
    
    renderer.domElement.addEventListener('touchend', (e) => {
      if (replayActive) return; // Tutorial: keine Interaktion
      // KIPP 21: Card tap detection
      if (gamePhase === 'kipp21' && kipp21Active && lastTouchPos && !dragActive) {
        const rect2 = renderer.domElement.getBoundingClientRect();
        
        vkMouse.x = ((lastTouchPos.x - rect2.left) / rect2.width) * 2 - 1;
        vkMouse.y = -((lastTouchPos.y - rect2.top) / rect2.height) * 2 + 1;
        vkRaycaster.setFromCamera(vkMouse, camera);
        
        for (let ci = 0; ci < 6; ci++) {
          if (kipp21CardStates[ci] === 'erledigt') continue;
          // Blick-Icon oder Karte treffen
          if ((blickIconMeshes[ci].visible && vkRaycaster.intersectObject(blickIconMeshes[ci]).length > 0) ||
              vkRaycaster.intersectObject(gameCards[ci].mesh).length > 0) {
            kipp21CardTouchHandled = true;
            setTimeout(() => { kipp21CardTouchHandled = false; }, 400);
            kipp21OnCardTap(ci);
            lastTouchPos = null;
            return;
          }
        }
      }
      
      if (!verdecktesMesh.visible || !lastTouchPos) { lastTouchPos = null; return; }
      if (dragActive) { lastTouchPos = null; return; }
      
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((lastTouchPos.x - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((lastTouchPos.y - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        if (gamePhase === 'entscheidung' && !verdecktesMesh.userData.revealed) {
          // Kippziel-Klick = Auge-Klick: Schauen/Demo starten
          if (activeCardIdx === 0) {
            spielzielToDemoPhase();
          } else {
            startFreeSchauenPhase();
          }
        } else if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        } else if (gamePhase === 'spielen' && !kippzielChecked && kippCount > 0) {
          // Spieler bestÃ¤tigt: "Mein Kippzug ist fertig"
          checkKippzielTap();
        }
      }
      lastTouchPos = null;
    }, { passive: true });
    
    // Desktop-Klick: Kippziel aufdecken (kippen) oder Schauen starten (entscheidung)
    renderer.domElement.addEventListener('click', (e) => {
      if (replayActive) return; // Tutorial: keine Interaktion
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      // KIPP 21: Card click detection (Desktop/Replay)
      if (gamePhase === 'kipp21' && kipp21Active && !kipp21CardTouchHandled) {
        // Pause-Button prÃ¼fen

        
        for (let ci = 0; ci < 6; ci++) {
          if (kipp21CardStates[ci] === 'erledigt') continue;
          if ((blickIconMeshes[ci].visible && vkRaycaster.intersectObject(blickIconMeshes[ci]).length > 0) ||
              vkRaycaster.intersectObject(gameCards[ci].mesh).length > 0) {
            kipp21OnCardTap(ci);
            return;
          }
        }
      }
      
      if (!verdecktesMesh.visible) return;
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        if (gamePhase === 'entscheidung' && !verdecktesMesh.userData.revealed) {
          if (activeCardIdx === 0) {
            spielzielToDemoPhase();
          } else {
            startFreeSchauenPhase();
          }
        } else if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        } else if (gamePhase === 'spielen' && !kippzielChecked && kippCount > 0) {
          checkKippzielTap();
        }
      }
    });
    
    // (Spielen: Freies Kippen + Tap auf Kippziel zum BestÃ¤tigen)
    
    // Kippziel-Check bei Tap auf WÃ¼rfel
    function checkKippzielTap() {
      if (!erstesKippziel || kippzielChecked) return;
      kippzielChecked = true;
      cubeLocked = true;  // WÃ¼rfel gesperrt bis nÃ¤chstes Kippziel
      hideKniffIcons();
      document.getElementById('tutorialText').style.display = 'none';
      
      // Eye-Icon ausblenden bei Wertung
      document.getElementById('eyeIcon').style.display = 'none';
      
      // Timer stoppen
      stopCountdown();
      
      // Treffer prÃ¼fen
      // Physische Verifikation: topFace + Quadrant aus 3D-State ableiten (Drift-Schutz)
      const physFace = getPhysicalTopFace();
      if (physFace !== topFace) {
        topFace = physFace;
      }
      const cubeWorldP = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldP);
      const physQ = (cubeWorldP.x < 0)
        ? (cubeWorldP.z < 0.1105 ? 0 : 3)
        : (cubeWorldP.z < 0.1105 ? 1 : 2);
      if (physQ !== currentQuadrant) {
        currentQuadrant = physQ;
      }
      
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      const off = faceOff[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };
      
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === erstesKippziel.zahl) { hitSlot = slot; break; }
      }
      
      let isHit = false;
      if (hitSlot) {
        const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
        isHit = (neighborColor === erstesKippziel.color.name);
      }
      
      drawKippzielBorder(isHit);
    }
    
    function drawKippzielBorder(isHit) {
      if (isHit) {
        // Treffer: goldgelber Rahmen mit Outer Glow
        // Glow-Effekt (mehrere halbtransparente Rahmen auÃŸenâ†’innen)
        verdecktesCtx.shadowColor = '#FFD700';
        verdecktesCtx.shadowBlur = 12;
        verdecktesCtx.strokeStyle = '#FFD700';
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCtx.shadowBlur = 0;
        
        // Innerer heller Rahmen
        verdecktesCtx.strokeStyle = '#FFF0A0';
        verdecktesCtx.lineWidth = 1;
        verdecktesCtx.strokeRect(7, 7, 71, 156);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Puls-Animation: kurz grÃ¶ÃŸer, dann zurÃ¼ck
        const origScale = 1;
        const pulseScale = 1.25;
        const pulseDur = 300;
        const startTime = performance.now();
        function pulseTick(now) {
          const t = Math.min((now - startTime) / pulseDur, 1);
          const s = t < 0.5
            ? origScale + (pulseScale - origScale) * (t * 2)
            : pulseScale - (pulseScale - origScale) * ((t - 0.5) * 2);
          verdecktesMesh.scale.set(s, s, s);
          if (t < 1) requestAnimationFrame(pulseTick);
          else verdecktesMesh.scale.set(origScale, origScale, origScale);
        }
        requestAnimationFrame(pulseTick);
        
        // Nach 2s zur nÃ¤chsten Runde
        setTimeout(() => proceedToNextRound(true), 2000);
        
      } else {
        // Miss: Zahl grau zeichnen
        const img = colorTargetImages[erstesKippziel.color.name];
        if (img) {
          verdecktesCtx.clearRect(0, 0, 85, 170);
          verdecktesCtx.drawImage(img, 0, 0, 85, 170);
          
          // FarbsÃ¤ttigung reduzieren
          verdecktesCtx.globalCompositeOperation = 'saturation';
          verdecktesCtx.fillStyle = 'hsl(0, 40%, 50%)';
          verdecktesCtx.fillRect(0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'source-over';
          
          // Zahl in Grau
          const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
          verdecktesCtx.fillStyle = '#888888';
          verdecktesCtx.font = 'bold 56px Arial';
          verdecktesCtx.textAlign = 'center';
          verdecktesCtx.textBaseline = 'middle';
          verdecktesCtx.fillText(displayText, 42, 42);
        }
        
        // Roter Rahmen
        verdecktesCtx.strokeStyle = '#FF2020';
        verdecktesCtx.lineWidth = 2;
        verdecktesCtx.strokeRect(1, 1, 83, 168);
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Nach 2s zur nÃ¤chsten Runde
        setTimeout(() => proceedToNextRound(false), 2000);
      }
    }

    function proceedToNextRound(isHit) {
      // 1. Visuellen Zustand von verdecktesMesh auf gameCard Ã¼bertragen
      const card = gameCards[activeCardIdx];
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(verdecktesCanvas, 0, 0);
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.visible = true;
      
      // 2. Treffer tracken
      if (isHit && erstesKippziel) {
        bereitsGetroffen.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 3. Kombi als ausgegeben markieren
      if (erstesKippziel) {
        bereitsAusgegeben.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 4. Weiter
      activeCardIdx++;
      
      // 5. Spielende?
      if (activeCardIdx >= 6) {
        verdecktesMesh.visible = false;
        document.getElementById('kippTarget').style.display = 'none';
        showGameEnd();
        return;
      }
      
      // 6. NÃ¤chste Entscheidungs-Runde
      initNextRoundEntscheidung();
    }

    function initNextRoundEntscheidung() {
      gamePhase = 'entscheidung';
      kippzielChecked = false;
      cubeLocked = false;
      erstesKippziel = null;
      
      // ALLE Texte ausblenden - nach erstem Kippziel keine Texte mehr
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      tapCount = 0;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // verdecktesMesh an nÃ¤chste KÃ¤rtchen-Position verschieben
      const nextX = cardStartX + activeCardIdx * (cardWidth + cardGap);
      verdecktesMesh.position.set(nextX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Eye-Icon nicht mehr zeigen (nur einmalig zu Spielbeginn)
      document.getElementById('eyeIcon').style.display = 'none';
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }

    function startFreeSchauenPhase() {
      gamePhase = 'kippen';
      
      // Ensure timerTopPos is set (skipped when isReplay bypasses spielziel)
      if (!timerTopPos) timerTopPos = '553px';
      
      // Auge ausblenden, keine Texte
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      
      // Timer bei 60 beginnen und abwÃ¤rts zÃ¤hlen
      countdown.textContent = '30';
      countdown.style.display = 'none'; // Timer jetzt unter Kippzielen
      if (timerTopPos) countdown.style.top = (parseInt(timerTopPos) + 45) + 'px';
      countdown.style.left = '180px';
      
      startCountdown(() => {
        if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        }
      }, 30);
      
      // WÃ¼rfel bleibt wo er ist - KEIN Reset!
    }


    // === Schauen aus SPIELEN (Auge-Klick) ===

    async function runSchauenWobbles() {
      schauenWobbleActive = true;

      function nextCwDir() {
        if (currentQuadrant === 3) return 'north';
        if (currentQuadrant === 0) return 'east';
        if (currentQuadrant === 1) return 'south_from_q1';
        return 'west_from_q2';
      }
      function nextCcwDir() {
        if (currentQuadrant === 3) return 'east_from_q3';
        if (currentQuadrant === 2) return 'north_from_q2';
        if (currentQuadrant === 1) return 'west';
        return 'south';
      }

      kippDirection = 'cw';
      for (let hw = 0; hw < 3; hw++) {
        if (!schauenWobbleActive) return;
        const wobbles = 3 - hw;
        const pause = (hw < 2) ? 300 : 100;
        await halfKippWithWobble(nextCwDir(), wobbles, pause);
        if (!schauenWobbleActive) return;
        if (hw < 2) await sleep(200);
      }

      const extraOption = Math.floor(Math.random() * 4);
      if (extraOption === 1) {
        kippDirection = 'ccw';
        await sleep(300);
        if (!schauenWobbleActive) return;
        await halfKippWithWobble(nextCcwDir(), 2, 100);
      } else if (extraOption === 2) {
        kippDirection = 'cw';
        await sleep(300);
        if (!schauenWobbleActive) return;
        await halfKippWithWobble(nextCwDir(), 2, 100);
      } else if (extraOption === 3) {
        kippDirection = 'ccw';
        await sleep(300);
        if (!schauenWobbleActive) return;
        await halfKippWithWobble(nextCcwDir(), 2, 200);
        if (!schauenWobbleActive) return;
        await sleep(200);
        await halfKippWithWobble(nextCcwDir(), 1, 0);
      }

      if (!schauenWobbleActive) return;
      finishSchauenWobbles();
    }

    function finishSchauenWobbles() {
      schauenWobbleActive = false;
      if (schauenFromSpielen) {
        schauenFromSpielen = false;
        gamePhase = 'spielen';
        kippzielChecked = false;
      cubeLocked = false;
        kippCount = 0;
        // Eye-Icon nicht mehr zeigen (nur einmalig zu Spielbeginn)
        document.getElementById('eyeIcon').style.display = 'none';
      } else {
        gamePhase = 'kippen';
        // Kein Timer - stattdessen verdecktes Kippziel pulsierend anzeigen
        countdown.style.display = 'none';
        const posX = cardStartX + activeCardIdx * (cardWidth + cardGap);
        verdecktesMesh.position.set(posX, cardY + 0.001, cardZ);
        verdecktesMesh.userData.revealed = false;
        drawLeernohitOnVerdecktes();
        verdecktesMesh.visible = true;
        verdecktesMesh.scale.set(1, 1, 1);
        verdecktesMat.opacity = 1;
        verdecktesMat.transparent = true;
        verdecktesMat.needsUpdate = true;
      }
    }

    function startSchauenDemo() {
      hideKniffIcons();
      gamePhase = 'demo';
      schauenFromSpielen = true;
      schauenWobbleActive = false;
      
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      stopCountdown();
      countdown.style.display = 'none';
      
      if (cube.parent !== kipGroup) {
        const oldP = cube.parent;
        if (oldP) oldP.remove(cube);
        kipGroup.add(cube);
      }
      
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      isAnimating = false;
      dragActive = false;
      
      runSchauenWobbles();
    }

    // Tutorial-Ende Buttons â†’ werden jetzt in showEndButtons() dynamisch erzeugt
    
    backButton.addEventListener('click', () => {
      if (gamePhase !== 'kippen' && gamePhase !== 'spielen') return;
      gamePhase = 'kippen'; // ZurÃ¼ck zu Phase 2
      currentMode = 'kanten';
      kippCount = 0;
      
      // UI zurÃ¼cksetzen zu Phase 2
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      stopCountdown();
      countdown.style.display = 'none';
      if (activeCardIdx === 0) {
        document.getElementById('instructionText').style.display = 'block';
      }
      document.getElementById('tutorialText').style.display = 'none';
      
      // SCHAUEN-Timer neu starten
      startCountdown(() => {
        if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        }
      }, 30);
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = false;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      erstesKippziel = null;
      kippzielChecked = false;
      cubeLocked = false;
      lockedKippDir = null;
      currentDragDir = null;
      tapCount = 0;
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      drawLeernohitOnVerdecktes();
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      // KÃ¤rtchen verstecken
      gameCards.forEach(c => c.mesh.visible = false);
      
      // WÃ¼rfel zurÃ¼cksetzen zu Q3
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.rotation.set(0, 0, 0);
      currentQuadrant = 3;
      topFace = 'f2'; // Anfangslage zurÃ¼cksetzen
      
    });
    
    // Reset-Button: Intelligente Navigation
    // - Auf Start-Overlay â†’ zurÃ¼ck zu index.html (HauptmenÃ¼)
    // - In Spielziel-Phase â†’ zurÃ¼ck zum Start-Overlay
    // - In allen anderen Phasen â†’ Reset + zurÃ¼ck zum Start-Overlay
    resetButton.addEventListener('click', () => {
      if (gamePhase === 'start') {
        window.location.href = 'index.html';
        return;
      }
      
      // ===== NUKLEARER CLEANUP =====
      // 1. Alles stoppen
      gamePhase = 'start';
      kipp21Generation++; // Alte Async-Chains invalidieren
      autoDemoActive = false;
      replayActive = false;
      kipp21Active = false;
      kipp21TimerRunning = false;
      kipp21KniffActive = false;
      kipp21KniffAbort = true;
      schauenWobbleActive = false;
      isDemoAnimating = false;
      isAnimating = false;
      dragActive = false;
      if (kipp21TimerInterval) { clearInterval(kipp21TimerInterval); kipp21TimerInterval = null; }
      stopCountdown();
      disableReplayBlocker();
      renderer.domElement.style.pointerEvents = 'auto';
      
      // 2. ALLE dynamischen Elemente aus uiOverlay entfernen
      ['auswertungBtn', 'endSpielenBtn', 'endKippPrinzipBtn', 'endMotivText', 'endScoreBtn', 'kipps21Label', 'timeoutNeuesSpielBtn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.remove();
      });
      document.querySelectorAll('.end-btn-dynamic, .hit-text-el').forEach(el => el.remove());
      hitTextEls.length = 0;
      
      // 3. Hand/Demo ausblenden
      handDemo.visible = false;
      if (handEl) { handEl.style.opacity = '0'; updateHandShadow(0,0,false); }
      
      // 4. ALLE UI-Elemente verstecken
      ['instructionText','tutorialText','eyeIcon','entscheidungText',
       'zumSpielBtn','perfektGameText','gameEndText','spielZielText','skipEndBtn',
       'kippTarget','demoSubtitle'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
      const jr2 = document.getElementById('jokerIconsRow');
      if (jr2) { jr2.style.display = 'none'; jr2.style.opacity = '0'; }
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      // 5. 3D zurÃ¼cksetzen
      if (cube.parent !== kipGroup) {
        const oldP = cube.parent;
        if (oldP) oldP.remove(cube);
        kipGroup.add(cube);
      }
      gameCards.forEach(c => c.mesh.visible = false);
      verdecktesMesh.visible = false;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      kippCount = 0;
      lockedKippDir = null;
      currentDragDir = null;
      erstesKippziel = null;
      kippzielChecked = false;
      cubeLocked = false;
      tapCount = 0;
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      counterOrigPos = null;
      
      // 6. Start-Overlay zeigen
      backToStartScreen();
    });

    // =========================
    // WÃœRFEL-KIPPMECHANIK
    // =========================
    // DRAG-KIPP-STEUERUNG (Phase 2)
    // =========================
    let isSwiping = false;
    let swipeStartX = 0;
    let swipeStartY = 0;
    let isAnimating = false;
    let currentQuadrant = 3;

    // Drag-State
    let dragActive = false;
    let dragPivotGroup = null;
    let dragAxis = null;
    let dragTargetSign = 0;
    let dragToQ = 0;
    let dragCurrentAngle = 0;
    const DRAG_SENSITIVITY = 150; // px fÃ¼r volle 90Â°

    // =========================
    // PAUSE-PHASE: Ecke-Drehinteraktion
    // =========================
    // 8 Ecken des WÃ¼rfels nach body-diagonal-Rotation (Pivot = Ecke, vorberechnet)
    const ECKE_CORNERS = [
      [ 0.000000,  0.000000,  0.000000],
      [ 0.369691,  0.270633, -0.099059],
      [-0.270633,  0.270633, -0.270633],
      [-0.099059,  0.270633,  0.369691],
      [ 0.099059,  0.541266, -0.369691],
      [ 0.270633,  0.541266,  0.270633],
      [-0.369691,  0.541266,  0.099059],
      [ 0.000000,  0.811899,  0.000000]
    ];
    // Frame-Grenzen relativ zum Pivot (0, 0, 0.109375)
    const PAUSE_LIMIT_S =  0.4705;   // sÃ¼d  (wallInnerSouth - pivotZ)
    const PAUSE_LIMIT_N =  0.46875;  // nord
    const PAUSE_LIMIT_E =  0.46875;  // ost
    const PAUSE_LIMIT_W =  0.46875;  // west

    function isPausePoseValid(alpha, beta) {
      const ca = Math.cos(alpha), sa = Math.sin(alpha);
      const cb = Math.cos(beta),  sb = Math.sin(beta);
      for (const [x, y, z] of ECKE_CORNERS) {
        // Ry(Î²) zuerst
        const x1 =  x * cb + z * sb;
        const z1 = -x * sb + z * cb;
        // Rx(Î±) danach
        const z2 = y * sa + z1 * ca;
        // x Ã¤ndert sich durch Rx nicht â†’ x1 bleiben
        if ( x1 > PAUSE_LIMIT_E || -x1 > PAUSE_LIMIT_W) return false;
        if ( z2 > PAUSE_LIMIT_S || -z2 > PAUSE_LIMIT_N) return false;
      }
      return true;
    }

    function getMaxBeta(alpha, sign) {
      // sign: +1 oder -1
      if (!isPausePoseValid(alpha, 0)) return 0;
      let lo = 0, hi = Math.PI;
      for (let i = 0; i < 16; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(alpha, sign * mid)) lo = mid; else hi = mid;
      }
      return lo;
    }

    function getMaxAlpha(beta) {
      if (!isPausePoseValid(0, beta)) return 0;
      let lo = 0, hi = Math.PI / 6; // 30Â° als obere Suche
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(mid, beta)) lo = mid; else hi = mid;
      }
      return lo;
    }

    let pausePivotGroup = null;
    let aufEckeTargetQuat = null;
    let pauseSpringRunning = false;
    let pauseTimerRef = null;
    let pauseExiting = false;
    let savedCubePosition = null;  // Position vor animateAufEcke
    let savedCubeQuaternion = null; // Quaternion vor animateAufEcke
    let savedTopFace = null;  // topFace vor animateAufEcke
    let savedCurrentQuadrant = null; // currentQuadrant vor animateAufEcke
    let pauseAlpha = 0;
    let pauseBeta  = 0;
    let pauseDragActive = false;
    let pauseDragStartX = 0;
    let pauseDragStartY = 0;
    let pauseDragStartAlpha = 0;
    let pauseDragStartBeta  = 0;
    const PAUSE_SENSITIVITY = 200; // px fÃ¼r ~30Â°

    function getKippConfig(direction) {
      const configs = {
        'north':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation: -Math.PI/2, toQ: 0 },
        'south':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation:  Math.PI/2, toQ: 3 },
        'east':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 1 },
        'west':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 2 }
      };
      return configs[direction];
    }

    function getValidDirection(deltaX, deltaY) {
      if (Math.abs(deltaY) >= Math.abs(deltaX)) {
        if (deltaY < 0) {
          if (currentQuadrant === 3) return 'north';
          if (currentQuadrant === 2) return 'north_from_q2';
        } else {
          if (currentQuadrant === 0) return 'south';
          if (currentQuadrant === 1) return 'south_from_q1';
        }
      } else {
        if (deltaX > 0) {
          if (currentQuadrant === 0) return 'east';
          if (currentQuadrant === 3) return 'east_from_q3';
        } else {
          if (currentQuadrant === 1) return 'west';
          if (currentQuadrant === 2) return 'west_from_q2';
        }
      }
      return null;
    }


    renderer.domElement.addEventListener('touchstart', (e) => {
      // Start-Phase: keine Touch-Interaktion
      if (gamePhase === 'start') return;
      // Demo-Phase: KEINE Touch-Interaktion (Demo lÃ¤uft automatisch)
      if (gamePhase === 'demo') return;
      // Tutorial: KEINE Interaktion
      if (replayActive) return;
      
      if (gamePhase === 'pause' && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        pauseDragStartX = touch.clientX;
        pauseDragStartY = touch.clientY;
        pauseDragStartAlpha = pauseAlpha;
        pauseDragStartBeta  = pauseBeta;
        pauseDragActive = true;
        return;
      }
      if (currentMode === 'kanten' && (gamePhase === 'kippen' || gamePhase === 'spielen' || gamePhase === 'kipp21')) {
        dismissKippenWarning();
        if (isAnimating || kipp21KniffActive) return;
        if (gamePhase === 'kipp21' && !kipp21Active) return; // Aufbau lÃ¤uft noch
        if (cubeLocked && gamePhase !== 'kipp21') return;
        if (gamePhase === 'kipp21' && kipp21HitLock) return; // Treffer erkannt â†’ WÃ¼rfel gesperrt
        // Kipp21: Nur kippen wenn ein Kippziel aufgedeckt ist
        if (gamePhase === 'kipp21' && kipp21CardStates.indexOf('offen') < 0) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        dragActive = false;
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (gamePhase === 'pause' && pauseDragActive && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        const dx = touch.clientX - pauseDragStartX;
        const dy = touch.clientY - pauseDragStartY;

        // Î²: X-Drag â†’ Y-Rotation (links = positiv)
        let newBeta  = pauseDragStartBeta  + (dx / PAUSE_SENSITIVITY) * Math.PI;
        // Î±: Y-Drag nach unten â†’ Tilt nach SÃ¼den
        let newAlpha = pauseDragStartAlpha + (dy / PAUSE_SENSITIVITY) * (Math.PI / 3);
        newAlpha = Math.max(0, newAlpha);

        // Alpha clampen bei gegebenem Beta
        const maxA = getMaxAlpha(newBeta);
        newAlpha = Math.min(newAlpha, maxA);

        // Beta clampen bei gegebenem Alpha
        if (!isPausePoseValid(newAlpha, newBeta)) {
          const sign = newBeta >= 0 ? 1 : -1;
          const maxB = getMaxBeta(newAlpha, sign);
          newBeta = sign * maxB;
        }

        pauseAlpha = newAlpha;
        pauseBeta  = newBeta;

        // Euler 'YXZ': erst Ry(Î²), dann Rx(Î±)
        pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');
        return;
      }
      if (!isSwiping || isAnimating || (gamePhase !== 'kippen' && gamePhase !== 'spielen' && gamePhase !== 'kipp21') || currentMode !== 'kanten') return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - swipeStartX;
      const deltaY = touch.clientY - swipeStartY;

      // Warte auf minimale Bewegung bevor Richtung bestimmt wird
      if (!dragActive) {
        if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < 8) return;
        if (kipp21HitLock) return; // Treffer erkannt â†’ kein neuer Kipp

        const direction = getValidDirection(deltaX, deltaY);
        if (!direction) { isSwiping = false; return; }
        
        // SPIELEN-Phase: freies Dragging wie in KIPPEN (kein Auto-Kipp mehr)
        // â†’ durchfallen lassen zu normalem Drag-Code
        
        // Auto-Eval-Timer bei neuem Kipp abbrechen
        // Manueller Drag
        currentDragDir = direction;

        const config = getKippConfig(direction);
        dragAxis = config.axis;
        dragTargetSign = config.targetRotation > 0 ? 1 : -1;
        dragToQ = config.toQ;

        // Pivot-Gruppe setup
        dragPivotGroup = new THREE.Group();
        dragPivotGroup.position.copy(config.pivotPoint);
        kipGroup.add(dragPivotGroup);

        cube.updateMatrixWorld();
        const cubeWorldPos = new THREE.Vector3();
        cube.getWorldPosition(cubeWorldPos);
        kipGroup.remove(cube);
        cube.position.copy(cubeWorldPos.clone().sub(config.pivotPoint));
        dragPivotGroup.add(cube);

        dragActive = true;
        dragCurrentAngle = 0;
        // KIPP 21: Timer starten bei WÃ¼rfelberÃ¼hrung
        if (gamePhase === 'kipp21' && kipp21Active && kipp21CardStates.includes('offen') && !kipp21TimerRunning) {
          kipp21StartRoundTimer();
        }


      }

      // Rotation live berechnen
      // X-Achse: deltaY direkt (oben neg, unten pos)
      // Z-Achse: -deltaX (rechts pos wird neg Rotation)
      const relevantDelta = (dragAxis === 'x') ? deltaY : -deltaX;
      let angle = (relevantDelta / DRAG_SENSITIVITY) * (Math.PI / 2);

      // Clamp zwischen 0 und targetRotation
      if (dragTargetSign > 0) {
        angle = Math.max(0, Math.min(Math.PI / 2, angle));
      } else {
        angle = Math.min(0, Math.max(-Math.PI / 2, angle));
      }

      dragCurrentAngle = angle;

      if (dragAxis === 'x') {
        dragPivotGroup.rotation.x = dragCurrentAngle;
      } else {
        dragPivotGroup.rotation.z = dragCurrentAngle;
      }
    });

    function finishPauseToSpiel() {
      // PivotGroup auflÃ¶sen
      if (pausePivotGroup) {
        pausePivotGroup.remove(cube);
        kipGroup.remove(pausePivotGroup);
        pausePivotGroup = null;
        kipGroup.add(cube);
      }

      // Gespeicherter Zustand vor der Pause â€” immer wiederherstellen
      cube.position.copy(savedCubePosition);
      cube.quaternion.copy(savedCubeQuaternion);
      topFace = savedTopFace;
      currentQuadrant = savedCurrentQuadrant;

      gamePhase = 'spielen';
      // Buttons bleiben versteckt (Tutorial-Modus: Swipe-Kipping)
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      updateKippTargetPosition();
      document.getElementById('kippTarget').style.display = 'block';

      // Pause-Lichter aus
      pauseLights.forEach(l => l.visible = false);
      
      // Nur die bereits gespielten KÃ¤rtchen sichtbar machen und opacity wiederherstellen
      gameCards.forEach((c, i) => {
        if (c.zahl || c.isHit || c.isMiss) {
          c.mesh.visible = true;
          if (i < savedCardOpacities.length) {
            c.mesh.material.opacity = savedCardOpacities[i];
            c.mesh.material.transparent = (savedCardOpacities[i] < 1);
            c.mesh.material.needsUpdate = true;
          }
        }
      });
      
      setButtonsDisabled(false);
    }

    renderer.domElement.addEventListener('touchend', () => {
      if (replayActive) return; // Tutorial: keine Interaktion
      if (gamePhase === 'pause') {
        pauseDragActive = false;
        return;
      }
      isSwiping = false;
      
      if (!dragActive) return;

      // Tipping-Point bei 45Â° (PI/4)
      const absAngle = Math.abs(dragCurrentAngle);
      let targetAngle, finalQ;

      if (absAngle > Math.PI / 4) {
        targetAngle = dragTargetSign * Math.PI / 2; // Kippen
        finalQ = dragToQ;
      } else {
        targetAngle = 0; // ZurÃ¼ckfallen
        finalQ = currentQuadrant;
      }

      // Schwerkraft-Fall-Animation
      isAnimating = true;
      let dragKlackFired = false;
      const startAngle = dragCurrentAngle;
      const angleDiff = targetAngle - startAngle;
      const fallDuration = Math.max(150, Math.abs(angleDiff) / (Math.PI / 2) * 420);
      const startTime = Date.now();

      function animateFall() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fallDuration, 1);

        // Ease-in (tÂ²) = Schwerkraft-Beschleunigung
        const eased = progress * progress;
        const currentAngle = startAngle + angleDiff * eased;

        if (dragAxis === 'x') {
          dragPivotGroup.rotation.x = currentAngle;
        } else {
          dragPivotGroup.rotation.z = currentAngle;
        }

        // Klack kurz VOR dem Aufsetzen (wie im Tutorial)
        if (!dragKlackFired && eased > 0.88 && targetAngle !== 0) {
          dragKlackFired = true;
          playKlack();
        }

        if (progress < 1) {
          requestAnimationFrame(animateFall);
        } else {
          if (targetAngle === 0) {
            // ZurÃ¼ckgefallen: kein Klack
            cube.updateMatrixWorld();
            const newPos = new THREE.Vector3();
            cube.getWorldPosition(newPos);
            const newQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newQuat);
            dragPivotGroup.remove(cube);
            kipGroup.remove(dragPivotGroup);
            cube.position.copy(newPos);
            cube.quaternion.copy(newQuat);
            kipGroup.add(cube);
          } else {
            // Gekippt: finalisieren
            finalizeKipp(finalQ, null);
            // topFace bei jedem Kipp aktualisieren (kippen + spielen)
            if ((gamePhase === 'kippen' || gamePhase === 'spielen' || gamePhase === 'kipp21') && currentDragDir) {
              const isCW = CW_DIRS.has(currentDragDir);
              kippDirection = isCW ? 'cw' : 'ccw';
              advanceTopFace();
            }

            // SPIELEN: kippCount erhÃ¶hen
            if (gamePhase === 'spielen' && !kippzielChecked) {
              kippCount++;
              // BestÃ¤tigungs-Haken in Ecken zeigen
              showEckeHaken();
            }
            // KIPP 21: Kipp zÃ¤hlen + On-Target prÃ¼fen
            if (gamePhase === 'kipp21' && kipp21Active) {
              kipp21KippCount++;
              kipp21RoundKipps++;
              hintText.innerHTML = formatKipps(kipp21KippCount);
              checkOnTargetAfterKipp();
            }


          }
          dragActive = false;
          dragPivotGroup = null;
          isAnimating = false;
        }
      }

      animateFall();
    });

    // Desktop-Support: Click startet Spielphase
    renderer.domElement.addEventListener('click', (e) => {
      // Demo-Phase: KEINE Click-Interaktion
      if (gamePhase === 'demo') return;
    });
    
    async function performKipp(direction, duration = 800) {
      console.log('[KIPP] performKipp ENTER dir='+direction, 'dur='+duration, 'isAnim='+isAnimating);
      if (isAnimating) { console.warn('[KIPP] BLOCKED by isAnimating!'); return; }
      isAnimating = true;
      
      let pivotPoint, axis, targetRotation, fromQ, toQ;
      
      if (direction === 'north') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 0;
      } else if (direction === 'south') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 0;
        toQ = 3;
      } else if (direction === 'east') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 0;
        toQ = 1;
      } else if (direction === 'west') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 0;
      } else if (direction === 'south_from_q1') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 2;
      } else if (direction === 'north_from_q2') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 2;
        toQ = 1;
      } else if (direction === 'west_from_q2') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 2;
        toQ = 3;
      } else if (direction === 'east_from_q3') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 2;
      }
      
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);
      
      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      
      kipGroup.remove(cube);
      
      const relativePos = cubeWorldPos.clone().sub(pivotPoint);
      cube.position.copy(relativePos);
      pivotGroup.add(cube);
      
      const startTime = Date.now();
      let klackFired = false;
      
      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          if (axis === 'x') {
            pivotGroup.rotation.x = eased * targetRotation;
          } else {
            pivotGroup.rotation.z = eased * targetRotation;
          }
          
          // Klack kurz VOR dem Aufsetzen (eased > 0.95 â‰ˆ letzten 5% der Bewegung)
          if (!klackFired && eased > 0.95) {
            klackFired = true;
            playKlack();
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            finalizeKipp(toQ, resolve);
          }
        }
        
        animate();
      });
    }
    
    function finalizeKipp(newQ, callback) {
      console.log('[KIPP] finalizeKipp Q='+newQ);
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);
      
      const parent = cube.parent;
      if (parent && parent.parent) {
        parent.parent.remove(parent);
      }
      
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);
      
      currentQuadrant = newQ;
      isAnimating = false;
      if (callback) callback();
    }

    // =========================
    // KIPP-SEQUENZ mit 2D-Timing
    // =========================
    // ReplayAbort: Spezielle Error-Klasse fÃ¼r sauberen Abbruch
    class ReplayAbort extends Error { constructor() { super('ReplayAbort'); } }
    
    function sleep(ms) {
      const gen = kipp21Generation;
      const wasReplay = replayActive;
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          // Nur wÃ¤hrend Replay: Generation-Check â†’ Abbruch
          if (wasReplay && kipp21Generation !== gen) reject(new ReplayAbort());
          else resolve();
        }, ms);
      });
    }

    async function runKippSequence(steps) {
      if (isAnimating) return;
      
      const T = getTiming();
      const kipFactor = 1;
      
      
      for (let i = 0; i < steps; i++) {
        const tStep = (steps <= 1) ? 0 : (i / (steps - 1));
        const stepMul = lerp(1.0, STEP_MAX, tStep);
        
        const kipTime = Math.max(40, Math.round(T.kipMs * kipFactor * stepMul));
        const holdTime = Math.max(40, Math.round(T.wMs * stepMul));
        
        
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north'; // Q3
        } else {
          // CCW: umgekehrte Reihenfolge
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3'; // Q3
        }
        
        await performKipp(direction, kipTime);
        advanceTopFace();
        await sleep(holdTime);
      }
    }

    // === Auto-Kipp-Sequenz fÃ¼r Spielphase ===
    async function runAutoKippSequence(steps) {
      if (isAnimating || kippzielChecked) return;
      isAnimating = true;
      
      // Tap-Counter und Zielkreis ausblenden
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      document.getElementById('kippTarget').style.display = 'none';
      
      for (let i = 0; i < steps; i++) {
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north';
        } else {
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3';
        }
        
        isAnimating = false; // performKipp setzt isAnimating selbst
        await performKipp(direction, 700);
        advanceTopFace();
        
        // Kurze Pause zwischen Kipps
        if (i < steps - 1) {
          await sleep(300);
        }
      }
      
      kippCount = steps;
      isAnimating = false;
      
      // Trefferwertung nach kurzem Moment
      await sleep(200);
      checkKippzielTap();
    }

    // =========================
    // CW/CCW Richtung
    let kippDirection = 'cw';
    
    // Richtungsklassifizierung fÃ¼r Swipe-Kipping
    const CW_DIRS = new Set(['east', 'south_from_q1', 'west_from_q2', 'north']);
    const CCW_DIRS = new Set(['south', 'west', 'north_from_q2', 'east_from_q3']);
    let lockedKippDir = null; // null, 'cw', 'ccw'
    let currentDragDir = null;
    
    const cwBtn = document.getElementById('cwBtn');
    const ccwBtn = document.getElementById('ccwBtn');

    function updateRichtungButtons() {
      if (kippDirection === 'cw') {
        cwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        cwBtn.style.color = '#c0b870';
        cwBtn.style.borderColor = '#d4b48c';
        cwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        ccwBtn.style.color = '#c0b8a8';
        ccwBtn.style.borderColor = '#808080';
        ccwBtn.style.boxShadow = '';
      } else {
        ccwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        ccwBtn.style.color = '#c0b870';
        ccwBtn.style.borderColor = '#d4b48c';
        ccwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        cwBtn.style.color = '#c0b8a8';
        cwBtn.style.borderColor = '#808080';
        cwBtn.style.boxShadow = '';
      }
    }
    // CW/CCW werden durch triggerKipp weiter unten gehandelt

    // =========================
    // Zwei-Schritt Ablauf: erst Zahl wÃ¤hlen, dann Richtung
    // =========================
    let selectedAnzahl = null;

    function setButtonsDisabled(disabled) {
      document.querySelectorAll('.kippBtn').forEach(btn => {
        btn.disabled = disabled;
        btn.classList.remove('pulsing');
        if (!disabled) {
          btn.style.background = btn.id === 'cwBtn' || btn.id === 'ccwBtn'
            ? 'linear-gradient(180deg,#404040 0%,#303030 100%)'
            : 'linear-gradient(180deg,#606060 0%,#404040 100%)';
          btn.style.color = '#c0b8a8';
          btn.style.borderColor = '#808080';
          btn.style.boxShadow = '';
        }
      });
      if (!disabled) startZahlWarten();
    }

    function pulseZahlenButtons(on) {
      document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
        if (on) btn.classList.add('pulsing');
        else btn.classList.remove('pulsing');
      });
    }
    function pulseRichtungButtons(on) {
      if (on) { cwBtn.classList.add('pulsing'); ccwBtn.classList.add('pulsing'); }
      else    { cwBtn.classList.remove('pulsing'); ccwBtn.classList.remove('pulsing'); }
    }

    function startZahlWarten() {
      selectedAnzahl = null;
      pulseZahlenButtons(true);
      pulseRichtungButtons(false);
      // Richtungsbuttons neutral (keine Hervorhebuung)
      cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      cwBtn.style.color = '#c0b8a8';
      cwBtn.style.borderColor = '#808080';
      cwBtn.style.boxShadow = '';
      ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      ccwBtn.style.color = '#c0b8a8';
      ccwBtn.style.borderColor = '#808080';
      ccwBtn.style.boxShadow = '';
    }

    function startRichtungWarten() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(true);
    }

    function stopAllenPulse() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(false);
    }

    // Zahl-Buttons: nur Zahl speichern, kein Kipp
    document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gamePhase !== 'spielen') return;
        if (selectedAnzahl !== null) return; // schon eine Zahl gewÃ¤hlt

        selectedAnzahl = parseInt(btn.dataset.anzahl);

        // GewÃ¤hlte Zahl hervorheben
        btn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        btn.style.color = '#c0b870';
        btn.style.borderColor = '#d4b48c';
        btn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';

        startRichtungWarten();
      });
    });

    // CW/CCW: wenn Zahl schon gewÃ¤hlt â†’ Kipp starten
    async function triggerKipp(direction) {
      if (gamePhase !== 'spielen') return;
      if (selectedAnzahl === null) return; // noch keine Zahl â†’ nur Richtung anzeigen

      const anzahl = selectedAnzahl;
      stopAllenPulse();
      setButtonsDisabled(true);

      kippDirection = direction;
      updateRichtungButtons();

      // Zielkreis ausblenden wÃ¤hrend Kipp-Animation
      document.getElementById('kippTarget').style.display = 'none';

      // KÃ¤rtchen auf Original zurÃ¼cksetzen - Image neu zeichnen
      const card = gameCards[activeCardIdx];
      const img = colorTargetImages[card.color.name];
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = card.zahl + ((card.zahl === 6 || card.zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      card.texture.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.material.opacity = 1.0;

      await runKippSequence(anzahl);

      // Treffer-PrÃ¼fung
      const treffer = checkTreffer();
      if (treffer) {
        bereitsGetroffen.add(card.zahl + '_' + card.color.name);
        animateTreffer(treffer);
      } else {
        animateNichtTreffer();
      }
    }

    cwBtn.addEventListener('click', () => triggerKipp('cw'));
    ccwBtn.addEventListener('click', () => triggerKipp('ccw'));

    // Animation loop
    function renderLoop() {
      requestAnimationFrame(renderLoop);
      
      // Puls-Animation fÃ¼r verdecktes Kippziel (nur wenn nicht aufgedeckt)
      if (verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
        const t = (Date.now() % 1500) / 1500 * Math.PI * 2;
        const pulse = (Math.sin(t) + 1) / 2; // 0 bis 1
        const s = 1 + 0.08 * pulse;
        verdecktesMesh.scale.set(s, s, s);
        verdecktesMat.opacity = 1 - 0.4 * pulse;
      }
      
      renderer.render(scene, camera);
    }

    // resetButton auf Einstiegsseite sofort sichtbar + positionieren
    positionResetButton();

    renderLoop();
  </script>
</body>
</html>
